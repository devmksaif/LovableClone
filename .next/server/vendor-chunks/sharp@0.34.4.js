"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sharp@0.34.4";
exports.ids = ["vendor-chunks/sharp@0.34.4"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/channel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/channel.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Remove alpha channels, if any. This is a no-op if the image does not have an alpha channel.\n *\n * See also {@link /api-operation#flatten|flatten}.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction removeAlpha () {\n  this.options.removeAlpha = true;\n  return this;\n}\n\n/**\n * Ensure the output image has an alpha transparency channel.\n * If missing, the added alpha channel will have the specified\n * transparency level, defaulting to fully-opaque (1).\n * This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * // rgba.png will be a 4 channel image with a fully-opaque alpha channel\n * await sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png')\n *\n * @example\n * // rgba is a 4 channel image with a fully-transparent alpha channel\n * const rgba = await sharp(rgb)\n *   .ensureAlpha(0)\n *   .toBuffer();\n *\n * @param {number} [alpha=1] - alpha transparency level (0=fully-transparent, 1=fully-opaque)\n * @returns {Sharp}\n * @throws {Error} Invalid alpha transparency level\n */\nfunction ensureAlpha (alpha) {\n  if (is.defined(alpha)) {\n    if (is.number(alpha) && is.inRange(alpha, 0, 1)) {\n      this.options.ensureAlpha = alpha;\n    } else {\n      throw is.invalidParameterError('alpha', 'number between 0 and 1', alpha);\n    }\n  } else {\n    this.options.ensureAlpha = 1;\n  }\n  return this;\n}\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * The output colourspace will be either `b-w` (8-bit) or `grey16` (16-bit).\n *\n * @example\n * // green.jpg is a greyscale image containing the green channel of the input\n * await sharp(input)\n *   .extractChannel('green')\n *   .toFile('green.jpg');\n *\n * @example\n * // red1 is the red value of the first pixel, red2 the second pixel etc.\n * const [red1, red2, ...] = await sharp(input)\n *   .extractChannel(0)\n *   .raw()\n *   .toBuffer();\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel (channel) {\n  const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n  return this;\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel (images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool (boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxrRkFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoYXJwQDAuMzQuNC9ub2RlX21vZHVsZXMvc2hhcnAvbGliL2NoYW5uZWwuanM/ZmFhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMyBMb3ZlbGwgRnVsbGVyIGFuZCBvdGhlcnMuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzID0gcmVxdWlyZSgnLi9pcycpO1xuXG4vKipcbiAqIEJvb2xlYW4gb3BlcmF0aW9ucyBmb3IgYmFuZGJvb2wuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBib29sID0ge1xuICBhbmQ6ICdhbmQnLFxuICBvcjogJ29yJyxcbiAgZW9yOiAnZW9yJ1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxwaGEgY2hhbm5lbHMsIGlmIGFueS4gVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGFuIGFscGhhIGNoYW5uZWwuXG4gKlxuICogU2VlIGFsc28ge0BsaW5rIC9hcGktb3BlcmF0aW9uI2ZsYXR0ZW58ZmxhdHRlbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKCdyZ2JhLnBuZycpXG4gKiAgIC5yZW1vdmVBbHBoYSgpXG4gKiAgIC50b0ZpbGUoJ3JnYi5wbmcnLCBmdW5jdGlvbihlcnIsIGluZm8pIHtcbiAqICAgICAvLyByZ2IucG5nIGlzIGEgMyBjaGFubmVsIGltYWdlIHdpdGhvdXQgYW4gYWxwaGEgY2hhbm5lbFxuICogICB9KTtcbiAqXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUFscGhhICgpIHtcbiAgdGhpcy5vcHRpb25zLnJlbW92ZUFscGhhID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoZSBvdXRwdXQgaW1hZ2UgaGFzIGFuIGFscGhhIHRyYW5zcGFyZW5jeSBjaGFubmVsLlxuICogSWYgbWlzc2luZywgdGhlIGFkZGVkIGFscGhhIGNoYW5uZWwgd2lsbCBoYXZlIHRoZSBzcGVjaWZpZWRcbiAqIHRyYW5zcGFyZW5jeSBsZXZlbCwgZGVmYXVsdGluZyB0byBmdWxseS1vcGFxdWUgKDEpLlxuICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBpbWFnZSBhbHJlYWR5IGhhcyBhbiBhbHBoYSBjaGFubmVsLlxuICpcbiAqIEBzaW5jZSAwLjIxLjJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gcmdiYS5wbmcgd2lsbCBiZSBhIDQgY2hhbm5lbCBpbWFnZSB3aXRoIGEgZnVsbHktb3BhcXVlIGFscGhhIGNoYW5uZWxcbiAqIGF3YWl0IHNoYXJwKCdyZ2IuanBnJylcbiAqICAgLmVuc3VyZUFscGhhKClcbiAqICAgLnRvRmlsZSgncmdiYS5wbmcnKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyByZ2JhIGlzIGEgNCBjaGFubmVsIGltYWdlIHdpdGggYSBmdWxseS10cmFuc3BhcmVudCBhbHBoYSBjaGFubmVsXG4gKiBjb25zdCByZ2JhID0gYXdhaXQgc2hhcnAocmdiKVxuICogICAuZW5zdXJlQWxwaGEoMClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0xXSAtIGFscGhhIHRyYW5zcGFyZW5jeSBsZXZlbCAoMD1mdWxseS10cmFuc3BhcmVudCwgMT1mdWxseS1vcGFxdWUpXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBhbHBoYSB0cmFuc3BhcmVuY3kgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gZW5zdXJlQWxwaGEgKGFscGhhKSB7XG4gIGlmIChpcy5kZWZpbmVkKGFscGhhKSkge1xuICAgIGlmIChpcy5udW1iZXIoYWxwaGEpICYmIGlzLmluUmFuZ2UoYWxwaGEsIDAsIDEpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZW5zdXJlQWxwaGEgPSBhbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdhbHBoYScsICdudW1iZXIgYmV0d2VlbiAwIGFuZCAxJywgYWxwaGEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuZW5zdXJlQWxwaGEgPSAxO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIGEgbXVsdGktY2hhbm5lbCBpbWFnZS5cbiAqXG4gKiBUaGUgb3V0cHV0IGNvbG91cnNwYWNlIHdpbGwgYmUgZWl0aGVyIGBiLXdgICg4LWJpdCkgb3IgYGdyZXkxNmAgKDE2LWJpdCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGdyZWVuLmpwZyBpcyBhIGdyZXlzY2FsZSBpbWFnZSBjb250YWluaW5nIHRoZSBncmVlbiBjaGFubmVsIG9mIHRoZSBpbnB1dFxuICogYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5leHRyYWN0Q2hhbm5lbCgnZ3JlZW4nKVxuICogICAudG9GaWxlKCdncmVlbi5qcGcnKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gcmVkMSBpcyB0aGUgcmVkIHZhbHVlIG9mIHRoZSBmaXJzdCBwaXhlbCwgcmVkMiB0aGUgc2Vjb25kIHBpeGVsIGV0Yy5cbiAqIGNvbnN0IFtyZWQxLCByZWQyLCAuLi5dID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5leHRyYWN0Q2hhbm5lbCgwKVxuICogICAucmF3KClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjaGFubmVsIC0gemVyby1pbmRleGVkIGNoYW5uZWwvYmFuZCBudW1iZXIgdG8gZXh0cmFjdCwgb3IgYHJlZGAsIGBncmVlbmAsIGBibHVlYCBvciBgYWxwaGFgLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgY2hhbm5lbFxuICovXG5mdW5jdGlvbiBleHRyYWN0Q2hhbm5lbCAoY2hhbm5lbCkge1xuICBjb25zdCBjaGFubmVsTWFwID0geyByZWQ6IDAsIGdyZWVuOiAxLCBibHVlOiAyLCBhbHBoYTogMyB9O1xuICBpZiAoT2JqZWN0LmtleXMoY2hhbm5lbE1hcCkuaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICBjaGFubmVsID0gY2hhbm5lbE1hcFtjaGFubmVsXTtcbiAgfVxuICBpZiAoaXMuaW50ZWdlcihjaGFubmVsKSAmJiBpcy5pblJhbmdlKGNoYW5uZWwsIDAsIDQpKSB7XG4gICAgdGhpcy5vcHRpb25zLmV4dHJhY3RDaGFubmVsID0gY2hhbm5lbDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NoYW5uZWwnLCAnaW50ZWdlciBvciBvbmUgb2Y6IHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhJywgY2hhbm5lbCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogSm9pbiBvbmUgb3IgbW9yZSBjaGFubmVscyB0byB0aGUgaW1hZ2UuXG4gKiBUaGUgbWVhbmluZyBvZiB0aGUgYWRkZWQgY2hhbm5lbHMgZGVwZW5kcyBvbiB0aGUgb3V0cHV0IGNvbG91cnNwYWNlLCBzZXQgd2l0aCBgdG9Db2xvdXJzcGFjZSgpYC5cbiAqIEJ5IGRlZmF1bHQgdGhlIG91dHB1dCBpbWFnZSB3aWxsIGJlIHdlYi1mcmllbmRseSBzUkdCLCB3aXRoIGFkZGl0aW9uYWwgY2hhbm5lbHMgaW50ZXJwcmV0ZWQgYXMgYWxwaGEgY2hhbm5lbHMuXG4gKiBDaGFubmVsIG9yZGVyaW5nIGZvbGxvd3MgdmlwcyBjb252ZW50aW9uOlxuICogLSBzUkdCOiAwOiBSZWQsIDE6IEdyZWVuLCAyOiBCbHVlLCAzOiBBbHBoYS5cbiAqIC0gQ01ZSzogMDogTWFnZW50YSwgMTogQ3lhbiwgMjogWWVsbG93LCAzOiBCbGFjaywgNDogQWxwaGEuXG4gKlxuICogQnVmZmVycyBtYXkgYmUgYW55IG9mIHRoZSBpbWFnZSBmb3JtYXRzIHN1cHBvcnRlZCBieSBzaGFycC5cbiAqIEZvciByYXcgcGl4ZWwgaW5wdXQsIHRoZSBgb3B0aW9uc2Agb2JqZWN0IHNob3VsZCBjb250YWluIGEgYHJhd2AgYXR0cmlidXRlLCB3aGljaCBmb2xsb3dzIHRoZSBmb3JtYXQgb2YgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lIGluIHRoZSBgc2hhcnAoKWAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8QnVmZmVyPnxzdHJpbmd8QnVmZmVyfSBpbWFnZXMgLSBvbmUgb3IgbW9yZSBpbWFnZXMgKGZpbGUgcGF0aHMsIEJ1ZmZlcnMpLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBpbWFnZSBvcHRpb25zLCBzZWUgYHNoYXJwKClgIGNvbnN0cnVjdG9yLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBqb2luQ2hhbm5lbCAoaW1hZ2VzLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGltYWdlcykpIHtcbiAgICBpbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5qb2luQ2hhbm5lbEluLnB1c2godGhpcy5fY3JlYXRlSW5wdXREZXNjcmlwdG9yKGltYWdlLCBvcHRpb25zKSk7XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLmpvaW5DaGFubmVsSW4ucHVzaCh0aGlzLl9jcmVhdGVJbnB1dERlc2NyaXB0b3IoaW1hZ2VzLCBvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGJpdHdpc2UgYm9vbGVhbiBvcGVyYXRpb24gb24gYWxsIGlucHV0IGltYWdlIGNoYW5uZWxzIChiYW5kcykgdG8gcHJvZHVjZSBhIHNpbmdsZSBjaGFubmVsIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2hhcnAoJzMtY2hhbm5lbC1yZ2ItaW5wdXQucG5nJylcbiAqICAgLmJhbmRib29sKHNoYXJwLmJvb2wuYW5kKVxuICogICAudG9GaWxlKCcxLWNoYW5uZWwtb3V0cHV0LnBuZycsIGZ1bmN0aW9uIChlcnIsIGluZm8pIHtcbiAqICAgICAvLyBUaGUgb3V0cHV0IHdpbGwgYmUgYSBzaW5nbGUgY2hhbm5lbCBpbWFnZSB3aGVyZSBlYWNoIHBpeGVsIGBQID0gUiAmIEcgJiBCYC5cbiAqICAgICAvLyBJZiBgSSgxLDEpID0gWzI0NywgMTcwLCAxNF0gPSBbMGIxMTExMDExMSwgMGIxMDEwMTAxMCwgMGIwMDAwMTExMV1gXG4gKiAgICAgLy8gdGhlbiBgTygxLDEpID0gMGIxMTExMDExMSAmIDBiMTAxMDEwMTAgJiAwYjAwMDAxMTExID0gMGIwMDAwMDAxMCA9IDJgLlxuICogICB9KTtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9vbE9wIC0gb25lIG9mIGBhbmRgLCBgb3JgIG9yIGBlb3JgIHRvIHBlcmZvcm0gdGhhdCBiaXR3aXNlIG9wZXJhdGlvbiwgbGlrZSB0aGUgQyBsb2dpYyBvcGVyYXRvcnMgYCZgLCBgfGAgYW5kIGBeYCByZXNwZWN0aXZlbHkuXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGJhbmRib29sIChib29sT3ApIHtcbiAgaWYgKGlzLnN0cmluZyhib29sT3ApICYmIGlzLmluQXJyYXkoYm9vbE9wLCBbJ2FuZCcsICdvcicsICdlb3InXSkpIHtcbiAgICB0aGlzLm9wdGlvbnMuYmFuZEJvb2xPcCA9IGJvb2xPcDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2Jvb2xPcCcsICdvbmUgb2Y6IGFuZCwgb3IsIGVvcicsIGJvb2xPcCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogRGVjb3JhdGUgdGhlIFNoYXJwIHByb3RvdHlwZSB3aXRoIGNoYW5uZWwtcmVsYXRlZCBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlIFNoYXJwXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTaGFycCkge1xuICBPYmplY3QuYXNzaWduKFNoYXJwLnByb3RvdHlwZSwge1xuICAgIC8vIFB1YmxpYyBpbnN0YW5jZSBmdW5jdGlvbnNcbiAgICByZW1vdmVBbHBoYSxcbiAgICBlbnN1cmVBbHBoYSxcbiAgICBleHRyYWN0Q2hhbm5lbCxcbiAgICBqb2luQ2hhbm5lbCxcbiAgICBiYW5kYm9vbFxuICB9KTtcbiAgLy8gQ2xhc3MgYXR0cmlidXRlc1xuICBTaGFycC5ib29sID0gYm9vbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/colour.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/colour.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst color = __webpack_require__(/*! @img/colour */ \"(rsc)/./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/index.cjs\");\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\n\n/**\n * Colourspaces.\n * @private\n */\nconst colourspace = {\n  multiband: 'multiband',\n  'b-w': 'b-w',\n  bw: 'b-w',\n  cmyk: 'cmyk',\n  srgb: 'srgb'\n};\n\n/**\n * Tint the image using the provided colour.\n * An alpha channel may be present and will be unchanged by the operation.\n *\n * @example\n * const output = await sharp(input)\n *   .tint({ r: 255, g: 240, b: 16 })\n *   .toBuffer();\n *\n * @param {string|Object} tint - Parsed by the [color](https://www.npmjs.org/package/color) module.\n * @returns {Sharp}\n * @throws {Error} Invalid parameter\n */\nfunction tint (tint) {\n  this._setBackgroundColourOption('tint', tint);\n  return this;\n}\n\n/**\n * Convert to 8-bit greyscale; 256 shades of grey.\n * This is a linear operation. If the input image is in a non-linear colour space such as sRGB, use `gamma()` with `greyscale()` for the best results.\n * By default the output image will be web-friendly sRGB and contain three (identical) colour channels.\n * This may be overridden by other sharp operations such as `toColourspace('b-w')`,\n * which will produce an output image containing one colour channel.\n * An alpha channel may be present, and will be unchanged by the operation.\n *\n * @example\n * const output = await sharp(input).greyscale().toBuffer();\n *\n * @param {Boolean} [greyscale=true]\n * @returns {Sharp}\n */\nfunction greyscale (greyscale) {\n  this.options.greyscale = is.bool(greyscale) ? greyscale : true;\n  return this;\n}\n\n/**\n * Alternative spelling of `greyscale`.\n * @param {Boolean} [grayscale=true]\n * @returns {Sharp}\n */\nfunction grayscale (grayscale) {\n  return this.greyscale(grayscale);\n}\n\n/**\n * Set the pipeline colourspace.\n *\n * The input image will be converted to the provided colourspace at the start of the pipeline.\n * All operations will use this colourspace before converting to the output colourspace,\n * as defined by {@link #tocolourspace|toColourspace}.\n *\n * @since 0.29.0\n *\n * @example\n * // Run pipeline in 16 bits per channel RGB while converting final result to 8 bits per channel sRGB.\n * await sharp(input)\n *  .pipelineColourspace('rgb16')\n *  .toColourspace('srgb')\n *  .toFile('16bpc-pipeline-to-8bpc-output.png')\n *\n * @param {string} [colourspace] - pipeline colourspace e.g. `rgb16`, `scrgb`, `lab`, `grey16` [...](https://github.com/libvips/libvips/blob/41cff4e9d0838498487a00623462204eb10ee5b8/libvips/iofuncs/enumtypes.c#L774)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction pipelineColourspace (colourspace) {\n  if (!is.string(colourspace)) {\n    throw is.invalidParameterError('colourspace', 'string', colourspace);\n  }\n  this.options.colourspacePipeline = colourspace;\n  return this;\n}\n\n/**\n * Alternative spelling of `pipelineColourspace`.\n * @param {string} [colorspace] - pipeline colorspace.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction pipelineColorspace (colorspace) {\n  return this.pipelineColourspace(colorspace);\n}\n\n/**\n * Set the output colourspace.\n * By default output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n *\n * @example\n * // Output 16 bits per pixel RGB\n * await sharp(input)\n *  .toColourspace('rgb16')\n *  .toFile('16-bpp.png')\n *\n * @param {string} [colourspace] - output colourspace e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://github.com/libvips/libvips/blob/3c0bfdf74ce1dc37a6429bed47fa76f16e2cd70a/libvips/iofuncs/enumtypes.c#L777-L794)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction toColourspace (colourspace) {\n  if (!is.string(colourspace)) {\n    throw is.invalidParameterError('colourspace', 'string', colourspace);\n  }\n  this.options.colourspace = colourspace;\n  return this;\n}\n\n/**\n * Alternative spelling of `toColourspace`.\n * @param {string} [colorspace] - output colorspace.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction toColorspace (colorspace) {\n  return this.toColourspace(colorspace);\n}\n\n/**\n * Create a RGBA colour array from a given value.\n * @private\n * @param {string|Object} value\n * @throws {Error} Invalid value\n */\nfunction _getBackgroundColourOption (value) {\n  if (is.object(value) || is.string(value)) {\n    const colour = color(value);\n    return [\n      colour.red(),\n      colour.green(),\n      colour.blue(),\n      Math.round(colour.alpha() * 255)\n    ];\n  } else {\n    throw is.invalidParameterError('background', 'object or string', value);\n  }\n}\n\n/**\n * Update a colour attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {string|Object} value\n * @throws {Error} Invalid value\n */\nfunction _setBackgroundColourOption (key, value) {\n  if (is.defined(value)) {\n    this.options[key] = _getBackgroundColourOption(value);\n  }\n}\n\n/**\n * Decorate the Sharp prototype with colour-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    tint,\n    greyscale,\n    grayscale,\n    pipelineColourspace,\n    pipelineColorspace,\n    toColourspace,\n    toColorspace,\n    // Private\n    _getBackgroundColourOption,\n    _setBackgroundColourOption\n  });\n  // Class attributes\n  Sharp.colourspace = colourspace;\n  Sharp.colorspace = colourspace;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvY29sb3VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG9HQUFhO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxrRkFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVucm91dGVyLWxhbmdncmFwaC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGFycEAwLjM0LjQvbm9kZV9tb2R1bGVzL3NoYXJwL2xpYi9jb2xvdXIuanM/MGI2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMyBMb3ZlbGwgRnVsbGVyIGFuZCBvdGhlcnMuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvbG9yID0gcmVxdWlyZSgnQGltZy9jb2xvdXInKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnLi9pcycpO1xuXG4vKipcbiAqIENvbG91cnNwYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNvbG91cnNwYWNlID0ge1xuICBtdWx0aWJhbmQ6ICdtdWx0aWJhbmQnLFxuICAnYi13JzogJ2ItdycsXG4gIGJ3OiAnYi13JyxcbiAgY215azogJ2NteWsnLFxuICBzcmdiOiAnc3JnYidcbn07XG5cbi8qKlxuICogVGludCB0aGUgaW1hZ2UgdXNpbmcgdGhlIHByb3ZpZGVkIGNvbG91ci5cbiAqIEFuIGFscGhhIGNoYW5uZWwgbWF5IGJlIHByZXNlbnQgYW5kIHdpbGwgYmUgdW5jaGFuZ2VkIGJ5IHRoZSBvcGVyYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAudGludCh7IHI6IDI1NSwgZzogMjQwLCBiOiAxNiB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHRpbnQgLSBQYXJzZWQgYnkgdGhlIFtjb2xvcl0oaHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvY29sb3IpIG1vZHVsZS5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlclxuICovXG5mdW5jdGlvbiB0aW50ICh0aW50KSB7XG4gIHRoaXMuX3NldEJhY2tncm91bmRDb2xvdXJPcHRpb24oJ3RpbnQnLCB0aW50KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ29udmVydCB0byA4LWJpdCBncmV5c2NhbGU7IDI1NiBzaGFkZXMgb2YgZ3JleS5cbiAqIFRoaXMgaXMgYSBsaW5lYXIgb3BlcmF0aW9uLiBJZiB0aGUgaW5wdXQgaW1hZ2UgaXMgaW4gYSBub24tbGluZWFyIGNvbG91ciBzcGFjZSBzdWNoIGFzIHNSR0IsIHVzZSBgZ2FtbWEoKWAgd2l0aCBgZ3JleXNjYWxlKClgIGZvciB0aGUgYmVzdCByZXN1bHRzLlxuICogQnkgZGVmYXVsdCB0aGUgb3V0cHV0IGltYWdlIHdpbGwgYmUgd2ViLWZyaWVuZGx5IHNSR0IgYW5kIGNvbnRhaW4gdGhyZWUgKGlkZW50aWNhbCkgY29sb3VyIGNoYW5uZWxzLlxuICogVGhpcyBtYXkgYmUgb3ZlcnJpZGRlbiBieSBvdGhlciBzaGFycCBvcGVyYXRpb25zIHN1Y2ggYXMgYHRvQ29sb3Vyc3BhY2UoJ2ItdycpYCxcbiAqIHdoaWNoIHdpbGwgcHJvZHVjZSBhbiBvdXRwdXQgaW1hZ2UgY29udGFpbmluZyBvbmUgY29sb3VyIGNoYW5uZWwuXG4gKiBBbiBhbHBoYSBjaGFubmVsIG1heSBiZSBwcmVzZW50LCBhbmQgd2lsbCBiZSB1bmNoYW5nZWQgYnkgdGhlIG9wZXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgc2hhcnAoaW5wdXQpLmdyZXlzY2FsZSgpLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZ3JleXNjYWxlPXRydWVdXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIGdyZXlzY2FsZSAoZ3JleXNjYWxlKSB7XG4gIHRoaXMub3B0aW9ucy5ncmV5c2NhbGUgPSBpcy5ib29sKGdyZXlzY2FsZSkgPyBncmV5c2NhbGUgOiB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBBbHRlcm5hdGl2ZSBzcGVsbGluZyBvZiBgZ3JleXNjYWxlYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2dyYXlzY2FsZT10cnVlXVxuICogQHJldHVybnMge1NoYXJwfVxuICovXG5mdW5jdGlvbiBncmF5c2NhbGUgKGdyYXlzY2FsZSkge1xuICByZXR1cm4gdGhpcy5ncmV5c2NhbGUoZ3JheXNjYWxlKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHBpcGVsaW5lIGNvbG91cnNwYWNlLlxuICpcbiAqIFRoZSBpbnB1dCBpbWFnZSB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgcHJvdmlkZWQgY29sb3Vyc3BhY2UgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwaXBlbGluZS5cbiAqIEFsbCBvcGVyYXRpb25zIHdpbGwgdXNlIHRoaXMgY29sb3Vyc3BhY2UgYmVmb3JlIGNvbnZlcnRpbmcgdG8gdGhlIG91dHB1dCBjb2xvdXJzcGFjZSxcbiAqIGFzIGRlZmluZWQgYnkge0BsaW5rICN0b2NvbG91cnNwYWNlfHRvQ29sb3Vyc3BhY2V9LlxuICpcbiAqIEBzaW5jZSAwLjI5LjBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUnVuIHBpcGVsaW5lIGluIDE2IGJpdHMgcGVyIGNoYW5uZWwgUkdCIHdoaWxlIGNvbnZlcnRpbmcgZmluYWwgcmVzdWx0IHRvIDggYml0cyBwZXIgY2hhbm5lbCBzUkdCLlxuICogYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgLnBpcGVsaW5lQ29sb3Vyc3BhY2UoJ3JnYjE2JylcbiAqICAudG9Db2xvdXJzcGFjZSgnc3JnYicpXG4gKiAgLnRvRmlsZSgnMTZicGMtcGlwZWxpbmUtdG8tOGJwYy1vdXRwdXQucG5nJylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbG91cnNwYWNlXSAtIHBpcGVsaW5lIGNvbG91cnNwYWNlIGUuZy4gYHJnYjE2YCwgYHNjcmdiYCwgYGxhYmAsIGBncmV5MTZgIFsuLi5dKGh0dHBzOi8vZ2l0aHViLmNvbS9saWJ2aXBzL2xpYnZpcHMvYmxvYi80MWNmZjRlOWQwODM4NDk4NDg3YTAwNjIzNDYyMjA0ZWIxMGVlNWI4L2xpYnZpcHMvaW9mdW5jcy9lbnVtdHlwZXMuYyNMNzc0KVxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBwaXBlbGluZUNvbG91cnNwYWNlIChjb2xvdXJzcGFjZSkge1xuICBpZiAoIWlzLnN0cmluZyhjb2xvdXJzcGFjZSkpIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NvbG91cnNwYWNlJywgJ3N0cmluZycsIGNvbG91cnNwYWNlKTtcbiAgfVxuICB0aGlzLm9wdGlvbnMuY29sb3Vyc3BhY2VQaXBlbGluZSA9IGNvbG91cnNwYWNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBBbHRlcm5hdGl2ZSBzcGVsbGluZyBvZiBgcGlwZWxpbmVDb2xvdXJzcGFjZWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbG9yc3BhY2VdIC0gcGlwZWxpbmUgY29sb3JzcGFjZS5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gcGlwZWxpbmVDb2xvcnNwYWNlIChjb2xvcnNwYWNlKSB7XG4gIHJldHVybiB0aGlzLnBpcGVsaW5lQ29sb3Vyc3BhY2UoY29sb3JzcGFjZSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBvdXRwdXQgY29sb3Vyc3BhY2UuXG4gKiBCeSBkZWZhdWx0IG91dHB1dCBpbWFnZSB3aWxsIGJlIHdlYi1mcmllbmRseSBzUkdCLCB3aXRoIGFkZGl0aW9uYWwgY2hhbm5lbHMgaW50ZXJwcmV0ZWQgYXMgYWxwaGEgY2hhbm5lbHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIE91dHB1dCAxNiBiaXRzIHBlciBwaXhlbCBSR0JcbiAqIGF3YWl0IHNoYXJwKGlucHV0KVxuICogIC50b0NvbG91cnNwYWNlKCdyZ2IxNicpXG4gKiAgLnRvRmlsZSgnMTYtYnBwLnBuZycpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvdXJzcGFjZV0gLSBvdXRwdXQgY29sb3Vyc3BhY2UgZS5nLiBgc3JnYmAsIGByZ2JgLCBgY215a2AsIGBsYWJgLCBgYi13YCBbLi4uXShodHRwczovL2dpdGh1Yi5jb20vbGlidmlwcy9saWJ2aXBzL2Jsb2IvM2MwYmZkZjc0Y2UxZGMzN2E2NDI5YmVkNDdmYTc2ZjE2ZTJjZDcwYS9saWJ2aXBzL2lvZnVuY3MvZW51bXR5cGVzLmMjTDc3Ny1MNzk0KVxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiB0b0NvbG91cnNwYWNlIChjb2xvdXJzcGFjZSkge1xuICBpZiAoIWlzLnN0cmluZyhjb2xvdXJzcGFjZSkpIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NvbG91cnNwYWNlJywgJ3N0cmluZycsIGNvbG91cnNwYWNlKTtcbiAgfVxuICB0aGlzLm9wdGlvbnMuY29sb3Vyc3BhY2UgPSBjb2xvdXJzcGFjZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQWx0ZXJuYXRpdmUgc3BlbGxpbmcgb2YgYHRvQ29sb3Vyc3BhY2VgLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvcnNwYWNlXSAtIG91dHB1dCBjb2xvcnNwYWNlLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiB0b0NvbG9yc3BhY2UgKGNvbG9yc3BhY2UpIHtcbiAgcmV0dXJuIHRoaXMudG9Db2xvdXJzcGFjZShjb2xvcnNwYWNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBSR0JBIGNvbG91ciBhcnJheSBmcm9tIGEgZ2l2ZW4gdmFsdWUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gX2dldEJhY2tncm91bmRDb2xvdXJPcHRpb24gKHZhbHVlKSB7XG4gIGlmIChpcy5vYmplY3QodmFsdWUpIHx8IGlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICBjb25zdCBjb2xvdXIgPSBjb2xvcih2YWx1ZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNvbG91ci5yZWQoKSxcbiAgICAgIGNvbG91ci5ncmVlbigpLFxuICAgICAgY29sb3VyLmJsdWUoKSxcbiAgICAgIE1hdGgucm91bmQoY29sb3VyLmFscGhhKCkgKiAyNTUpXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2JhY2tncm91bmQnLCAnb2JqZWN0IG9yIHN0cmluZycsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIGNvbG91ciBhdHRyaWJ1dGUgb2YgdGhlIHRoaXMub3B0aW9ucyBPYmplY3QuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gX3NldEJhY2tncm91bmRDb2xvdXJPcHRpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzLmRlZmluZWQodmFsdWUpKSB7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSBfZ2V0QmFja2dyb3VuZENvbG91ck9wdGlvbih2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvcmF0ZSB0aGUgU2hhcnAgcHJvdG90eXBlIHdpdGggY29sb3VyLXJlbGF0ZWQgZnVuY3Rpb25zLlxuICogQG1vZHVsZSBTaGFycFxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU2hhcnApIHtcbiAgT2JqZWN0LmFzc2lnbihTaGFycC5wcm90b3R5cGUsIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aW50LFxuICAgIGdyZXlzY2FsZSxcbiAgICBncmF5c2NhbGUsXG4gICAgcGlwZWxpbmVDb2xvdXJzcGFjZSxcbiAgICBwaXBlbGluZUNvbG9yc3BhY2UsXG4gICAgdG9Db2xvdXJzcGFjZSxcbiAgICB0b0NvbG9yc3BhY2UsXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9nZXRCYWNrZ3JvdW5kQ29sb3VyT3B0aW9uLFxuICAgIF9zZXRCYWNrZ3JvdW5kQ29sb3VyT3B0aW9uXG4gIH0pO1xuICAvLyBDbGFzcyBhdHRyaWJ1dGVzXG4gIFNoYXJwLmNvbG91cnNwYWNlID0gY29sb3Vyc3BhY2U7XG4gIFNoYXJwLmNvbG9yc3BhY2UgPSBjb2xvdXJzcGFjZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/colour.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/composite.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/composite.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\n\n/**\n * Blend modes.\n * @member\n * @private\n */\nconst blend = {\n  clear: 'clear',\n  source: 'source',\n  over: 'over',\n  in: 'in',\n  out: 'out',\n  atop: 'atop',\n  dest: 'dest',\n  'dest-over': 'dest-over',\n  'dest-in': 'dest-in',\n  'dest-out': 'dest-out',\n  'dest-atop': 'dest-atop',\n  xor: 'xor',\n  add: 'add',\n  saturate: 'saturate',\n  multiply: 'multiply',\n  screen: 'screen',\n  overlay: 'overlay',\n  darken: 'darken',\n  lighten: 'lighten',\n  'colour-dodge': 'colour-dodge',\n  'color-dodge': 'colour-dodge',\n  'colour-burn': 'colour-burn',\n  'color-burn': 'colour-burn',\n  'hard-light': 'hard-light',\n  'soft-light': 'soft-light',\n  difference: 'difference',\n  exclusion: 'exclusion'\n};\n\n/**\n * Composite image(s) over the processed (resized, extracted etc.) image.\n *\n * The images to composite must be the same size or smaller than the processed image.\n * If both `top` and `left` options are provided, they take precedence over `gravity`.\n *\n * Other operations in the same processing pipeline (e.g. resize, rotate, flip,\n * flop, extract) will always be applied to the input image before composition.\n *\n * The `blend` option can be one of `clear`, `source`, `over`, `in`, `out`, `atop`,\n * `dest`, `dest-over`, `dest-in`, `dest-out`, `dest-atop`,\n * `xor`, `add`, `saturate`, `multiply`, `screen`, `overlay`, `darken`, `lighten`,\n * `colour-dodge`, `color-dodge`, `colour-burn`,`color-burn`,\n * `hard-light`, `soft-light`, `difference`, `exclusion`.\n *\n * More information about blend modes can be found at\n * https://www.libvips.org/API/current/libvips-conversion.html#VipsBlendMode\n * and https://www.cairographics.org/operators/\n *\n * @since 0.22.0\n *\n * @example\n * await sharp(background)\n *   .composite([\n *     { input: layer1, gravity: 'northwest' },\n *     { input: layer2, gravity: 'southeast' },\n *   ])\n *   .toFile('combined.png');\n *\n * @example\n * const output = await sharp('input.gif', { animated: true })\n *   .composite([\n *     { input: 'overlay.png', tile: true, blend: 'saturate' }\n *   ])\n *   .toBuffer();\n *\n * @example\n * sharp('input.png')\n *   .rotate(180)\n *   .resize(300)\n *   .flatten( { background: '#ff6600' } )\n *   .composite([{ input: 'overlay.png', gravity: 'southeast' }])\n *   .sharpen()\n *   .withMetadata()\n *   .webp( { quality: 90 } )\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains upside down, 300px wide, alpha channel flattened\n *     // onto orange background, composited with overlay.png with SE gravity,\n *     // sharpened, with metadata, 90% quality WebP image data. Phew!\n *   });\n *\n * @param {Object[]} images - Ordered list of images to composite\n * @param {Buffer|String} [images[].input] - Buffer containing image data, String containing the path to an image file, or Create object (see below)\n * @param {Object} [images[].input.create] - describes a blank overlay to be created.\n * @param {Number} [images[].input.create.width]\n * @param {Number} [images[].input.create.height]\n * @param {Number} [images[].input.create.channels] - 3-4\n * @param {String|Object} [images[].input.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [images[].input.text] - describes a new text image to be created.\n * @param {string} [images[].input.text.text] - text to render as a UTF-8 string. It can contain Pango markup, for example `<i>Le</i>Monde`.\n * @param {string} [images[].input.text.font] - font name to render with.\n * @param {string} [images[].input.text.fontfile] - absolute filesystem path to a font file that can be used by `font`.\n * @param {number} [images[].input.text.width=0] - integral number of pixels to word-wrap at. Lines of text wider than this will be broken at word boundaries.\n * @param {number} [images[].input.text.height=0] - integral number of pixels high. When defined, `dpi` will be ignored and the text will automatically fit the pixel resolution defined by `width` and `height`. Will be ignored if `width` is not specified or set to 0.\n * @param {string} [images[].input.text.align='left'] - text alignment (`'left'`, `'centre'`, `'center'`, `'right'`).\n * @param {boolean} [images[].input.text.justify=false] - set this to true to apply justification to the text.\n * @param {number} [images[].input.text.dpi=72] - the resolution (size) at which to render the text. Does not take effect if `height` is specified.\n * @param {boolean} [images[].input.text.rgba=false] - set this to true to enable RGBA output. This is useful for colour emoji rendering, or support for Pango markup features like `<span foreground=\"red\">Red!</span>`.\n * @param {number} [images[].input.text.spacing=0] - text line height in points. Will use the font line height if none is specified.\n * @param {Boolean} [images[].autoOrient=false] - set to true to use EXIF orientation data, if present, to orient the image.\n * @param {String} [images[].blend='over'] - how to blend this image with the image below.\n * @param {String} [images[].gravity='centre'] - gravity at which to place the overlay.\n * @param {Number} [images[].top] - the pixel offset from the top edge.\n * @param {Number} [images[].left] - the pixel offset from the left edge.\n * @param {Boolean} [images[].tile=false] - set to true to repeat the overlay image across the entire image with the given `gravity`.\n * @param {Boolean} [images[].premultiplied=false] - set to true to avoid premultiplying the image below. Equivalent to the `--premultiplied` vips option.\n * @param {Number} [images[].density=72] - number representing the DPI for vector overlay image.\n * @param {Object} [images[].raw] - describes overlay when using raw pixel data.\n * @param {Number} [images[].raw.width]\n * @param {Number} [images[].raw.height]\n * @param {Number} [images[].raw.channels]\n * @param {boolean} [images[].animated=false] - Set to `true` to read all frames/pages of an animated image.\n * @param {string} [images[].failOn='warning'] - @see {@link /api-constructor#parameters|constructor parameters}\n * @param {number|boolean} [images[].limitInputPixels=268402689] - @see {@link /api-constructor#parameters|constructor parameters}\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction composite (images) {\n  if (!Array.isArray(images)) {\n    throw is.invalidParameterError('images to composite', 'array', images);\n  }\n  this.options.composite = images.map(image => {\n    if (!is.object(image)) {\n      throw is.invalidParameterError('image to composite', 'object', image);\n    }\n    const inputOptions = this._inputOptionsFromObject(image);\n    const composite = {\n      input: this._createInputDescriptor(image.input, inputOptions, { allowStream: false }),\n      blend: 'over',\n      tile: false,\n      left: 0,\n      top: 0,\n      hasOffset: false,\n      gravity: 0,\n      premultiplied: false\n    };\n    if (is.defined(image.blend)) {\n      if (is.string(blend[image.blend])) {\n        composite.blend = blend[image.blend];\n      } else {\n        throw is.invalidParameterError('blend', 'valid blend name', image.blend);\n      }\n    }\n    if (is.defined(image.tile)) {\n      if (is.bool(image.tile)) {\n        composite.tile = image.tile;\n      } else {\n        throw is.invalidParameterError('tile', 'boolean', image.tile);\n      }\n    }\n    if (is.defined(image.left)) {\n      if (is.integer(image.left)) {\n        composite.left = image.left;\n      } else {\n        throw is.invalidParameterError('left', 'integer', image.left);\n      }\n    }\n    if (is.defined(image.top)) {\n      if (is.integer(image.top)) {\n        composite.top = image.top;\n      } else {\n        throw is.invalidParameterError('top', 'integer', image.top);\n      }\n    }\n    if (is.defined(image.top) !== is.defined(image.left)) {\n      throw new Error('Expected both left and top to be set');\n    } else {\n      composite.hasOffset = is.integer(image.top) && is.integer(image.left);\n    }\n    if (is.defined(image.gravity)) {\n      if (is.integer(image.gravity) && is.inRange(image.gravity, 0, 8)) {\n        composite.gravity = image.gravity;\n      } else if (is.string(image.gravity) && is.integer(this.constructor.gravity[image.gravity])) {\n        composite.gravity = this.constructor.gravity[image.gravity];\n      } else {\n        throw is.invalidParameterError('gravity', 'valid gravity', image.gravity);\n      }\n    }\n    if (is.defined(image.premultiplied)) {\n      if (is.bool(image.premultiplied)) {\n        composite.premultiplied = image.premultiplied;\n      } else {\n        throw is.invalidParameterError('premultiplied', 'boolean', image.premultiplied);\n      }\n    }\n    return composite;\n  });\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with composite-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Sharp.prototype.composite = composite;\n  Sharp.blend = blend;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvY29tcG9zaXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGtGQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFDQUFxQztBQUM5QyxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUSxvQ0FBb0M7QUFDdkQsV0FBVyxnQkFBZ0IsOENBQThDO0FBQ3pFLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvQkFBb0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbnJvdXRlci1sYW5nZ3JhcGgvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvY29tcG9zaXRlLmpzP2Y1Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMgTG92ZWxsIEZ1bGxlciBhbmQgb3RoZXJzLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuLyoqXG4gKiBCbGVuZCBtb2Rlcy5cbiAqIEBtZW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGJsZW5kID0ge1xuICBjbGVhcjogJ2NsZWFyJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgb3ZlcjogJ292ZXInLFxuICBpbjogJ2luJyxcbiAgb3V0OiAnb3V0JyxcbiAgYXRvcDogJ2F0b3AnLFxuICBkZXN0OiAnZGVzdCcsXG4gICdkZXN0LW92ZXInOiAnZGVzdC1vdmVyJyxcbiAgJ2Rlc3QtaW4nOiAnZGVzdC1pbicsXG4gICdkZXN0LW91dCc6ICdkZXN0LW91dCcsXG4gICdkZXN0LWF0b3AnOiAnZGVzdC1hdG9wJyxcbiAgeG9yOiAneG9yJyxcbiAgYWRkOiAnYWRkJyxcbiAgc2F0dXJhdGU6ICdzYXR1cmF0ZScsXG4gIG11bHRpcGx5OiAnbXVsdGlwbHknLFxuICBzY3JlZW46ICdzY3JlZW4nLFxuICBvdmVybGF5OiAnb3ZlcmxheScsXG4gIGRhcmtlbjogJ2RhcmtlbicsXG4gIGxpZ2h0ZW46ICdsaWdodGVuJyxcbiAgJ2NvbG91ci1kb2RnZSc6ICdjb2xvdXItZG9kZ2UnLFxuICAnY29sb3ItZG9kZ2UnOiAnY29sb3VyLWRvZGdlJyxcbiAgJ2NvbG91ci1idXJuJzogJ2NvbG91ci1idXJuJyxcbiAgJ2NvbG9yLWJ1cm4nOiAnY29sb3VyLWJ1cm4nLFxuICAnaGFyZC1saWdodCc6ICdoYXJkLWxpZ2h0JyxcbiAgJ3NvZnQtbGlnaHQnOiAnc29mdC1saWdodCcsXG4gIGRpZmZlcmVuY2U6ICdkaWZmZXJlbmNlJyxcbiAgZXhjbHVzaW9uOiAnZXhjbHVzaW9uJ1xufTtcblxuLyoqXG4gKiBDb21wb3NpdGUgaW1hZ2Uocykgb3ZlciB0aGUgcHJvY2Vzc2VkIChyZXNpemVkLCBleHRyYWN0ZWQgZXRjLikgaW1hZ2UuXG4gKlxuICogVGhlIGltYWdlcyB0byBjb21wb3NpdGUgbXVzdCBiZSB0aGUgc2FtZSBzaXplIG9yIHNtYWxsZXIgdGhhbiB0aGUgcHJvY2Vzc2VkIGltYWdlLlxuICogSWYgYm90aCBgdG9wYCBhbmQgYGxlZnRgIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGV5IHRha2UgcHJlY2VkZW5jZSBvdmVyIGBncmF2aXR5YC5cbiAqXG4gKiBPdGhlciBvcGVyYXRpb25zIGluIHRoZSBzYW1lIHByb2Nlc3NpbmcgcGlwZWxpbmUgKGUuZy4gcmVzaXplLCByb3RhdGUsIGZsaXAsXG4gKiBmbG9wLCBleHRyYWN0KSB3aWxsIGFsd2F5cyBiZSBhcHBsaWVkIHRvIHRoZSBpbnB1dCBpbWFnZSBiZWZvcmUgY29tcG9zaXRpb24uXG4gKlxuICogVGhlIGBibGVuZGAgb3B0aW9uIGNhbiBiZSBvbmUgb2YgYGNsZWFyYCwgYHNvdXJjZWAsIGBvdmVyYCwgYGluYCwgYG91dGAsIGBhdG9wYCxcbiAqIGBkZXN0YCwgYGRlc3Qtb3ZlcmAsIGBkZXN0LWluYCwgYGRlc3Qtb3V0YCwgYGRlc3QtYXRvcGAsXG4gKiBgeG9yYCwgYGFkZGAsIGBzYXR1cmF0ZWAsIGBtdWx0aXBseWAsIGBzY3JlZW5gLCBgb3ZlcmxheWAsIGBkYXJrZW5gLCBgbGlnaHRlbmAsXG4gKiBgY29sb3VyLWRvZGdlYCwgYGNvbG9yLWRvZGdlYCwgYGNvbG91ci1idXJuYCxgY29sb3ItYnVybmAsXG4gKiBgaGFyZC1saWdodGAsIGBzb2Z0LWxpZ2h0YCwgYGRpZmZlcmVuY2VgLCBgZXhjbHVzaW9uYC5cbiAqXG4gKiBNb3JlIGluZm9ybWF0aW9uIGFib3V0IGJsZW5kIG1vZGVzIGNhbiBiZSBmb3VuZCBhdFxuICogaHR0cHM6Ly93d3cubGlidmlwcy5vcmcvQVBJL2N1cnJlbnQvbGlidmlwcy1jb252ZXJzaW9uLmh0bWwjVmlwc0JsZW5kTW9kZVxuICogYW5kIGh0dHBzOi8vd3d3LmNhaXJvZ3JhcGhpY3Mub3JnL29wZXJhdG9ycy9cbiAqXG4gKiBAc2luY2UgMC4yMi4wXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IHNoYXJwKGJhY2tncm91bmQpXG4gKiAgIC5jb21wb3NpdGUoW1xuICogICAgIHsgaW5wdXQ6IGxheWVyMSwgZ3Jhdml0eTogJ25vcnRod2VzdCcgfSxcbiAqICAgICB7IGlucHV0OiBsYXllcjIsIGdyYXZpdHk6ICdzb3V0aGVhc3QnIH0sXG4gKiAgIF0pXG4gKiAgIC50b0ZpbGUoJ2NvbWJpbmVkLnBuZycpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycCgnaW5wdXQuZ2lmJywgeyBhbmltYXRlZDogdHJ1ZSB9KVxuICogICAuY29tcG9zaXRlKFtcbiAqICAgICB7IGlucHV0OiAnb3ZlcmxheS5wbmcnLCB0aWxlOiB0cnVlLCBibGVuZDogJ3NhdHVyYXRlJyB9XG4gKiAgIF0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBzaGFycCgnaW5wdXQucG5nJylcbiAqICAgLnJvdGF0ZSgxODApXG4gKiAgIC5yZXNpemUoMzAwKVxuICogICAuZmxhdHRlbiggeyBiYWNrZ3JvdW5kOiAnI2ZmNjYwMCcgfSApXG4gKiAgIC5jb21wb3NpdGUoW3sgaW5wdXQ6ICdvdmVybGF5LnBuZycsIGdyYXZpdHk6ICdzb3V0aGVhc3QnIH1dKVxuICogICAuc2hhcnBlbigpXG4gKiAgIC53aXRoTWV0YWRhdGEoKVxuICogICAud2VicCggeyBxdWFsaXR5OiA5MCB9IClcbiAqICAgLnRvQnVmZmVyKClcbiAqICAgLnRoZW4oZnVuY3Rpb24ob3V0cHV0QnVmZmVyKSB7XG4gKiAgICAgLy8gb3V0cHV0QnVmZmVyIGNvbnRhaW5zIHVwc2lkZSBkb3duLCAzMDBweCB3aWRlLCBhbHBoYSBjaGFubmVsIGZsYXR0ZW5lZFxuICogICAgIC8vIG9udG8gb3JhbmdlIGJhY2tncm91bmQsIGNvbXBvc2l0ZWQgd2l0aCBvdmVybGF5LnBuZyB3aXRoIFNFIGdyYXZpdHksXG4gKiAgICAgLy8gc2hhcnBlbmVkLCB3aXRoIG1ldGFkYXRhLCA5MCUgcXVhbGl0eSBXZWJQIGltYWdlIGRhdGEuIFBoZXchXG4gKiAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IGltYWdlcyAtIE9yZGVyZWQgbGlzdCBvZiBpbWFnZXMgdG8gY29tcG9zaXRlXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IFtpbWFnZXNbXS5pbnB1dF0gLSBCdWZmZXIgY29udGFpbmluZyBpbWFnZSBkYXRhLCBTdHJpbmcgY29udGFpbmluZyB0aGUgcGF0aCB0byBhbiBpbWFnZSBmaWxlLCBvciBDcmVhdGUgb2JqZWN0IChzZWUgYmVsb3cpXG4gKiBAcGFyYW0ge09iamVjdH0gW2ltYWdlc1tdLmlucHV0LmNyZWF0ZV0gLSBkZXNjcmliZXMgYSBibGFuayBvdmVybGF5IHRvIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW2ltYWdlc1tdLmlucHV0LmNyZWF0ZS53aWR0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VzW10uaW5wdXQuY3JlYXRlLmhlaWdodF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VzW10uaW5wdXQuY3JlYXRlLmNoYW5uZWxzXSAtIDMtNFxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbaW1hZ2VzW10uaW5wdXQuY3JlYXRlLmJhY2tncm91bmRdIC0gcGFyc2VkIGJ5IHRoZSBbY29sb3JdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL2NvbG9yKSBtb2R1bGUgdG8gZXh0cmFjdCB2YWx1ZXMgZm9yIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhLlxuICogQHBhcmFtIHtPYmplY3R9IFtpbWFnZXNbXS5pbnB1dC50ZXh0XSAtIGRlc2NyaWJlcyBhIG5ldyB0ZXh0IGltYWdlIHRvIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ltYWdlc1tdLmlucHV0LnRleHQudGV4dF0gLSB0ZXh0IHRvIHJlbmRlciBhcyBhIFVURi04IHN0cmluZy4gSXQgY2FuIGNvbnRhaW4gUGFuZ28gbWFya3VwLCBmb3IgZXhhbXBsZSBgPGk+TGU8L2k+TW9uZGVgLlxuICogQHBhcmFtIHtzdHJpbmd9IFtpbWFnZXNbXS5pbnB1dC50ZXh0LmZvbnRdIC0gZm9udCBuYW1lIHRvIHJlbmRlciB3aXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IFtpbWFnZXNbXS5pbnB1dC50ZXh0LmZvbnRmaWxlXSAtIGFic29sdXRlIGZpbGVzeXN0ZW0gcGF0aCB0byBhIGZvbnQgZmlsZSB0aGF0IGNhbiBiZSB1c2VkIGJ5IGBmb250YC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW1hZ2VzW10uaW5wdXQudGV4dC53aWR0aD0wXSAtIGludGVncmFsIG51bWJlciBvZiBwaXhlbHMgdG8gd29yZC13cmFwIGF0LiBMaW5lcyBvZiB0ZXh0IHdpZGVyIHRoYW4gdGhpcyB3aWxsIGJlIGJyb2tlbiBhdCB3b3JkIGJvdW5kYXJpZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ltYWdlc1tdLmlucHV0LnRleHQuaGVpZ2h0PTBdIC0gaW50ZWdyYWwgbnVtYmVyIG9mIHBpeGVscyBoaWdoLiBXaGVuIGRlZmluZWQsIGBkcGlgIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIHRleHQgd2lsbCBhdXRvbWF0aWNhbGx5IGZpdCB0aGUgcGl4ZWwgcmVzb2x1dGlvbiBkZWZpbmVkIGJ5IGB3aWR0aGAgYW5kIGBoZWlnaHRgLiBXaWxsIGJlIGlnbm9yZWQgaWYgYHdpZHRoYCBpcyBub3Qgc3BlY2lmaWVkIG9yIHNldCB0byAwLlxuICogQHBhcmFtIHtzdHJpbmd9IFtpbWFnZXNbXS5pbnB1dC50ZXh0LmFsaWduPSdsZWZ0J10gLSB0ZXh0IGFsaWdubWVudCAoYCdsZWZ0J2AsIGAnY2VudHJlJ2AsIGAnY2VudGVyJ2AsIGAncmlnaHQnYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbWFnZXNbXS5pbnB1dC50ZXh0Lmp1c3RpZnk9ZmFsc2VdIC0gc2V0IHRoaXMgdG8gdHJ1ZSB0byBhcHBseSBqdXN0aWZpY2F0aW9uIHRvIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbWFnZXNbXS5pbnB1dC50ZXh0LmRwaT03Ml0gLSB0aGUgcmVzb2x1dGlvbiAoc2l6ZSkgYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSB0ZXh0LiBEb2VzIG5vdCB0YWtlIGVmZmVjdCBpZiBgaGVpZ2h0YCBpcyBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbWFnZXNbXS5pbnB1dC50ZXh0LnJnYmE9ZmFsc2VdIC0gc2V0IHRoaXMgdG8gdHJ1ZSB0byBlbmFibGUgUkdCQSBvdXRwdXQuIFRoaXMgaXMgdXNlZnVsIGZvciBjb2xvdXIgZW1vamkgcmVuZGVyaW5nLCBvciBzdXBwb3J0IGZvciBQYW5nbyBtYXJrdXAgZmVhdHVyZXMgbGlrZSBgPHNwYW4gZm9yZWdyb3VuZD1cInJlZFwiPlJlZCE8L3NwYW4+YC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW1hZ2VzW10uaW5wdXQudGV4dC5zcGFjaW5nPTBdIC0gdGV4dCBsaW5lIGhlaWdodCBpbiBwb2ludHMuIFdpbGwgdXNlIHRoZSBmb250IGxpbmUgaGVpZ2h0IGlmIG5vbmUgaXMgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtCb29sZWFufSBbaW1hZ2VzW10uYXV0b09yaWVudD1mYWxzZV0gLSBzZXQgdG8gdHJ1ZSB0byB1c2UgRVhJRiBvcmllbnRhdGlvbiBkYXRhLCBpZiBwcmVzZW50LCB0byBvcmllbnQgdGhlIGltYWdlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtpbWFnZXNbXS5ibGVuZD0nb3ZlciddIC0gaG93IHRvIGJsZW5kIHRoaXMgaW1hZ2Ugd2l0aCB0aGUgaW1hZ2UgYmVsb3cuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ltYWdlc1tdLmdyYXZpdHk9J2NlbnRyZSddIC0gZ3Jhdml0eSBhdCB3aGljaCB0byBwbGFjZSB0aGUgb3ZlcmxheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VzW10udG9wXSAtIHRoZSBwaXhlbCBvZmZzZXQgZnJvbSB0aGUgdG9wIGVkZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW2ltYWdlc1tdLmxlZnRdIC0gdGhlIHBpeGVsIG9mZnNldCBmcm9tIHRoZSBsZWZ0IGVkZ2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpbWFnZXNbXS50aWxlPWZhbHNlXSAtIHNldCB0byB0cnVlIHRvIHJlcGVhdCB0aGUgb3ZlcmxheSBpbWFnZSBhY3Jvc3MgdGhlIGVudGlyZSBpbWFnZSB3aXRoIHRoZSBnaXZlbiBgZ3Jhdml0eWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpbWFnZXNbXS5wcmVtdWx0aXBsaWVkPWZhbHNlXSAtIHNldCB0byB0cnVlIHRvIGF2b2lkIHByZW11bHRpcGx5aW5nIHRoZSBpbWFnZSBiZWxvdy4gRXF1aXZhbGVudCB0byB0aGUgYC0tcHJlbXVsdGlwbGllZGAgdmlwcyBvcHRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW2ltYWdlc1tdLmRlbnNpdHk9NzJdIC0gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgRFBJIGZvciB2ZWN0b3Igb3ZlcmxheSBpbWFnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW1hZ2VzW10ucmF3XSAtIGRlc2NyaWJlcyBvdmVybGF5IHdoZW4gdXNpbmcgcmF3IHBpeGVsIGRhdGEuXG4gKiBAcGFyYW0ge051bWJlcn0gW2ltYWdlc1tdLnJhdy53aWR0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VzW10ucmF3LmhlaWdodF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW1hZ2VzW10ucmF3LmNoYW5uZWxzXVxuICogQHBhcmFtIHtib29sZWFufSBbaW1hZ2VzW10uYW5pbWF0ZWQ9ZmFsc2VdIC0gU2V0IHRvIGB0cnVlYCB0byByZWFkIGFsbCBmcmFtZXMvcGFnZXMgb2YgYW4gYW5pbWF0ZWQgaW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ltYWdlc1tdLmZhaWxPbj0nd2FybmluZyddIC0gQHNlZSB7QGxpbmsgL2FwaS1jb25zdHJ1Y3RvciNwYXJhbWV0ZXJzfGNvbnN0cnVjdG9yIHBhcmFtZXRlcnN9XG4gKiBAcGFyYW0ge251bWJlcnxib29sZWFufSBbaW1hZ2VzW10ubGltaXRJbnB1dFBpeGVscz0yNjg0MDI2ODldIC0gQHNlZSB7QGxpbmsgL2FwaS1jb25zdHJ1Y3RvciNwYXJhbWV0ZXJzfGNvbnN0cnVjdG9yIHBhcmFtZXRlcnN9XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2l0ZSAoaW1hZ2VzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbWFnZXMpKSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdpbWFnZXMgdG8gY29tcG9zaXRlJywgJ2FycmF5JywgaW1hZ2VzKTtcbiAgfVxuICB0aGlzLm9wdGlvbnMuY29tcG9zaXRlID0gaW1hZ2VzLm1hcChpbWFnZSA9PiB7XG4gICAgaWYgKCFpcy5vYmplY3QoaW1hZ2UpKSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2ltYWdlIHRvIGNvbXBvc2l0ZScsICdvYmplY3QnLCBpbWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0T3B0aW9ucyA9IHRoaXMuX2lucHV0T3B0aW9uc0Zyb21PYmplY3QoaW1hZ2UpO1xuICAgIGNvbnN0IGNvbXBvc2l0ZSA9IHtcbiAgICAgIGlucHV0OiB0aGlzLl9jcmVhdGVJbnB1dERlc2NyaXB0b3IoaW1hZ2UuaW5wdXQsIGlucHV0T3B0aW9ucywgeyBhbGxvd1N0cmVhbTogZmFsc2UgfSksXG4gICAgICBibGVuZDogJ292ZXInLFxuICAgICAgdGlsZTogZmFsc2UsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgaGFzT2Zmc2V0OiBmYWxzZSxcbiAgICAgIGdyYXZpdHk6IDAsXG4gICAgICBwcmVtdWx0aXBsaWVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKGlzLmRlZmluZWQoaW1hZ2UuYmxlbmQpKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKGJsZW5kW2ltYWdlLmJsZW5kXSkpIHtcbiAgICAgICAgY29tcG9zaXRlLmJsZW5kID0gYmxlbmRbaW1hZ2UuYmxlbmRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdibGVuZCcsICd2YWxpZCBibGVuZCBuYW1lJywgaW1hZ2UuYmxlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChpbWFnZS50aWxlKSkge1xuICAgICAgaWYgKGlzLmJvb2woaW1hZ2UudGlsZSkpIHtcbiAgICAgICAgY29tcG9zaXRlLnRpbGUgPSBpbWFnZS50aWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd0aWxlJywgJ2Jvb2xlYW4nLCBpbWFnZS50aWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQoaW1hZ2UubGVmdCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKGltYWdlLmxlZnQpKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5sZWZ0ID0gaW1hZ2UubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignbGVmdCcsICdpbnRlZ2VyJywgaW1hZ2UubGVmdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKGltYWdlLnRvcCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKGltYWdlLnRvcCkpIHtcbiAgICAgICAgY29tcG9zaXRlLnRvcCA9IGltYWdlLnRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndG9wJywgJ2ludGVnZXInLCBpbWFnZS50b3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChpbWFnZS50b3ApICE9PSBpcy5kZWZpbmVkKGltYWdlLmxlZnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJvdGggbGVmdCBhbmQgdG9wIHRvIGJlIHNldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb3NpdGUuaGFzT2Zmc2V0ID0gaXMuaW50ZWdlcihpbWFnZS50b3ApICYmIGlzLmludGVnZXIoaW1hZ2UubGVmdCk7XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKGltYWdlLmdyYXZpdHkpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihpbWFnZS5ncmF2aXR5KSAmJiBpcy5pblJhbmdlKGltYWdlLmdyYXZpdHksIDAsIDgpKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5ncmF2aXR5ID0gaW1hZ2UuZ3Jhdml0eTtcbiAgICAgIH0gZWxzZSBpZiAoaXMuc3RyaW5nKGltYWdlLmdyYXZpdHkpICYmIGlzLmludGVnZXIodGhpcy5jb25zdHJ1Y3Rvci5ncmF2aXR5W2ltYWdlLmdyYXZpdHldKSkge1xuICAgICAgICBjb21wb3NpdGUuZ3Jhdml0eSA9IHRoaXMuY29uc3RydWN0b3IuZ3Jhdml0eVtpbWFnZS5ncmF2aXR5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZ3Jhdml0eScsICd2YWxpZCBncmF2aXR5JywgaW1hZ2UuZ3Jhdml0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKGltYWdlLnByZW11bHRpcGxpZWQpKSB7XG4gICAgICBpZiAoaXMuYm9vbChpbWFnZS5wcmVtdWx0aXBsaWVkKSkge1xuICAgICAgICBjb21wb3NpdGUucHJlbXVsdGlwbGllZCA9IGltYWdlLnByZW11bHRpcGxpZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3ByZW11bHRpcGxpZWQnLCAnYm9vbGVhbicsIGltYWdlLnByZW11bHRpcGxpZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcG9zaXRlO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogRGVjb3JhdGUgdGhlIFNoYXJwIHByb3RvdHlwZSB3aXRoIGNvbXBvc2l0ZS1yZWxhdGVkIGZ1bmN0aW9ucy5cbiAqIEBtb2R1bGUgU2hhcnBcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNoYXJwKSB7XG4gIFNoYXJwLnByb3RvdHlwZS5jb21wb3NpdGUgPSBjb21wb3NpdGU7XG4gIFNoYXJwLmJsZW5kID0gYmxlbmQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/composite.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/constructor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/constructor.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst util = __webpack_require__(/*! node:util */ \"node:util\");\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\n\n__webpack_require__(/*! ./sharp */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js\");\n\n// Use NODE_DEBUG=sharp to enable libvips warnings\nconst debuglog = util.debuglog('sharp');\n\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, GIF, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * When loading more than one page/frame of an animated image,\n * these are combined as a vertically-stacked \"toilet roll\" image\n * where the overall height is the `pageHeight` multiplied by the number of `pages`.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from remote URL,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * const { body } = fetch('https://...');\n * const readableStream = Readable.fromWeb(body);\n * const transformer = sharp()\n *   .resize(300)\n *   .on('info', ({ height }) => {\n *     console.log(`Image height is ${height}`);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-translucent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }).toFile('noise.png');\n *\n * @example\n * // Generate an image from text\n * await sharp({\n *   text: {\n *     text: 'Hello, world!',\n *     width: 400, // max width\n *     height: 300 // max height\n *   }\n * }).toFile('text_bw.png');\n *\n * @example\n * // Generate an rgba image from text using pango markup and font\n * await sharp({\n *   text: {\n *     text: '<span foreground=\"red\">Red!</span><span background=\"cyan\">blue</span>',\n *     font: 'sans',\n *     rgba: true,\n *     dpi: 300\n *   }\n * }).toFile('text_rgba.png');\n *\n * @example\n * // Join four input images as a 2x2 grid with a 4 pixel gutter\n * const data = await sharp(\n *  [image1, image2, image3, image4],\n *  { join: { across: 2, shim: 4 } }\n * ).toBuffer();\n *\n * @example\n * // Generate a two-frame animated image from emoji\n * const images = ['😀', '😛'].map(text => ({\n *   text: { text, width: 64, height: 64, channels: 4, rgba: true }\n * }));\n * await sharp(images, { join: { animated: true } }).toFile('out.gif');\n *\n * @param {(Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|string|Array)} [input] - if present, can be\n *  a Buffer / ArrayBuffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image data, or\n *  a TypedArray containing raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  An array of inputs can be provided, and these will be joined together.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string} [options.failOn='warning'] - When to abort processing of invalid pixel data, one of (in order of sensitivity, least to most): 'none', 'truncated', 'error', 'warning'. Higher levels imply lower levels. Invalid metadata will always abort.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.unlimited=false] - Set this to `true` to remove safety features that help prevent memory exhaustion (JPEG, PNG, SVG, HEIF).\n * @param {boolean} [options.autoOrient=false] - Set this to `true` to rotate/flip the image to match EXIF `Orientation`, if any.\n * @param {boolean} [options.sequentialRead=true] - Set this to `false` to use random access rather than sequential read. Some operations will do this automatically.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.ignoreIcc=false] - should the embedded ICC profile, if any, be ignored.\n * @param {number} [options.pages=1] - Number of pages to extract for multi-page input (GIF, WebP, TIFF), use -1 for all pages.\n * @param {number} [options.page=0] - Page number to start extracting from for multi-page input (GIF, WebP, TIFF), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (GIF, WebP, TIFF), equivalent of setting `pages` to `-1`.\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {boolean} [options.raw.premultiplied] - specifies that the raw input has already been premultiplied, set to `true`\n *  to avoid sharp premultiplying the image. (optional, default `false`)\n * @param {number} [options.raw.pageHeight] - The pixel height of each page/frame for animated images, must be an integral factor of `raw.height`.\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {number} [options.create.pageHeight] - The pixel height of each page/frame for animated images, must be an integral factor of `create.height`.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean=128] - Mean value of pixels in the generated noise.\n * @param {number} [options.create.noise.sigma=30] - Standard deviation of pixel values in the generated noise.\n * @param {Object} [options.text] - describes a new text image to be created.\n * @param {string} [options.text.text] - text to render as a UTF-8 string. It can contain Pango markup, for example `<i>Le</i>Monde`.\n * @param {string} [options.text.font] - font name to render with.\n * @param {string} [options.text.fontfile] - absolute filesystem path to a font file that can be used by `font`.\n * @param {number} [options.text.width=0] - Integral number of pixels to word-wrap at. Lines of text wider than this will be broken at word boundaries.\n * @param {number} [options.text.height=0] - Maximum integral number of pixels high. When defined, `dpi` will be ignored and the text will automatically fit the pixel resolution defined by `width` and `height`. Will be ignored if `width` is not specified or set to 0.\n * @param {string} [options.text.align='left'] - Alignment style for multi-line text (`'left'`, `'centre'`, `'center'`, `'right'`).\n * @param {boolean} [options.text.justify=false] - set this to true to apply justification to the text.\n * @param {number} [options.text.dpi=72] - the resolution (size) at which to render the text. Does not take effect if `height` is specified.\n * @param {boolean} [options.text.rgba=false] - set this to true to enable RGBA output. This is useful for colour emoji rendering, or support for pango markup features like `<span foreground=\"red\">Red!</span>`.\n * @param {number} [options.text.spacing=0] - text line height in points. Will use the font line height if none is specified.\n * @param {string} [options.text.wrap='word'] - word wrapping style when width is provided, one of: 'word', 'char', 'word-char' (prefer word, fallback to char) or 'none'.\n * @param {Object} [options.join] - describes how an array of input images should be joined.\n * @param {number} [options.join.across=1] - number of images to join horizontally.\n * @param {boolean} [options.join.animated=false] - set this to `true` to join the images as an animated image.\n * @param {number} [options.join.shim=0] - number of pixels to insert between joined images.\n * @param {string|Object} [options.join.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {string} [options.join.halign='left'] - horizontal alignment style for images joined horizontally (`'left'`, `'centre'`, `'center'`, `'right'`).\n * @param {string} [options.join.valign='top'] - vertical alignment style for images joined vertically (`'top'`, `'centre'`, `'center'`, `'bottom'`).\n * @param {Object} [options.tiff] - Describes TIFF specific options.\n * @param {number} [options.tiff.subifd=-1] - Sub Image File Directory to extract for OME-TIFF, defaults to main image.\n * @param {Object} [options.svg] - Describes SVG specific options.\n * @param {string} [options.svg.stylesheet] - Custom CSS for SVG input, applied with a User Origin during the CSS cascade.\n * @param {boolean} [options.svg.highBitdepth=false] - Set to `true` to render SVG input at 32-bits per channel (128-bit) instead of 8-bits per channel (32-bit) RGBA.\n * @param {Object} [options.pdf] - Describes PDF specific options. Requires the use of a globally-installed libvips compiled with support for PDFium, Poppler, ImageMagick or GraphicsMagick.\n * @param {string|Object} [options.pdf.background] - Background colour to use when PDF is partially transparent. Parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.openSlide] - Describes OpenSlide specific options. Requires the use of a globally-installed libvips compiled with support for OpenSlide.\n * @param {number} [options.openSlide.level=0] - Level to extract from a multi-level input, zero based.\n * @param {Object} [options.jp2] - Describes JPEG 2000 specific options. Requires the use of a globally-installed libvips compiled with support for OpenJPEG.\n * @param {boolean} [options.jp2.oneshot=false] - Set to `true` to decode tiled JPEG 2000 images in a single operation, improving compatibility.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBefore: false,\n    orientBefore: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    extendWith: 'background',\n    withoutEnlargement: false,\n    withoutReduction: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tint: [-1, 0, 0, 0],\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    unflatten: false,\n    negate: false,\n    negateAlpha: true,\n    medianSize: 0,\n    blurSigma: 0,\n    precision: 'integer',\n    minAmpl: 0.2,\n    sharpenSigma: 0,\n    sharpenM1: 1,\n    sharpenM2: 2,\n    sharpenX1: 2,\n    sharpenY2: 10,\n    sharpenY3: 20,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimBackground: [],\n    trimThreshold: -1,\n    trimLineArt: false,\n    dilateWidth: 0,\n    erodeWidth: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    normaliseLower: 1,\n    normaliseUpper: 99,\n    claheWidth: 0,\n    claheHeight: 0,\n    claheMaxSlope: 3,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    lightness: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: -1,\n    colourspace: 'srgb',\n    colourspacePipeline: 'last',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    keepMetadata: 0,\n    withMetadataOrientation: -1,\n    withMetadataDensity: 0,\n    withIccProfile: '',\n    withExif: {},\n    withExifMerge: true,\n    withXmp: '',\n    resolveWithObject: false,\n    loop: -1,\n    delay: [],\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 6,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngEffort: 7,\n    pngBitdepth: 8,\n    pngDither: 1,\n    jp2Quality: 80,\n    jp2TileHeight: 512,\n    jp2TileWidth: 512,\n    jp2Lossless: false,\n    jp2ChromaSubsampling: '4:4:4',\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpSmartDeblock: false,\n    webpPreset: 'default',\n    webpEffort: 4,\n    webpMinSize: false,\n    webpMixed: false,\n    gifBitdepth: 8,\n    gifEffort: 7,\n    gifDither: 1,\n    gifInterFrameMaxError: 0,\n    gifInterPaletteMaxError: 3,\n    gifKeepDuplicateFrames: false,\n    gifReuse: true,\n    gifProgressive: false,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffMiniswhite: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    tiffResolutionUnit: 'inch',\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifEffort: 4,\n    heifChromaSubsampling: '4:4:4',\n    heifBitdepth: 8,\n    jxlDistance: 1,\n    jxlDecodingTier: 0,\n    jxlEffort: 7,\n    jxlLossless: false,\n    rawDepth: 'uchar',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    tileId: 'https://example.com/iiif',\n    tileBasename: '',\n    timeoutSeconds: 0,\n    linearA: [],\n    linearB: [],\n    pdfBackground: [255, 255, 255, 255],\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, { allowStream: true });\n  return this;\n};\nObject.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);\nObject.setPrototypeOf(Sharp, stream.Duplex);\n\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({ failOn: 'none' });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got/blob/main/documentation/3-streams.md\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\nfunction clone () {\n  // Clone existing options\n  const clone = this.constructor.call();\n  const { debuglog, queueListener, ...options } = this.options;\n  clone.options = structuredClone(options);\n  clone.options.debuglog = debuglog;\n  clone.options.queueListener = queueListener;\n  // Pass 'finish' event to clone for Stream-based input\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n      clone.options.input.buffer = this.options.input.buffer;\n      clone.emit('finish');\n    });\n  }\n  return clone;\n}\nObject.assign(Sharp.prototype, { clone });\n\n/**\n * Export constructor.\n * @module Sharp\n * @private\n */\nmodule.exports = Sharp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvY29uc3RydWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNEJBQVc7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxrRkFBTTs7QUFFekIsbUJBQU8sQ0FBQyx3RkFBUzs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsc0NBQXNDLE9BQU87QUFDN0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLHlCQUF5QixRQUFRLGtCQUFrQjtBQUNuRDtBQUNBLFdBQVcsa0pBQWtKO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNENBQTRDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbnJvdXRlci1sYW5nZ3JhcGgvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvY29uc3RydWN0b3IuanM/ZGM2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMyBMb3ZlbGwgRnVsbGVyIGFuZCBvdGhlcnMuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxucmVxdWlyZSgnLi9zaGFycCcpO1xuXG4vLyBVc2UgTk9ERV9ERUJVRz1zaGFycCB0byBlbmFibGUgbGlidmlwcyB3YXJuaW5nc1xuY29uc3QgZGVidWdsb2cgPSB1dGlsLmRlYnVnbG9nKCdzaGFycCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZhY3RvcnkgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGBzaGFycGAsIHRvIHdoaWNoIGZ1cnRoZXIgbWV0aG9kcyBhcmUgY2hhaW5lZC5cbiAqXG4gKiBKUEVHLCBQTkcsIFdlYlAsIEdJRiwgQVZJRiBvciBUSUZGIGZvcm1hdCBpbWFnZSBkYXRhIGNhbiBiZSBzdHJlYW1lZCBvdXQgZnJvbSB0aGlzIG9iamVjdC5cbiAqIFdoZW4gdXNpbmcgU3RyZWFtIGJhc2VkIG91dHB1dCwgZGVyaXZlZCBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGUgZnJvbSB0aGUgYGluZm9gIGV2ZW50LlxuICpcbiAqIE5vbi1jcml0aWNhbCBwcm9ibGVtcyBlbmNvdW50ZXJlZCBkdXJpbmcgcHJvY2Vzc2luZyBhcmUgZW1pdHRlZCBhcyBgd2FybmluZ2AgZXZlbnRzLlxuICpcbiAqIEltcGxlbWVudHMgdGhlIFtzdHJlYW0uRHVwbGV4XShodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX2NsYXNzX3N0cmVhbV9kdXBsZXgpIGNsYXNzLlxuICpcbiAqIFdoZW4gbG9hZGluZyBtb3JlIHRoYW4gb25lIHBhZ2UvZnJhbWUgb2YgYW4gYW5pbWF0ZWQgaW1hZ2UsXG4gKiB0aGVzZSBhcmUgY29tYmluZWQgYXMgYSB2ZXJ0aWNhbGx5LXN0YWNrZWQgXCJ0b2lsZXQgcm9sbFwiIGltYWdlXG4gKiB3aGVyZSB0aGUgb3ZlcmFsbCBoZWlnaHQgaXMgdGhlIGBwYWdlSGVpZ2h0YCBtdWx0aXBsaWVkIGJ5IHRoZSBudW1iZXIgb2YgYHBhZ2VzYC5cbiAqXG4gKiBAY29uc3RydWN0cyBTaGFycFxuICpcbiAqIEBlbWl0cyBTaGFycCNpbmZvXG4gKiBAZW1pdHMgU2hhcnAjd2FybmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiBzaGFycCgnaW5wdXQuanBnJylcbiAqICAgLnJlc2l6ZSgzMDAsIDIwMClcbiAqICAgLnRvRmlsZSgnb3V0cHV0LmpwZycsIGZ1bmN0aW9uKGVycikge1xuICogICAgIC8vIG91dHB1dC5qcGcgaXMgYSAzMDAgcGl4ZWxzIHdpZGUgYW5kIDIwMCBwaXhlbHMgaGlnaCBpbWFnZVxuICogICAgIC8vIGNvbnRhaW5pbmcgYSBzY2FsZWQgYW5kIGNyb3BwZWQgdmVyc2lvbiBvZiBpbnB1dC5qcGdcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlYWQgaW1hZ2UgZGF0YSBmcm9tIHJlbW90ZSBVUkwsXG4gKiAvLyByZXNpemUgdG8gMzAwIHBpeGVscyB3aWRlLFxuICogLy8gZW1pdCBhbiAnaW5mbycgZXZlbnQgd2l0aCBjYWxjdWxhdGVkIGRpbWVuc2lvbnNcbiAqIC8vIGFuZCBmaW5hbGx5IHdyaXRlIGltYWdlIGRhdGEgdG8gd3JpdGFibGVTdHJlYW1cbiAqIGNvbnN0IHsgYm9keSB9ID0gZmV0Y2goJ2h0dHBzOi8vLi4uJyk7XG4gKiBjb25zdCByZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlLmZyb21XZWIoYm9keSk7XG4gKiBjb25zdCB0cmFuc2Zvcm1lciA9IHNoYXJwKClcbiAqICAgLnJlc2l6ZSgzMDApXG4gKiAgIC5vbignaW5mbycsICh7IGhlaWdodCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coYEltYWdlIGhlaWdodCBpcyAke2hlaWdodH1gKTtcbiAqICAgfSk7XG4gKiByZWFkYWJsZVN0cmVhbS5waXBlKHRyYW5zZm9ybWVyKS5waXBlKHdyaXRhYmxlU3RyZWFtKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgYmxhbmsgMzAweDIwMCBQTkcgaW1hZ2Ugb2Ygc2VtaS10cmFuc2x1Y2VudCByZWQgcGl4ZWxzXG4gKiBzaGFycCh7XG4gKiAgIGNyZWF0ZToge1xuICogICAgIHdpZHRoOiAzMDAsXG4gKiAgICAgaGVpZ2h0OiAyMDAsXG4gKiAgICAgY2hhbm5lbHM6IDQsXG4gKiAgICAgYmFja2dyb3VuZDogeyByOiAyNTUsIGc6IDAsIGI6IDAsIGFscGhhOiAwLjUgfVxuICogICB9XG4gKiB9KVxuICogLnBuZygpXG4gKiAudG9CdWZmZXIoKVxuICogLnRoZW4oIC4uLiApO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IGFuIGFuaW1hdGVkIEdJRiB0byBhbiBhbmltYXRlZCBXZWJQXG4gKiBhd2FpdCBzaGFycCgnaW4uZ2lmJywgeyBhbmltYXRlZDogdHJ1ZSB9KS50b0ZpbGUoJ291dC53ZWJwJyk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlYWQgYSByYXcgYXJyYXkgb2YgcGl4ZWxzIGFuZCBzYXZlIGl0IHRvIGEgcG5nXG4gKiBjb25zdCBpbnB1dCA9IFVpbnQ4QXJyYXkuZnJvbShbMjU1LCAyNTUsIDI1NSwgMCwgMCwgMF0pOyAvLyBvciBVaW50OENsYW1wZWRBcnJheVxuICogY29uc3QgaW1hZ2UgPSBzaGFycChpbnB1dCwge1xuICogICAvLyBiZWNhdXNlIHRoZSBpbnB1dCBkb2VzIG5vdCBjb250YWluIGl0cyBkaW1lbnNpb25zIG9yIGhvdyBtYW55IGNoYW5uZWxzIGl0IGhhc1xuICogICAvLyB3ZSBuZWVkIHRvIHNwZWNpZnkgaXQgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAqICAgcmF3OiB7XG4gKiAgICAgd2lkdGg6IDIsXG4gKiAgICAgaGVpZ2h0OiAxLFxuICogICAgIGNoYW5uZWxzOiAzXG4gKiAgIH1cbiAqIH0pO1xuICogYXdhaXQgaW1hZ2UudG9GaWxlKCdteS10d28tcGl4ZWxzLnBuZycpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZW5lcmF0ZSBSR0IgR2F1c3NpYW4gbm9pc2VcbiAqIGF3YWl0IHNoYXJwKHtcbiAqICAgY3JlYXRlOiB7XG4gKiAgICAgd2lkdGg6IDMwMCxcbiAqICAgICBoZWlnaHQ6IDIwMCxcbiAqICAgICBjaGFubmVsczogMyxcbiAqICAgICBub2lzZToge1xuICogICAgICAgdHlwZTogJ2dhdXNzaWFuJyxcbiAqICAgICAgIG1lYW46IDEyOCxcbiAqICAgICAgIHNpZ21hOiAzMFxuICogICAgIH1cbiAqICB9XG4gKiB9KS50b0ZpbGUoJ25vaXNlLnBuZycpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZW5lcmF0ZSBhbiBpbWFnZSBmcm9tIHRleHRcbiAqIGF3YWl0IHNoYXJwKHtcbiAqICAgdGV4dDoge1xuICogICAgIHRleHQ6ICdIZWxsbywgd29ybGQhJyxcbiAqICAgICB3aWR0aDogNDAwLCAvLyBtYXggd2lkdGhcbiAqICAgICBoZWlnaHQ6IDMwMCAvLyBtYXggaGVpZ2h0XG4gKiAgIH1cbiAqIH0pLnRvRmlsZSgndGV4dF9idy5wbmcnKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2VuZXJhdGUgYW4gcmdiYSBpbWFnZSBmcm9tIHRleHQgdXNpbmcgcGFuZ28gbWFya3VwIGFuZCBmb250XG4gKiBhd2FpdCBzaGFycCh7XG4gKiAgIHRleHQ6IHtcbiAqICAgICB0ZXh0OiAnPHNwYW4gZm9yZWdyb3VuZD1cInJlZFwiPlJlZCE8L3NwYW4+PHNwYW4gYmFja2dyb3VuZD1cImN5YW5cIj5ibHVlPC9zcGFuPicsXG4gKiAgICAgZm9udDogJ3NhbnMnLFxuICogICAgIHJnYmE6IHRydWUsXG4gKiAgICAgZHBpOiAzMDBcbiAqICAgfVxuICogfSkudG9GaWxlKCd0ZXh0X3JnYmEucG5nJyk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEpvaW4gZm91ciBpbnB1dCBpbWFnZXMgYXMgYSAyeDIgZ3JpZCB3aXRoIGEgNCBwaXhlbCBndXR0ZXJcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChcbiAqICBbaW1hZ2UxLCBpbWFnZTIsIGltYWdlMywgaW1hZ2U0XSxcbiAqICB7IGpvaW46IHsgYWNyb3NzOiAyLCBzaGltOiA0IH0gfVxuICogKS50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZW5lcmF0ZSBhIHR3by1mcmFtZSBhbmltYXRlZCBpbWFnZSBmcm9tIGVtb2ppXG4gKiBjb25zdCBpbWFnZXMgPSBbJ/CfmIAnLCAn8J+YmyddLm1hcCh0ZXh0ID0+ICh7XG4gKiAgIHRleHQ6IHsgdGV4dCwgd2lkdGg6IDY0LCBoZWlnaHQ6IDY0LCBjaGFubmVsczogNCwgcmdiYTogdHJ1ZSB9XG4gKiB9KSk7XG4gKiBhd2FpdCBzaGFycChpbWFnZXMsIHsgam9pbjogeyBhbmltYXRlZDogdHJ1ZSB9IH0pLnRvRmlsZSgnb3V0LmdpZicpO1xuICpcbiAqIEBwYXJhbSB7KEJ1ZmZlcnxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fEludDhBcnJheXxVaW50MTZBcnJheXxJbnQxNkFycmF5fFVpbnQzMkFycmF5fEludDMyQXJyYXl8RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheXxzdHJpbmd8QXJyYXkpfSBbaW5wdXRdIC0gaWYgcHJlc2VudCwgY2FuIGJlXG4gKiAgYSBCdWZmZXIgLyBBcnJheUJ1ZmZlciAvIFVpbnQ4QXJyYXkgLyBVaW50OENsYW1wZWRBcnJheSBjb250YWluaW5nIEpQRUcsIFBORywgV2ViUCwgQVZJRiwgR0lGLCBTVkcgb3IgVElGRiBpbWFnZSBkYXRhLCBvclxuICogIGEgVHlwZWRBcnJheSBjb250YWluaW5nIHJhdyBwaXhlbCBpbWFnZSBkYXRhLCBvclxuICogIGEgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbGVzeXN0ZW0gcGF0aCB0byBhbiBKUEVHLCBQTkcsIFdlYlAsIEFWSUYsIEdJRiwgU1ZHIG9yIFRJRkYgaW1hZ2UgZmlsZS5cbiAqICBBbiBhcnJheSBvZiBpbnB1dHMgY2FuIGJlIHByb3ZpZGVkLCBhbmQgdGhlc2Ugd2lsbCBiZSBqb2luZWQgdG9nZXRoZXIuXG4gKiAgSlBFRywgUE5HLCBXZWJQLCBBVklGLCBHSUYsIFNWRywgVElGRiBvciByYXcgcGl4ZWwgaW1hZ2UgZGF0YSBjYW4gYmUgc3RyZWFtZWQgaW50byB0aGUgb2JqZWN0IHdoZW4gbm90IHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gaWYgcHJlc2VudCwgaXMgYW4gT2JqZWN0IHdpdGggb3B0aW9uYWwgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mYWlsT249J3dhcm5pbmcnXSAtIFdoZW4gdG8gYWJvcnQgcHJvY2Vzc2luZyBvZiBpbnZhbGlkIHBpeGVsIGRhdGEsIG9uZSBvZiAoaW4gb3JkZXIgb2Ygc2Vuc2l0aXZpdHksIGxlYXN0IHRvIG1vc3QpOiAnbm9uZScsICd0cnVuY2F0ZWQnLCAnZXJyb3InLCAnd2FybmluZycuIEhpZ2hlciBsZXZlbHMgaW1wbHkgbG93ZXIgbGV2ZWxzLiBJbnZhbGlkIG1ldGFkYXRhIHdpbGwgYWx3YXlzIGFib3J0LlxuICogQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbn0gW29wdGlvbnMubGltaXRJbnB1dFBpeGVscz0yNjg0MDI2ODldIC0gRG8gbm90IHByb2Nlc3MgaW5wdXQgaW1hZ2VzIHdoZXJlIHRoZSBudW1iZXIgb2YgcGl4ZWxzXG4gKiAgKHdpZHRoIHggaGVpZ2h0KSBleGNlZWRzIHRoaXMgbGltaXQuIEFzc3VtZXMgaW1hZ2UgZGltZW5zaW9ucyBjb250YWluZWQgaW4gdGhlIGlucHV0IG1ldGFkYXRhIGNhbiBiZSB0cnVzdGVkLlxuICogIEFuIGludGVncmFsIE51bWJlciBvZiBwaXhlbHMsIHplcm8gb3IgZmFsc2UgdG8gcmVtb3ZlIGxpbWl0LCB0cnVlIHRvIHVzZSBkZWZhdWx0IGxpbWl0IG9mIDI2ODQwMjY4OSAoMHgzRkZGIHggMHgzRkZGKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudW5saW1pdGVkPWZhbHNlXSAtIFNldCB0aGlzIHRvIGB0cnVlYCB0byByZW1vdmUgc2FmZXR5IGZlYXR1cmVzIHRoYXQgaGVscCBwcmV2ZW50IG1lbW9yeSBleGhhdXN0aW9uIChKUEVHLCBQTkcsIFNWRywgSEVJRikuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9PcmllbnQ9ZmFsc2VdIC0gU2V0IHRoaXMgdG8gYHRydWVgIHRvIHJvdGF0ZS9mbGlwIHRoZSBpbWFnZSB0byBtYXRjaCBFWElGIGBPcmllbnRhdGlvbmAsIGlmIGFueS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VxdWVudGlhbFJlYWQ9dHJ1ZV0gLSBTZXQgdGhpcyB0byBgZmFsc2VgIHRvIHVzZSByYW5kb20gYWNjZXNzIHJhdGhlciB0aGFuIHNlcXVlbnRpYWwgcmVhZC4gU29tZSBvcGVyYXRpb25zIHdpbGwgZG8gdGhpcyBhdXRvbWF0aWNhbGx5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlbnNpdHk9NzJdIC0gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgRFBJIGZvciB2ZWN0b3IgaW1hZ2VzIGluIHRoZSByYW5nZSAxIHRvIDEwMDAwMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pZ25vcmVJY2M9ZmFsc2VdIC0gc2hvdWxkIHRoZSBlbWJlZGRlZCBJQ0MgcHJvZmlsZSwgaWYgYW55LCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZ2VzPTFdIC0gTnVtYmVyIG9mIHBhZ2VzIHRvIGV4dHJhY3QgZm9yIG11bHRpLXBhZ2UgaW5wdXQgKEdJRiwgV2ViUCwgVElGRiksIHVzZSAtMSBmb3IgYWxsIHBhZ2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZ2U9MF0gLSBQYWdlIG51bWJlciB0byBzdGFydCBleHRyYWN0aW5nIGZyb20gZm9yIG11bHRpLXBhZ2UgaW5wdXQgKEdJRiwgV2ViUCwgVElGRiksIHplcm8gYmFzZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFuaW1hdGVkPWZhbHNlXSAtIFNldCB0byBgdHJ1ZWAgdG8gcmVhZCBhbGwgZnJhbWVzL3BhZ2VzIG9mIGFuIGFuaW1hdGVkIGltYWdlIChHSUYsIFdlYlAsIFRJRkYpLCBlcXVpdmFsZW50IG9mIHNldHRpbmcgYHBhZ2VzYCB0byBgLTFgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJhd10gLSBkZXNjcmliZXMgcmF3IHBpeGVsIGlucHV0IGltYWdlIGRhdGEuIFNlZSBgcmF3KClgIGZvciBwaXhlbCBvcmRlcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYXcud2lkdGhdIC0gaW50ZWdyYWwgbnVtYmVyIG9mIHBpeGVscyB3aWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhdy5oZWlnaHRdIC0gaW50ZWdyYWwgbnVtYmVyIG9mIHBpeGVscyBoaWdoLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhdy5jaGFubmVsc10gLSBpbnRlZ3JhbCBudW1iZXIgb2YgY2hhbm5lbHMsIGJldHdlZW4gMSBhbmQgNC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmF3LnByZW11bHRpcGxpZWRdIC0gc3BlY2lmaWVzIHRoYXQgdGhlIHJhdyBpbnB1dCBoYXMgYWxyZWFkeSBiZWVuIHByZW11bHRpcGxpZWQsIHNldCB0byBgdHJ1ZWBcbiAqICB0byBhdm9pZCBzaGFycCBwcmVtdWx0aXBseWluZyB0aGUgaW1hZ2UuIChvcHRpb25hbCwgZGVmYXVsdCBgZmFsc2VgKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhdy5wYWdlSGVpZ2h0XSAtIFRoZSBwaXhlbCBoZWlnaHQgb2YgZWFjaCBwYWdlL2ZyYW1lIGZvciBhbmltYXRlZCBpbWFnZXMsIG11c3QgYmUgYW4gaW50ZWdyYWwgZmFjdG9yIG9mIGByYXcuaGVpZ2h0YC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jcmVhdGVdIC0gZGVzY3JpYmVzIGEgbmV3IGltYWdlIHRvIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3JlYXRlLndpZHRoXSAtIGludGVncmFsIG51bWJlciBvZiBwaXhlbHMgd2lkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jcmVhdGUuaGVpZ2h0XSAtIGludGVncmFsIG51bWJlciBvZiBwaXhlbHMgaGlnaC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jcmVhdGUuY2hhbm5lbHNdIC0gaW50ZWdyYWwgbnVtYmVyIG9mIGNoYW5uZWxzLCBlaXRoZXIgMyAoUkdCKSBvciA0IChSR0JBKS5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW29wdGlvbnMuY3JlYXRlLmJhY2tncm91bmRdIC0gcGFyc2VkIGJ5IHRoZSBbY29sb3JdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL2NvbG9yKSBtb2R1bGUgdG8gZXh0cmFjdCB2YWx1ZXMgZm9yIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNyZWF0ZS5wYWdlSGVpZ2h0XSAtIFRoZSBwaXhlbCBoZWlnaHQgb2YgZWFjaCBwYWdlL2ZyYW1lIGZvciBhbmltYXRlZCBpbWFnZXMsIG11c3QgYmUgYW4gaW50ZWdyYWwgZmFjdG9yIG9mIGBjcmVhdGUuaGVpZ2h0YC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jcmVhdGUubm9pc2VdIC0gZGVzY3JpYmVzIGEgbm9pc2UgdG8gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jcmVhdGUubm9pc2UudHlwZV0gLSB0eXBlIG9mIGdlbmVyYXRlZCBub2lzZSwgY3VycmVudGx5IG9ubHkgYGdhdXNzaWFuYCBpcyBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3JlYXRlLm5vaXNlLm1lYW49MTI4XSAtIE1lYW4gdmFsdWUgb2YgcGl4ZWxzIGluIHRoZSBnZW5lcmF0ZWQgbm9pc2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3JlYXRlLm5vaXNlLnNpZ21hPTMwXSAtIFN0YW5kYXJkIGRldmlhdGlvbiBvZiBwaXhlbCB2YWx1ZXMgaW4gdGhlIGdlbmVyYXRlZCBub2lzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSAtIGRlc2NyaWJlcyBhIG5ldyB0ZXh0IGltYWdlIHRvIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSAtIHRleHQgdG8gcmVuZGVyIGFzIGEgVVRGLTggc3RyaW5nLiBJdCBjYW4gY29udGFpbiBQYW5nbyBtYXJrdXAsIGZvciBleGFtcGxlIGA8aT5MZTwvaT5Nb25kZWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGV4dC5mb250XSAtIGZvbnQgbmFtZSB0byByZW5kZXIgd2l0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXh0LmZvbnRmaWxlXSAtIGFic29sdXRlIGZpbGVzeXN0ZW0gcGF0aCB0byBhIGZvbnQgZmlsZSB0aGF0IGNhbiBiZSB1c2VkIGJ5IGBmb250YC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50ZXh0LndpZHRoPTBdIC0gSW50ZWdyYWwgbnVtYmVyIG9mIHBpeGVscyB0byB3b3JkLXdyYXAgYXQuIExpbmVzIG9mIHRleHQgd2lkZXIgdGhhbiB0aGlzIHdpbGwgYmUgYnJva2VuIGF0IHdvcmQgYm91bmRhcmllcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50ZXh0LmhlaWdodD0wXSAtIE1heGltdW0gaW50ZWdyYWwgbnVtYmVyIG9mIHBpeGVscyBoaWdoLiBXaGVuIGRlZmluZWQsIGBkcGlgIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIHRleHQgd2lsbCBhdXRvbWF0aWNhbGx5IGZpdCB0aGUgcGl4ZWwgcmVzb2x1dGlvbiBkZWZpbmVkIGJ5IGB3aWR0aGAgYW5kIGBoZWlnaHRgLiBXaWxsIGJlIGlnbm9yZWQgaWYgYHdpZHRoYCBpcyBub3Qgc3BlY2lmaWVkIG9yIHNldCB0byAwLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRleHQuYWxpZ249J2xlZnQnXSAtIEFsaWdubWVudCBzdHlsZSBmb3IgbXVsdGktbGluZSB0ZXh0IChgJ2xlZnQnYCwgYCdjZW50cmUnYCwgYCdjZW50ZXInYCwgYCdyaWdodCdgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dC5qdXN0aWZ5PWZhbHNlXSAtIHNldCB0aGlzIHRvIHRydWUgdG8gYXBwbHkganVzdGlmaWNhdGlvbiB0byB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50ZXh0LmRwaT03Ml0gLSB0aGUgcmVzb2x1dGlvbiAoc2l6ZSkgYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSB0ZXh0LiBEb2VzIG5vdCB0YWtlIGVmZmVjdCBpZiBgaGVpZ2h0YCBpcyBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHQucmdiYT1mYWxzZV0gLSBzZXQgdGhpcyB0byB0cnVlIHRvIGVuYWJsZSBSR0JBIG91dHB1dC4gVGhpcyBpcyB1c2VmdWwgZm9yIGNvbG91ciBlbW9qaSByZW5kZXJpbmcsIG9yIHN1cHBvcnQgZm9yIHBhbmdvIG1hcmt1cCBmZWF0dXJlcyBsaWtlIGA8c3BhbiBmb3JlZ3JvdW5kPVwicmVkXCI+UmVkITwvc3Bhbj5gLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRleHQuc3BhY2luZz0wXSAtIHRleHQgbGluZSBoZWlnaHQgaW4gcG9pbnRzLiBXaWxsIHVzZSB0aGUgZm9udCBsaW5lIGhlaWdodCBpZiBub25lIGlzIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXh0LndyYXA9J3dvcmQnXSAtIHdvcmQgd3JhcHBpbmcgc3R5bGUgd2hlbiB3aWR0aCBpcyBwcm92aWRlZCwgb25lIG9mOiAnd29yZCcsICdjaGFyJywgJ3dvcmQtY2hhcicgKHByZWZlciB3b3JkLCBmYWxsYmFjayB0byBjaGFyKSBvciAnbm9uZScuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuam9pbl0gLSBkZXNjcmliZXMgaG93IGFuIGFycmF5IG9mIGlucHV0IGltYWdlcyBzaG91bGQgYmUgam9pbmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmpvaW4uYWNyb3NzPTFdIC0gbnVtYmVyIG9mIGltYWdlcyB0byBqb2luIGhvcml6b250YWxseS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuam9pbi5hbmltYXRlZD1mYWxzZV0gLSBzZXQgdGhpcyB0byBgdHJ1ZWAgdG8gam9pbiB0aGUgaW1hZ2VzIGFzIGFuIGFuaW1hdGVkIGltYWdlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmpvaW4uc2hpbT0wXSAtIG51bWJlciBvZiBwaXhlbHMgdG8gaW5zZXJ0IGJldHdlZW4gam9pbmVkIGltYWdlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW29wdGlvbnMuam9pbi5iYWNrZ3JvdW5kXSAtIHBhcnNlZCBieSB0aGUgW2NvbG9yXShodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9jb2xvcikgbW9kdWxlIHRvIGV4dHJhY3QgdmFsdWVzIGZvciByZWQsIGdyZWVuLCBibHVlIGFuZCBhbHBoYS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5qb2luLmhhbGlnbj0nbGVmdCddIC0gaG9yaXpvbnRhbCBhbGlnbm1lbnQgc3R5bGUgZm9yIGltYWdlcyBqb2luZWQgaG9yaXpvbnRhbGx5IChgJ2xlZnQnYCwgYCdjZW50cmUnYCwgYCdjZW50ZXInYCwgYCdyaWdodCdgKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5qb2luLnZhbGlnbj0ndG9wJ10gLSB2ZXJ0aWNhbCBhbGlnbm1lbnQgc3R5bGUgZm9yIGltYWdlcyBqb2luZWQgdmVydGljYWxseSAoYCd0b3AnYCwgYCdjZW50cmUnYCwgYCdjZW50ZXInYCwgYCdib3R0b20nYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGlmZl0gLSBEZXNjcmliZXMgVElGRiBzcGVjaWZpYyBvcHRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpZmYuc3ViaWZkPS0xXSAtIFN1YiBJbWFnZSBGaWxlIERpcmVjdG9yeSB0byBleHRyYWN0IGZvciBPTUUtVElGRiwgZGVmYXVsdHMgdG8gbWFpbiBpbWFnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdmddIC0gRGVzY3JpYmVzIFNWRyBzcGVjaWZpYyBvcHRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN2Zy5zdHlsZXNoZWV0XSAtIEN1c3RvbSBDU1MgZm9yIFNWRyBpbnB1dCwgYXBwbGllZCB3aXRoIGEgVXNlciBPcmlnaW4gZHVyaW5nIHRoZSBDU1MgY2FzY2FkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ZnLmhpZ2hCaXRkZXB0aD1mYWxzZV0gLSBTZXQgdG8gYHRydWVgIHRvIHJlbmRlciBTVkcgaW5wdXQgYXQgMzItYml0cyBwZXIgY2hhbm5lbCAoMTI4LWJpdCkgaW5zdGVhZCBvZiA4LWJpdHMgcGVyIGNoYW5uZWwgKDMyLWJpdCkgUkdCQS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wZGZdIC0gRGVzY3JpYmVzIFBERiBzcGVjaWZpYyBvcHRpb25zLiBSZXF1aXJlcyB0aGUgdXNlIG9mIGEgZ2xvYmFsbHktaW5zdGFsbGVkIGxpYnZpcHMgY29tcGlsZWQgd2l0aCBzdXBwb3J0IGZvciBQREZpdW0sIFBvcHBsZXIsIEltYWdlTWFnaWNrIG9yIEdyYXBoaWNzTWFnaWNrLlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbb3B0aW9ucy5wZGYuYmFja2dyb3VuZF0gLSBCYWNrZ3JvdW5kIGNvbG91ciB0byB1c2Ugd2hlbiBQREYgaXMgcGFydGlhbGx5IHRyYW5zcGFyZW50LiBQYXJzZWQgYnkgdGhlIFtjb2xvcl0oaHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvY29sb3IpIG1vZHVsZSB0byBleHRyYWN0IHZhbHVlcyBmb3IgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3BlblNsaWRlXSAtIERlc2NyaWJlcyBPcGVuU2xpZGUgc3BlY2lmaWMgb3B0aW9ucy4gUmVxdWlyZXMgdGhlIHVzZSBvZiBhIGdsb2JhbGx5LWluc3RhbGxlZCBsaWJ2aXBzIGNvbXBpbGVkIHdpdGggc3VwcG9ydCBmb3IgT3BlblNsaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm9wZW5TbGlkZS5sZXZlbD0wXSAtIExldmVsIHRvIGV4dHJhY3QgZnJvbSBhIG11bHRpLWxldmVsIGlucHV0LCB6ZXJvIGJhc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmpwMl0gLSBEZXNjcmliZXMgSlBFRyAyMDAwIHNwZWNpZmljIG9wdGlvbnMuIFJlcXVpcmVzIHRoZSB1c2Ugb2YgYSBnbG9iYWxseS1pbnN0YWxsZWQgbGlidmlwcyBjb21waWxlZCB3aXRoIHN1cHBvcnQgZm9yIE9wZW5KUEVHLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5qcDIub25lc2hvdD1mYWxzZV0gLSBTZXQgdG8gYHRydWVgIHRvIGRlY29kZSB0aWxlZCBKUEVHIDIwMDAgaW1hZ2VzIGluIGEgc2luZ2xlIG9wZXJhdGlvbiwgaW1wcm92aW5nIGNvbXBhdGliaWxpdHkuXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmNvbnN0IFNoYXJwID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpcy5kZWZpbmVkKGlucHV0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCcpO1xuICB9XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTaGFycCkpIHtcbiAgICByZXR1cm4gbmV3IFNoYXJwKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcyk7XG4gIHRoaXMub3B0aW9ucyA9IHtcbiAgICAvLyByZXNpemUgb3B0aW9uc1xuICAgIHRvcE9mZnNldFByZTogLTEsXG4gICAgbGVmdE9mZnNldFByZTogLTEsXG4gICAgd2lkdGhQcmU6IC0xLFxuICAgIGhlaWdodFByZTogLTEsXG4gICAgdG9wT2Zmc2V0UG9zdDogLTEsXG4gICAgbGVmdE9mZnNldFBvc3Q6IC0xLFxuICAgIHdpZHRoUG9zdDogLTEsXG4gICAgaGVpZ2h0UG9zdDogLTEsXG4gICAgd2lkdGg6IC0xLFxuICAgIGhlaWdodDogLTEsXG4gICAgY2FudmFzOiAnY3JvcCcsXG4gICAgcG9zaXRpb246IDAsXG4gICAgcmVzaXplQmFja2dyb3VuZDogWzAsIDAsIDAsIDI1NV0sXG4gICAgYW5nbGU6IDAsXG4gICAgcm90YXRpb25BbmdsZTogMCxcbiAgICByb3RhdGlvbkJhY2tncm91bmQ6IFswLCAwLCAwLCAyNTVdLFxuICAgIHJvdGF0ZUJlZm9yZTogZmFsc2UsXG4gICAgb3JpZW50QmVmb3JlOiBmYWxzZSxcbiAgICBmbGlwOiBmYWxzZSxcbiAgICBmbG9wOiBmYWxzZSxcbiAgICBleHRlbmRUb3A6IDAsXG4gICAgZXh0ZW5kQm90dG9tOiAwLFxuICAgIGV4dGVuZExlZnQ6IDAsXG4gICAgZXh0ZW5kUmlnaHQ6IDAsXG4gICAgZXh0ZW5kQmFja2dyb3VuZDogWzAsIDAsIDAsIDI1NV0sXG4gICAgZXh0ZW5kV2l0aDogJ2JhY2tncm91bmQnLFxuICAgIHdpdGhvdXRFbmxhcmdlbWVudDogZmFsc2UsXG4gICAgd2l0aG91dFJlZHVjdGlvbjogZmFsc2UsXG4gICAgYWZmaW5lTWF0cml4OiBbXSxcbiAgICBhZmZpbmVCYWNrZ3JvdW5kOiBbMCwgMCwgMCwgMjU1XSxcbiAgICBhZmZpbmVJZHg6IDAsXG4gICAgYWZmaW5lSWR5OiAwLFxuICAgIGFmZmluZU9keDogMCxcbiAgICBhZmZpbmVPZHk6IDAsXG4gICAgYWZmaW5lSW50ZXJwb2xhdG9yOiB0aGlzLmNvbnN0cnVjdG9yLmludGVycG9sYXRvcnMuYmlsaW5lYXIsXG4gICAga2VybmVsOiAnbGFuY3pvczMnLFxuICAgIGZhc3RTaHJpbmtPbkxvYWQ6IHRydWUsXG4gICAgLy8gb3BlcmF0aW9uc1xuICAgIHRpbnQ6IFstMSwgMCwgMCwgMF0sXG4gICAgZmxhdHRlbjogZmFsc2UsXG4gICAgZmxhdHRlbkJhY2tncm91bmQ6IFswLCAwLCAwXSxcbiAgICB1bmZsYXR0ZW46IGZhbHNlLFxuICAgIG5lZ2F0ZTogZmFsc2UsXG4gICAgbmVnYXRlQWxwaGE6IHRydWUsXG4gICAgbWVkaWFuU2l6ZTogMCxcbiAgICBibHVyU2lnbWE6IDAsXG4gICAgcHJlY2lzaW9uOiAnaW50ZWdlcicsXG4gICAgbWluQW1wbDogMC4yLFxuICAgIHNoYXJwZW5TaWdtYTogMCxcbiAgICBzaGFycGVuTTE6IDEsXG4gICAgc2hhcnBlbk0yOiAyLFxuICAgIHNoYXJwZW5YMTogMixcbiAgICBzaGFycGVuWTI6IDEwLFxuICAgIHNoYXJwZW5ZMzogMjAsXG4gICAgdGhyZXNob2xkOiAwLFxuICAgIHRocmVzaG9sZEdyYXlzY2FsZTogdHJ1ZSxcbiAgICB0cmltQmFja2dyb3VuZDogW10sXG4gICAgdHJpbVRocmVzaG9sZDogLTEsXG4gICAgdHJpbUxpbmVBcnQ6IGZhbHNlLFxuICAgIGRpbGF0ZVdpZHRoOiAwLFxuICAgIGVyb2RlV2lkdGg6IDAsXG4gICAgZ2FtbWE6IDAsXG4gICAgZ2FtbWFPdXQ6IDAsXG4gICAgZ3JleXNjYWxlOiBmYWxzZSxcbiAgICBub3JtYWxpc2U6IGZhbHNlLFxuICAgIG5vcm1hbGlzZUxvd2VyOiAxLFxuICAgIG5vcm1hbGlzZVVwcGVyOiA5OSxcbiAgICBjbGFoZVdpZHRoOiAwLFxuICAgIGNsYWhlSGVpZ2h0OiAwLFxuICAgIGNsYWhlTWF4U2xvcGU6IDMsXG4gICAgYnJpZ2h0bmVzczogMSxcbiAgICBzYXR1cmF0aW9uOiAxLFxuICAgIGh1ZTogMCxcbiAgICBsaWdodG5lc3M6IDAsXG4gICAgYm9vbGVhbkJ1ZmZlckluOiBudWxsLFxuICAgIGJvb2xlYW5GaWxlSW46ICcnLFxuICAgIGpvaW5DaGFubmVsSW46IFtdLFxuICAgIGV4dHJhY3RDaGFubmVsOiAtMSxcbiAgICByZW1vdmVBbHBoYTogZmFsc2UsXG4gICAgZW5zdXJlQWxwaGE6IC0xLFxuICAgIGNvbG91cnNwYWNlOiAnc3JnYicsXG4gICAgY29sb3Vyc3BhY2VQaXBlbGluZTogJ2xhc3QnLFxuICAgIGNvbXBvc2l0ZTogW10sXG4gICAgLy8gb3V0cHV0XG4gICAgZmlsZU91dDogJycsXG4gICAgZm9ybWF0T3V0OiAnaW5wdXQnLFxuICAgIHN0cmVhbU91dDogZmFsc2UsXG4gICAga2VlcE1ldGFkYXRhOiAwLFxuICAgIHdpdGhNZXRhZGF0YU9yaWVudGF0aW9uOiAtMSxcbiAgICB3aXRoTWV0YWRhdGFEZW5zaXR5OiAwLFxuICAgIHdpdGhJY2NQcm9maWxlOiAnJyxcbiAgICB3aXRoRXhpZjoge30sXG4gICAgd2l0aEV4aWZNZXJnZTogdHJ1ZSxcbiAgICB3aXRoWG1wOiAnJyxcbiAgICByZXNvbHZlV2l0aE9iamVjdDogZmFsc2UsXG4gICAgbG9vcDogLTEsXG4gICAgZGVsYXk6IFtdLFxuICAgIC8vIG91dHB1dCBmb3JtYXRcbiAgICBqcGVnUXVhbGl0eTogODAsXG4gICAganBlZ1Byb2dyZXNzaXZlOiBmYWxzZSxcbiAgICBqcGVnQ2hyb21hU3Vic2FtcGxpbmc6ICc0OjI6MCcsXG4gICAganBlZ1RyZWxsaXNRdWFudGlzYXRpb246IGZhbHNlLFxuICAgIGpwZWdPdmVyc2hvb3REZXJpbmdpbmc6IGZhbHNlLFxuICAgIGpwZWdPcHRpbWlzZVNjYW5zOiBmYWxzZSxcbiAgICBqcGVnT3B0aW1pc2VDb2Rpbmc6IHRydWUsXG4gICAganBlZ1F1YW50aXNhdGlvblRhYmxlOiAwLFxuICAgIHBuZ1Byb2dyZXNzaXZlOiBmYWxzZSxcbiAgICBwbmdDb21wcmVzc2lvbkxldmVsOiA2LFxuICAgIHBuZ0FkYXB0aXZlRmlsdGVyaW5nOiBmYWxzZSxcbiAgICBwbmdQYWxldHRlOiBmYWxzZSxcbiAgICBwbmdRdWFsaXR5OiAxMDAsXG4gICAgcG5nRWZmb3J0OiA3LFxuICAgIHBuZ0JpdGRlcHRoOiA4LFxuICAgIHBuZ0RpdGhlcjogMSxcbiAgICBqcDJRdWFsaXR5OiA4MCxcbiAgICBqcDJUaWxlSGVpZ2h0OiA1MTIsXG4gICAganAyVGlsZVdpZHRoOiA1MTIsXG4gICAganAyTG9zc2xlc3M6IGZhbHNlLFxuICAgIGpwMkNocm9tYVN1YnNhbXBsaW5nOiAnNDo0OjQnLFxuICAgIHdlYnBRdWFsaXR5OiA4MCxcbiAgICB3ZWJwQWxwaGFRdWFsaXR5OiAxMDAsXG4gICAgd2VicExvc3NsZXNzOiBmYWxzZSxcbiAgICB3ZWJwTmVhckxvc3NsZXNzOiBmYWxzZSxcbiAgICB3ZWJwU21hcnRTdWJzYW1wbGU6IGZhbHNlLFxuICAgIHdlYnBTbWFydERlYmxvY2s6IGZhbHNlLFxuICAgIHdlYnBQcmVzZXQ6ICdkZWZhdWx0JyxcbiAgICB3ZWJwRWZmb3J0OiA0LFxuICAgIHdlYnBNaW5TaXplOiBmYWxzZSxcbiAgICB3ZWJwTWl4ZWQ6IGZhbHNlLFxuICAgIGdpZkJpdGRlcHRoOiA4LFxuICAgIGdpZkVmZm9ydDogNyxcbiAgICBnaWZEaXRoZXI6IDEsXG4gICAgZ2lmSW50ZXJGcmFtZU1heEVycm9yOiAwLFxuICAgIGdpZkludGVyUGFsZXR0ZU1heEVycm9yOiAzLFxuICAgIGdpZktlZXBEdXBsaWNhdGVGcmFtZXM6IGZhbHNlLFxuICAgIGdpZlJldXNlOiB0cnVlLFxuICAgIGdpZlByb2dyZXNzaXZlOiBmYWxzZSxcbiAgICB0aWZmUXVhbGl0eTogODAsXG4gICAgdGlmZkNvbXByZXNzaW9uOiAnanBlZycsXG4gICAgdGlmZlByZWRpY3RvcjogJ2hvcml6b250YWwnLFxuICAgIHRpZmZQeXJhbWlkOiBmYWxzZSxcbiAgICB0aWZmTWluaXN3aGl0ZTogZmFsc2UsXG4gICAgdGlmZkJpdGRlcHRoOiA4LFxuICAgIHRpZmZUaWxlOiBmYWxzZSxcbiAgICB0aWZmVGlsZUhlaWdodDogMjU2LFxuICAgIHRpZmZUaWxlV2lkdGg6IDI1NixcbiAgICB0aWZmWHJlczogMS4wLFxuICAgIHRpZmZZcmVzOiAxLjAsXG4gICAgdGlmZlJlc29sdXRpb25Vbml0OiAnaW5jaCcsXG4gICAgaGVpZlF1YWxpdHk6IDUwLFxuICAgIGhlaWZMb3NzbGVzczogZmFsc2UsXG4gICAgaGVpZkNvbXByZXNzaW9uOiAnYXYxJyxcbiAgICBoZWlmRWZmb3J0OiA0LFxuICAgIGhlaWZDaHJvbWFTdWJzYW1wbGluZzogJzQ6NDo0JyxcbiAgICBoZWlmQml0ZGVwdGg6IDgsXG4gICAganhsRGlzdGFuY2U6IDEsXG4gICAganhsRGVjb2RpbmdUaWVyOiAwLFxuICAgIGp4bEVmZm9ydDogNyxcbiAgICBqeGxMb3NzbGVzczogZmFsc2UsXG4gICAgcmF3RGVwdGg6ICd1Y2hhcicsXG4gICAgdGlsZVNpemU6IDI1NixcbiAgICB0aWxlT3ZlcmxhcDogMCxcbiAgICB0aWxlQ29udGFpbmVyOiAnZnMnLFxuICAgIHRpbGVMYXlvdXQ6ICdkeicsXG4gICAgdGlsZUZvcm1hdDogJ2xhc3QnLFxuICAgIHRpbGVEZXB0aDogJ2xhc3QnLFxuICAgIHRpbGVBbmdsZTogMCxcbiAgICB0aWxlU2tpcEJsYW5rczogLTEsXG4gICAgdGlsZUJhY2tncm91bmQ6IFsyNTUsIDI1NSwgMjU1LCAyNTVdLFxuICAgIHRpbGVDZW50cmU6IGZhbHNlLFxuICAgIHRpbGVJZDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vaWlpZicsXG4gICAgdGlsZUJhc2VuYW1lOiAnJyxcbiAgICB0aW1lb3V0U2Vjb25kczogMCxcbiAgICBsaW5lYXJBOiBbXSxcbiAgICBsaW5lYXJCOiBbXSxcbiAgICBwZGZCYWNrZ3JvdW5kOiBbMjU1LCAyNTUsIDI1NSwgMjU1XSxcbiAgICAvLyBGdW5jdGlvbiB0byBub3RpZnkgb2YgbGlidmlwcyB3YXJuaW5nc1xuICAgIGRlYnVnbG9nOiB3YXJuaW5nID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnd2FybmluZycsIHdhcm5pbmcpO1xuICAgICAgZGVidWdsb2cod2FybmluZyk7XG4gICAgfSxcbiAgICAvLyBGdW5jdGlvbiB0byBub3RpZnkgb2YgcXVldWUgbGVuZ3RoIGNoYW5nZXNcbiAgICBxdWV1ZUxpc3RlbmVyOiBmdW5jdGlvbiAocXVldWVMZW5ndGgpIHtcbiAgICAgIFNoYXJwLnF1ZXVlLmVtaXQoJ2NoYW5nZScsIHF1ZXVlTGVuZ3RoKTtcbiAgICB9XG4gIH07XG4gIHRoaXMub3B0aW9ucy5pbnB1dCA9IHRoaXMuX2NyZWF0ZUlucHV0RGVzY3JpcHRvcihpbnB1dCwgb3B0aW9ucywgeyBhbGxvd1N0cmVhbTogdHJ1ZSB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNoYXJwLnByb3RvdHlwZSwgc3RyZWFtLkR1cGxleC5wcm90b3R5cGUpO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNoYXJwLCBzdHJlYW0uRHVwbGV4KTtcblxuLyoqXG4gKiBUYWtlIGEgXCJzbmFwc2hvdFwiIG9mIHRoZSBTaGFycCBpbnN0YW5jZSwgcmV0dXJuaW5nIGEgbmV3IGluc3RhbmNlLlxuICogQ2xvbmVkIGluc3RhbmNlcyBpbmhlcml0IHRoZSBpbnB1dCBvZiB0aGVpciBwYXJlbnQgaW5zdGFuY2UuXG4gKiBUaGlzIGFsbG93cyBtdWx0aXBsZSBvdXRwdXQgU3RyZWFtcyBhbmQgdGhlcmVmb3JlIG11bHRpcGxlIHByb2Nlc3NpbmcgcGlwZWxpbmVzIHRvIHNoYXJlIGEgc2luZ2xlIGlucHV0IFN0cmVhbS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcGlwZWxpbmUgPSBzaGFycCgpLnJvdGF0ZSgpO1xuICogcGlwZWxpbmUuY2xvbmUoKS5yZXNpemUoODAwLCA2MDApLnBpcGUoZmlyc3RXcml0YWJsZVN0cmVhbSk7XG4gKiBwaXBlbGluZS5jbG9uZSgpLmV4dHJhY3QoeyBsZWZ0OiAyMCwgdG9wOiAyMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfSkucGlwZShzZWNvbmRXcml0YWJsZVN0cmVhbSk7XG4gKiByZWFkYWJsZVN0cmVhbS5waXBlKHBpcGVsaW5lKTtcbiAqIC8vIGZpcnN0V3JpdGFibGVTdHJlYW0gcmVjZWl2ZXMgYXV0by1yb3RhdGVkLCByZXNpemVkIHJlYWRhYmxlU3RyZWFtXG4gKiAvLyBzZWNvbmRXcml0YWJsZVN0cmVhbSByZWNlaXZlcyBhdXRvLXJvdGF0ZWQsIGV4dHJhY3RlZCByZWdpb24gb2YgcmVhZGFibGVTdHJlYW1cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgcGlwZWxpbmUgdGhhdCB3aWxsIGRvd25sb2FkIGFuIGltYWdlLCByZXNpemUgaXQgYW5kIGZvcm1hdCBpdCB0byBkaWZmZXJlbnQgZmlsZXNcbiAqIC8vIFVzaW5nIFByb21pc2VzIHRvIGtub3cgd2hlbiB0aGUgcGlwZWxpbmUgaXMgY29tcGxldGVcbiAqIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICogY29uc3QgZ290ID0gcmVxdWlyZShcImdvdFwiKTtcbiAqIGNvbnN0IHNoYXJwU3RyZWFtID0gc2hhcnAoeyBmYWlsT246ICdub25lJyB9KTtcbiAqXG4gKiBjb25zdCBwcm9taXNlcyA9IFtdO1xuICpcbiAqIHByb21pc2VzLnB1c2goXG4gKiAgIHNoYXJwU3RyZWFtXG4gKiAgICAgLmNsb25lKClcbiAqICAgICAuanBlZyh7IHF1YWxpdHk6IDEwMCB9KVxuICogICAgIC50b0ZpbGUoXCJvcmlnaW5hbEZpbGUuanBnXCIpXG4gKiApO1xuICpcbiAqIHByb21pc2VzLnB1c2goXG4gKiAgIHNoYXJwU3RyZWFtXG4gKiAgICAgLmNsb25lKClcbiAqICAgICAucmVzaXplKHsgd2lkdGg6IDUwMCB9KVxuICogICAgIC5qcGVnKHsgcXVhbGl0eTogODAgfSlcbiAqICAgICAudG9GaWxlKFwib3B0aW1pemVkLTUwMC5qcGdcIilcbiAqICk7XG4gKlxuICogcHJvbWlzZXMucHVzaChcbiAqICAgc2hhcnBTdHJlYW1cbiAqICAgICAuY2xvbmUoKVxuICogICAgIC5yZXNpemUoeyB3aWR0aDogNTAwIH0pXG4gKiAgICAgLndlYnAoeyBxdWFsaXR5OiA4MCB9KVxuICogICAgIC50b0ZpbGUoXCJvcHRpbWl6ZWQtNTAwLndlYnBcIilcbiAqICk7XG4gKlxuICogLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nb3QvYmxvYi9tYWluL2RvY3VtZW50YXRpb24vMy1zdHJlYW1zLm1kXG4gKiBnb3Quc3RyZWFtKFwiaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vc29tZS1maWxlLmpwZ1wiKS5waXBlKHNoYXJwU3RyZWFtKTtcbiAqXG4gKiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAqICAgLnRoZW4ocmVzID0+IHsgY29uc29sZS5sb2coXCJEb25lIVwiLCByZXMpOyB9KVxuICogICAuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyBmaWxlcywgbGV0J3MgY2xlYW4gaXQgdXBcIiwgZXJyKTtcbiAqICAgICB0cnkge1xuICogICAgICAgZnMudW5saW5rU3luYyhcIm9yaWdpbmFsRmlsZS5qcGdcIik7XG4gKiAgICAgICBmcy51bmxpbmtTeW5jKFwib3B0aW1pemVkLTUwMC5qcGdcIik7XG4gKiAgICAgICBmcy51bmxpbmtTeW5jKFwib3B0aW1pemVkLTUwMC53ZWJwXCIpO1xuICogICAgIH0gY2F0Y2ggKGUpIHt9XG4gKiAgIH0pO1xuICpcbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqL1xuZnVuY3Rpb24gY2xvbmUgKCkge1xuICAvLyBDbG9uZSBleGlzdGluZyBvcHRpb25zXG4gIGNvbnN0IGNsb25lID0gdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKCk7XG4gIGNvbnN0IHsgZGVidWdsb2csIHF1ZXVlTGlzdGVuZXIsIC4uLm9wdGlvbnMgfSA9IHRoaXMub3B0aW9ucztcbiAgY2xvbmUub3B0aW9ucyA9IHN0cnVjdHVyZWRDbG9uZShvcHRpb25zKTtcbiAgY2xvbmUub3B0aW9ucy5kZWJ1Z2xvZyA9IGRlYnVnbG9nO1xuICBjbG9uZS5vcHRpb25zLnF1ZXVlTGlzdGVuZXIgPSBxdWV1ZUxpc3RlbmVyO1xuICAvLyBQYXNzICdmaW5pc2gnIGV2ZW50IHRvIGNsb25lIGZvciBTdHJlYW0tYmFzZWQgaW5wdXRcbiAgaWYgKHRoaXMuX2lzU3RyZWFtSW5wdXQoKSkge1xuICAgIHRoaXMub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIC8vIENsb25lIGluaGVyaXRzIGlucHV0IGRhdGFcbiAgICAgIHRoaXMuX2ZsYXR0ZW5CdWZmZXJJbigpO1xuICAgICAgY2xvbmUub3B0aW9ucy5pbnB1dC5idWZmZXIgPSB0aGlzLm9wdGlvbnMuaW5wdXQuYnVmZmVyO1xuICAgICAgY2xvbmUuZW1pdCgnZmluaXNoJyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuT2JqZWN0LmFzc2lnbihTaGFycC5wcm90b3R5cGUsIHsgY2xvbmUgfSk7XG5cbi8qKlxuICogRXhwb3J0IGNvbnN0cnVjdG9yLlxuICogQG1vZHVsZSBTaGFycFxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBTaGFycDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/constructor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst Sharp = __webpack_require__(/*! ./constructor */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/constructor.js\");\n__webpack_require__(/*! ./input */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/input.js\")(Sharp);\n__webpack_require__(/*! ./resize */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/resize.js\")(Sharp);\n__webpack_require__(/*! ./composite */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/composite.js\")(Sharp);\n__webpack_require__(/*! ./operation */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/operation.js\")(Sharp);\n__webpack_require__(/*! ./colour */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/colour.js\")(Sharp);\n__webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/channel.js\")(Sharp);\n__webpack_require__(/*! ./output */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/output.js\")(Sharp);\n__webpack_require__(/*! ./utility */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/utility.js\")(Sharp);\n\nmodule.exports = Sharp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0dBQWU7QUFDckMsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQixtQkFBTyxDQUFDLDBGQUFVO0FBQ2xCLG1CQUFPLENBQUMsZ0dBQWE7QUFDckIsbUJBQU8sQ0FBQyxnR0FBYTtBQUNyQixtQkFBTyxDQUFDLDBGQUFVO0FBQ2xCLG1CQUFPLENBQUMsNEZBQVc7QUFDbkIsbUJBQU8sQ0FBQywwRkFBVTtBQUNsQixtQkFBTyxDQUFDLDRGQUFXOztBQUVuQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoYXJwQDAuMzQuNC9ub2RlX21vZHVsZXMvc2hhcnAvbGliL2luZGV4LmpzPzUzMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMgTG92ZWxsIEZ1bGxlciBhbmQgb3RoZXJzLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTaGFycCA9IHJlcXVpcmUoJy4vY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vaW5wdXQnKShTaGFycCk7XG5yZXF1aXJlKCcuL3Jlc2l6ZScpKFNoYXJwKTtcbnJlcXVpcmUoJy4vY29tcG9zaXRlJykoU2hhcnApO1xucmVxdWlyZSgnLi9vcGVyYXRpb24nKShTaGFycCk7XG5yZXF1aXJlKCcuL2NvbG91cicpKFNoYXJwKTtcbnJlcXVpcmUoJy4vY2hhbm5lbCcpKFNoYXJwKTtcbnJlcXVpcmUoJy4vb3V0cHV0JykoU2hhcnApO1xucmVxdWlyZSgnLi91dGlsaXR5JykoU2hhcnApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXJwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/input.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/input.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\nconst sharp = __webpack_require__(/*! ./sharp */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js\");\n\n/**\n * Justification alignment\n * @member\n * @private\n */\nconst align = {\n  left: 'low',\n  top: 'low',\n  low: 'low',\n  center: 'centre',\n  centre: 'centre',\n  right: 'high',\n  bottom: 'high',\n  high: 'high'\n};\n\nconst inputStreamParameters = [\n  // Limits and error handling\n  'failOn', 'limitInputPixels', 'unlimited',\n  // Format-generic\n  'animated', 'autoOrient', 'density', 'ignoreIcc', 'page', 'pages', 'sequentialRead',\n  // Format-specific\n  'jp2', 'openSlide', 'pdf', 'raw', 'svg', 'tiff',\n  // Deprecated\n  'failOnError', 'openSlideLevel', 'pdfBackground', 'tiffSubifd'\n];\n\n/**\n * Extract input options, if any, from an object.\n * @private\n */\nfunction _inputOptionsFromObject (obj) {\n  const params = inputStreamParameters\n    .filter(p => is.defined(obj[p]))\n    .map(p => ([p, obj[p]]));\n  return params.length\n    ? Object.fromEntries(params)\n    : undefined;\n}\n\n/**\n * Create Object containing input and input-related options.\n * @private\n */\nfunction _createInputDescriptor (input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    autoOrient: false,\n    failOn: 'warning',\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    ignoreIcc: false,\n    unlimited: false,\n    sequentialRead: true\n  };\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    if (input.length === 0) {\n      throw Error('Input Buffer is empty');\n    }\n    inputDescriptor.buffer = input;\n  } else if (is.arrayBuffer(input)) {\n    if (input.byteLength === 0) {\n      throw Error('Input bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);\n  } else if (is.typedArray(input)) {\n    if (input.length === 0) {\n      throw Error('Input Bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n    if (_inputOptionsFromObject(inputOptions)) {\n      // Stream with options\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream without options\n    inputDescriptor.buffer = [];\n  } else if (Array.isArray(input)) {\n    if (input.length > 1) {\n      // Join images together\n      if (!this.options.joining) {\n        this.options.joining = true;\n        this.options.join = input.map(i => this._createInputDescriptor(i));\n      } else {\n        throw new Error('Recursive join is unsupported');\n      }\n    } else {\n      throw new Error('Expected at least two images to join');\n    }\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${\n      is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''\n    }`);\n  }\n  if (is.object(inputOptions)) {\n    // Deprecated: failOnError\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOn = inputOptions.failOnError ? 'warning' : 'none';\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    }\n    // failOn\n    if (is.defined(inputOptions.failOn)) {\n      if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ['none', 'truncated', 'error', 'warning'])) {\n        inputDescriptor.failOn = inputOptions.failOn;\n      } else {\n        throw is.invalidParameterError('failOn', 'one of: none, truncated, error, warning', inputOptions.failOn);\n      }\n    }\n    // autoOrient\n    if (is.defined(inputOptions.autoOrient)) {\n      if (is.bool(inputOptions.autoOrient)) {\n        inputDescriptor.autoOrient = inputOptions.autoOrient;\n      } else {\n        throw is.invalidParameterError('autoOrient', 'boolean', inputOptions.autoOrient);\n      }\n    }\n    // Density\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 100000)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 100000', inputOptions.density);\n      }\n    }\n    // Ignore embeddded ICC profile\n    if (is.defined(inputOptions.ignoreIcc)) {\n      if (is.bool(inputOptions.ignoreIcc)) {\n        inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;\n      } else {\n        throw is.invalidParameterError('ignoreIcc', 'boolean', inputOptions.ignoreIcc);\n      }\n    }\n    // limitInputPixels\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels\n          ? Math.pow(0x3FFF, 2)\n          : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'positive integer', inputOptions.limitInputPixels);\n      }\n    }\n    // unlimited\n    if (is.defined(inputOptions.unlimited)) {\n      if (is.bool(inputOptions.unlimited)) {\n        inputDescriptor.unlimited = inputOptions.unlimited;\n      } else {\n        throw is.invalidParameterError('unlimited', 'boolean', inputOptions.unlimited);\n      }\n    }\n    // sequentialRead\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    }\n    // Raw pixel input\n    if (is.defined(inputOptions.raw)) {\n      if (\n        is.object(inputOptions.raw) &&\n        is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 &&\n        is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 &&\n        is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)\n      ) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n        switch (input.constructor) {\n          case Uint8Array:\n          case Uint8ClampedArray:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n          case Int8Array:\n            inputDescriptor.rawDepth = 'char';\n            break;\n          case Uint16Array:\n            inputDescriptor.rawDepth = 'ushort';\n            break;\n          case Int16Array:\n            inputDescriptor.rawDepth = 'short';\n            break;\n          case Uint32Array:\n            inputDescriptor.rawDepth = 'uint';\n            break;\n          case Int32Array:\n            inputDescriptor.rawDepth = 'int';\n            break;\n          case Float32Array:\n            inputDescriptor.rawDepth = 'float';\n            break;\n          case Float64Array:\n            inputDescriptor.rawDepth = 'double';\n            break;\n          default:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n        }\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n      inputDescriptor.rawPremultiplied = false;\n      if (is.defined(inputOptions.raw.premultiplied)) {\n        if (is.bool(inputOptions.raw.premultiplied)) {\n          inputDescriptor.rawPremultiplied = inputOptions.raw.premultiplied;\n        } else {\n          throw is.invalidParameterError('raw.premultiplied', 'boolean', inputOptions.raw.premultiplied);\n        }\n      }\n      inputDescriptor.rawPageHeight = 0;\n      if (is.defined(inputOptions.raw.pageHeight)) {\n        if (is.integer(inputOptions.raw.pageHeight) && inputOptions.raw.pageHeight > 0 && inputOptions.raw.pageHeight <= inputOptions.raw.height) {\n          if (inputOptions.raw.height % inputOptions.raw.pageHeight !== 0) {\n            throw new Error(`Expected raw.height ${inputOptions.raw.height} to be a multiple of raw.pageHeight ${inputOptions.raw.pageHeight}`);\n          }\n          inputDescriptor.rawPageHeight = inputOptions.raw.pageHeight;\n        } else {\n          throw is.invalidParameterError('raw.pageHeight', 'positive integer', inputOptions.raw.pageHeight);\n        }\n      }\n    }\n    // Multi-page input (GIF, TIFF, PDF)\n    if (is.defined(inputOptions.animated)) {\n      if (is.bool(inputOptions.animated)) {\n        inputDescriptor.pages = inputOptions.animated ? -1 : 1;\n      } else {\n        throw is.invalidParameterError('animated', 'boolean', inputOptions.animated);\n      }\n    }\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    }\n    // OpenSlide specific options\n    if (is.object(inputOptions.openSlide) && is.defined(inputOptions.openSlide.level)) {\n      if (is.integer(inputOptions.openSlide.level) && is.inRange(inputOptions.openSlide.level, 0, 256)) {\n        inputDescriptor.openSlideLevel = inputOptions.openSlide.level;\n      } else {\n        throw is.invalidParameterError('openSlide.level', 'integer between 0 and 256', inputOptions.openSlide.level);\n      }\n    } else if (is.defined(inputOptions.level)) {\n      // Deprecated\n      if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {\n        inputDescriptor.openSlideLevel = inputOptions.level;\n      } else {\n        throw is.invalidParameterError('level', 'integer between 0 and 256', inputOptions.level);\n      }\n    }\n    // TIFF specific options\n    if (is.object(inputOptions.tiff) && is.defined(inputOptions.tiff.subifd)) {\n      if (is.integer(inputOptions.tiff.subifd) && is.inRange(inputOptions.tiff.subifd, -1, 100000)) {\n        inputDescriptor.tiffSubifd = inputOptions.tiff.subifd;\n      } else {\n        throw is.invalidParameterError('tiff.subifd', 'integer between -1 and 100000', inputOptions.tiff.subifd);\n      }\n    } else if (is.defined(inputOptions.subifd)) {\n      // Deprecated\n      if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 100000)) {\n        inputDescriptor.tiffSubifd = inputOptions.subifd;\n      } else {\n        throw is.invalidParameterError('subifd', 'integer between -1 and 100000', inputOptions.subifd);\n      }\n    }\n    // SVG specific options\n    if (is.object(inputOptions.svg)) {\n      if (is.defined(inputOptions.svg.stylesheet)) {\n        if (is.string(inputOptions.svg.stylesheet)) {\n          inputDescriptor.svgStylesheet = inputOptions.svg.stylesheet;\n        } else {\n          throw is.invalidParameterError('svg.stylesheet', 'string', inputOptions.svg.stylesheet);\n        }\n      }\n      if (is.defined(inputOptions.svg.highBitdepth)) {\n        if (is.bool(inputOptions.svg.highBitdepth)) {\n          inputDescriptor.svgHighBitdepth = inputOptions.svg.highBitdepth;\n        } else {\n          throw is.invalidParameterError('svg.highBitdepth', 'boolean', inputOptions.svg.highBitdepth);\n        }\n      }\n    }\n    // PDF specific options\n    if (is.object(inputOptions.pdf) && is.defined(inputOptions.pdf.background)) {\n      inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdf.background);\n    } else if (is.defined(inputOptions.pdfBackground)) {\n      // Deprecated\n      inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdfBackground);\n    }\n    // JPEG 2000 specific options\n    if (is.object(inputOptions.jp2) && is.defined(inputOptions.jp2.oneshot)) {\n      if (is.bool(inputOptions.jp2.oneshot)) {\n        inputDescriptor.jp2Oneshot = inputOptions.jp2.oneshot;\n      } else {\n        throw is.invalidParameterError('jp2.oneshot', 'boolean', inputOptions.jp2.oneshot);\n      }\n    }\n    // Create new image\n    if (is.defined(inputOptions.create)) {\n      if (\n        is.object(inputOptions.create) &&\n        is.integer(inputOptions.create.width) && inputOptions.create.width > 0 &&\n        is.integer(inputOptions.create.height) && inputOptions.create.height > 0 &&\n        is.integer(inputOptions.create.channels)\n      ) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        inputDescriptor.createPageHeight = 0;\n        if (is.defined(inputOptions.create.pageHeight)) {\n          if (is.integer(inputOptions.create.pageHeight) && inputOptions.create.pageHeight > 0 && inputOptions.create.pageHeight <= inputOptions.create.height) {\n            if (inputOptions.create.height % inputOptions.create.pageHeight !== 0) {\n              throw new Error(`Expected create.height ${inputOptions.create.height} to be a multiple of create.pageHeight ${inputOptions.create.pageHeight}`);\n            }\n            inputDescriptor.createPageHeight = inputOptions.create.pageHeight;\n          } else {\n            throw is.invalidParameterError('create.pageHeight', 'positive integer', inputOptions.create.pageHeight);\n          }\n        }\n        // Noise\n        if (is.defined(inputOptions.create.noise)) {\n          if (!is.object(inputOptions.create.noise)) {\n            throw new Error('Expected noise to be an object');\n          }\n          if (inputOptions.create.noise.type !== 'gaussian') {\n            throw new Error('Only gaussian noise is supported at the moment');\n          }\n          inputDescriptor.createNoiseType = inputOptions.create.noise.type;\n          if (!is.inRange(inputOptions.create.channels, 1, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 1 and 4', inputOptions.create.channels);\n          }\n          inputDescriptor.createNoiseMean = 128;\n          if (is.defined(inputOptions.create.noise.mean)) {\n            if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n              inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;\n            } else {\n              throw is.invalidParameterError('create.noise.mean', 'number between 0 and 10000', inputOptions.create.noise.mean);\n            }\n          }\n          inputDescriptor.createNoiseSigma = 30;\n          if (is.defined(inputOptions.create.noise.sigma)) {\n            if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n              inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;\n            } else {\n              throw is.invalidParameterError('create.noise.sigma', 'number between 0 and 10000', inputOptions.create.noise.sigma);\n            }\n          }\n        } else if (is.defined(inputOptions.create.background)) {\n          if (!is.inRange(inputOptions.create.channels, 3, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 3 and 4', inputOptions.create.channels);\n          }\n          inputDescriptor.createBackground = this._getBackgroundColourOption(inputOptions.create.background);\n        } else {\n          throw new Error('Expected valid noise or background to create a new input image');\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected valid width, height and channels to create a new input image');\n      }\n    }\n    // Create a new image with text\n    if (is.defined(inputOptions.text)) {\n      if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {\n        inputDescriptor.textValue = inputOptions.text.text;\n        if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {\n          throw new Error('Expected only one of dpi or height');\n        }\n        if (is.defined(inputOptions.text.font)) {\n          if (is.string(inputOptions.text.font)) {\n            inputDescriptor.textFont = inputOptions.text.font;\n          } else {\n            throw is.invalidParameterError('text.font', 'string', inputOptions.text.font);\n          }\n        }\n        if (is.defined(inputOptions.text.fontfile)) {\n          if (is.string(inputOptions.text.fontfile)) {\n            inputDescriptor.textFontfile = inputOptions.text.fontfile;\n          } else {\n            throw is.invalidParameterError('text.fontfile', 'string', inputOptions.text.fontfile);\n          }\n        }\n        if (is.defined(inputOptions.text.width)) {\n          if (is.integer(inputOptions.text.width) && inputOptions.text.width > 0) {\n            inputDescriptor.textWidth = inputOptions.text.width;\n          } else {\n            throw is.invalidParameterError('text.width', 'positive integer', inputOptions.text.width);\n          }\n        }\n        if (is.defined(inputOptions.text.height)) {\n          if (is.integer(inputOptions.text.height) && inputOptions.text.height > 0) {\n            inputDescriptor.textHeight = inputOptions.text.height;\n          } else {\n            throw is.invalidParameterError('text.height', 'positive integer', inputOptions.text.height);\n          }\n        }\n        if (is.defined(inputOptions.text.align)) {\n          if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {\n            inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];\n          } else {\n            throw is.invalidParameterError('text.align', 'valid alignment', inputOptions.text.align);\n          }\n        }\n        if (is.defined(inputOptions.text.justify)) {\n          if (is.bool(inputOptions.text.justify)) {\n            inputDescriptor.textJustify = inputOptions.text.justify;\n          } else {\n            throw is.invalidParameterError('text.justify', 'boolean', inputOptions.text.justify);\n          }\n        }\n        if (is.defined(inputOptions.text.dpi)) {\n          if (is.integer(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 1000000)) {\n            inputDescriptor.textDpi = inputOptions.text.dpi;\n          } else {\n            throw is.invalidParameterError('text.dpi', 'integer between 1 and 1000000', inputOptions.text.dpi);\n          }\n        }\n        if (is.defined(inputOptions.text.rgba)) {\n          if (is.bool(inputOptions.text.rgba)) {\n            inputDescriptor.textRgba = inputOptions.text.rgba;\n          } else {\n            throw is.invalidParameterError('text.rgba', 'bool', inputOptions.text.rgba);\n          }\n        }\n        if (is.defined(inputOptions.text.spacing)) {\n          if (is.integer(inputOptions.text.spacing) && is.inRange(inputOptions.text.spacing, -1000000, 1000000)) {\n            inputDescriptor.textSpacing = inputOptions.text.spacing;\n          } else {\n            throw is.invalidParameterError('text.spacing', 'integer between -1000000 and 1000000', inputOptions.text.spacing);\n          }\n        }\n        if (is.defined(inputOptions.text.wrap)) {\n          if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ['word', 'char', 'word-char', 'none'])) {\n            inputDescriptor.textWrap = inputOptions.text.wrap;\n          } else {\n            throw is.invalidParameterError('text.wrap', 'one of: word, char, word-char, none', inputOptions.text.wrap);\n          }\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected a valid string to create an image with text.');\n      }\n    }\n    // Join images together\n    if (is.defined(inputOptions.join)) {\n      if (is.defined(this.options.join)) {\n        if (is.defined(inputOptions.join.animated)) {\n          if (is.bool(inputOptions.join.animated)) {\n            inputDescriptor.joinAnimated = inputOptions.join.animated;\n          } else {\n            throw is.invalidParameterError('join.animated', 'boolean', inputOptions.join.animated);\n          }\n        }\n        if (is.defined(inputOptions.join.across)) {\n          if (is.integer(inputOptions.join.across) && is.inRange(inputOptions.join.across, 1, 1000000)) {\n            inputDescriptor.joinAcross = inputOptions.join.across;\n          } else {\n            throw is.invalidParameterError('join.across', 'integer between 1 and 100000', inputOptions.join.across);\n          }\n        }\n        if (is.defined(inputOptions.join.shim)) {\n          if (is.integer(inputOptions.join.shim) && is.inRange(inputOptions.join.shim, 0, 1000000)) {\n            inputDescriptor.joinShim = inputOptions.join.shim;\n          } else {\n            throw is.invalidParameterError('join.shim', 'integer between 0 and 100000', inputOptions.join.shim);\n          }\n        }\n        if (is.defined(inputOptions.join.background)) {\n          inputDescriptor.joinBackground = this._getBackgroundColourOption(inputOptions.join.background);\n        }\n        if (is.defined(inputOptions.join.halign)) {\n          if (is.string(inputOptions.join.halign) && is.string(this.constructor.align[inputOptions.join.halign])) {\n            inputDescriptor.joinHalign = this.constructor.align[inputOptions.join.halign];\n          } else {\n            throw is.invalidParameterError('join.halign', 'valid alignment', inputOptions.join.halign);\n          }\n        }\n        if (is.defined(inputOptions.join.valign)) {\n          if (is.string(inputOptions.join.valign) && is.string(this.constructor.align[inputOptions.join.valign])) {\n            inputDescriptor.joinValign = this.constructor.align[inputOptions.join.valign];\n          } else {\n            throw is.invalidParameterError('join.valign', 'valid alignment', inputOptions.join.valign);\n          }\n        }\n      } else {\n        throw new Error('Expected input to be an array of images to join');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n  return inputDescriptor;\n}\n\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {string} encoding - unused\n * @param {Function} callback\n */\nfunction _write (chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\nfunction _flattenBufferIn () {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {boolean}\n */\nfunction _isStreamInput () {\n  return Array.isArray(this.options.input.buffer);\n}\n\n/**\n * Fast access to (uncached) image metadata without decoding any compressed pixel data.\n *\n * This is read from the header of the input image.\n * It does not take into consideration any operations to be applied to the output image,\n * such as resize or rotate.\n *\n * Dimensions in the response will respect the `page` and `pages` properties of the\n * {@link /api-constructor#parameters|constructor parameters}.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration, see example below)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration, see example below)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://www.libvips.org/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `isPalette`: Boolean indicating whether the image is palette-based (GIF, PNG).\n * - `bitsPerSample`: Number of bits per sample for each channel (GIF, PNG, HEIF).\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `levels`: Details of each level in a multi-level image provided as an array of objects, requires libvips compiled with support for OpenSlide\n * - `subifds`: Number of Sub Image File Directories in an OME-TIFF image\n * - `background`: Default background colour, if present, for PNG (bKGD) and GIF images\n * - `compression`: The encoder used to compress an HEIF file, `av1` (AVIF) or `hevc` (HEIC)\n * - `resolutionUnit`: The unit of resolution (density), either `inch` or `cm`, if present\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `xmpAsString`: String containing XMP data, if valid UTF-8.\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n * - `formatMagick`: String containing format for images loaded via *magick\n * - `comments`: Array of keyword/text pairs representing PNG text blocks, if present.\n *\n * @example\n * const metadata = await sharp(input).metadata();\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @example\n * // Get dimensions taking EXIF Orientation into account.\n * const { autoOrient } = await sharp(input).metadata();\n * const { width, height } = autoOrient;\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\nfunction metadata (callback) {\n  const stack = Error();\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            callback(is.nativeError(err, stack));\n          } else {\n            callback(null, metadata);\n          }\n        });\n      });\n    } else {\n      sharp.metadata(this.options, (err, metadata) => {\n        if (err) {\n          callback(is.nativeError(err, stack));\n        } else {\n          callback(null, metadata);\n        }\n      });\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        const finished = () => {\n          this._flattenBufferIn();\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(is.nativeError(err, stack));\n            } else {\n              resolve(metadata);\n            }\n          });\n        };\n        if (this.writableFinished) {\n          finished();\n        } else {\n          this.once('finish', finished);\n        }\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(is.nativeError(err, stack));\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Is the image fully opaque? Will be `true` if the image has no alpha channel or if every pixel is fully opaque.\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any.\n * - `sharpness`: Estimation of greyscale sharpness based on the standard deviation of a Laplacian convolution, discarding alpha channel if any.\n * - `dominant`: Object containing most dominant sRGB colour based on a 4096-bin 3D histogram.\n *\n * **Note**: Statistics are derived from the original input image. Any operations performed on the image must first be\n * written to a buffer in order to run `stats` on the result (see third example).\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @example\n * const { entropy, sharpness, dominant } = await sharp(input).stats();\n * const { r, g, b } = dominant;\n *\n * @example\n * const image = sharp(input);\n * // store intermediate result\n * const part = await image.extract(region).toBuffer();\n * // create new instance to obtain statistics of extracted region\n * const stats = await sharp(part).stats();\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\nfunction stats (callback) {\n  const stack = Error();\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            callback(is.nativeError(err, stack));\n          } else {\n            callback(null, stats);\n          }\n        });\n      });\n    } else {\n      sharp.stats(this.options, (err, stats) => {\n        if (err) {\n          callback(is.nativeError(err, stack));\n        } else {\n          callback(null, stats);\n        }\n      });\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(is.nativeError(err, stack));\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(is.nativeError(err, stack));\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _inputOptionsFromObject,\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats\n  });\n  // Class attributes\n  Sharp.align = align;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvaW5wdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsa0ZBQU07QUFDekIsY0FBYyxtQkFBTyxDQUFDLHdGQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDLE1BQU0sWUFBWSxhQUFhO0FBQ3pFLHlFQUF5RSxvQkFBb0I7QUFDN0YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUJBQXlCLHFDQUFxQyw0QkFBNEI7QUFDN0k7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDRCQUE0Qix3Q0FBd0MsK0JBQStCO0FBQzNKO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZ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U0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVucm91dGVyLWxhbmdncmFwaC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGFycEAwLjM0LjQvbm9kZV9tb2R1bGVzL3NoYXJwL2xpYi9pbnB1dC5qcz82M2M3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzIExvdmVsbCBGdWxsZXIgYW5kIG90aGVycy5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5jb25zdCBzaGFycCA9IHJlcXVpcmUoJy4vc2hhcnAnKTtcblxuLyoqXG4gKiBKdXN0aWZpY2F0aW9uIGFsaWdubWVudFxuICogQG1lbWJlclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWxpZ24gPSB7XG4gIGxlZnQ6ICdsb3cnLFxuICB0b3A6ICdsb3cnLFxuICBsb3c6ICdsb3cnLFxuICBjZW50ZXI6ICdjZW50cmUnLFxuICBjZW50cmU6ICdjZW50cmUnLFxuICByaWdodDogJ2hpZ2gnLFxuICBib3R0b206ICdoaWdoJyxcbiAgaGlnaDogJ2hpZ2gnXG59O1xuXG5jb25zdCBpbnB1dFN0cmVhbVBhcmFtZXRlcnMgPSBbXG4gIC8vIExpbWl0cyBhbmQgZXJyb3IgaGFuZGxpbmdcbiAgJ2ZhaWxPbicsICdsaW1pdElucHV0UGl4ZWxzJywgJ3VubGltaXRlZCcsXG4gIC8vIEZvcm1hdC1nZW5lcmljXG4gICdhbmltYXRlZCcsICdhdXRvT3JpZW50JywgJ2RlbnNpdHknLCAnaWdub3JlSWNjJywgJ3BhZ2UnLCAncGFnZXMnLCAnc2VxdWVudGlhbFJlYWQnLFxuICAvLyBGb3JtYXQtc3BlY2lmaWNcbiAgJ2pwMicsICdvcGVuU2xpZGUnLCAncGRmJywgJ3JhdycsICdzdmcnLCAndGlmZicsXG4gIC8vIERlcHJlY2F0ZWRcbiAgJ2ZhaWxPbkVycm9yJywgJ29wZW5TbGlkZUxldmVsJywgJ3BkZkJhY2tncm91bmQnLCAndGlmZlN1YmlmZCdcbl07XG5cbi8qKlxuICogRXh0cmFjdCBpbnB1dCBvcHRpb25zLCBpZiBhbnksIGZyb20gYW4gb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lucHV0T3B0aW9uc0Zyb21PYmplY3QgKG9iaikge1xuICBjb25zdCBwYXJhbXMgPSBpbnB1dFN0cmVhbVBhcmFtZXRlcnNcbiAgICAuZmlsdGVyKHAgPT4gaXMuZGVmaW5lZChvYmpbcF0pKVxuICAgIC5tYXAocCA9PiAoW3AsIG9ialtwXV0pKTtcbiAgcmV0dXJuIHBhcmFtcy5sZW5ndGhcbiAgICA/IE9iamVjdC5mcm9tRW50cmllcyhwYXJhbXMpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIE9iamVjdCBjb250YWluaW5nIGlucHV0IGFuZCBpbnB1dC1yZWxhdGVkIG9wdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfY3JlYXRlSW5wdXREZXNjcmlwdG9yIChpbnB1dCwgaW5wdXRPcHRpb25zLCBjb250YWluZXJPcHRpb25zKSB7XG4gIGNvbnN0IGlucHV0RGVzY3JpcHRvciA9IHtcbiAgICBhdXRvT3JpZW50OiBmYWxzZSxcbiAgICBmYWlsT246ICd3YXJuaW5nJyxcbiAgICBsaW1pdElucHV0UGl4ZWxzOiBNYXRoLnBvdygweDNGRkYsIDIpLFxuICAgIGlnbm9yZUljYzogZmFsc2UsXG4gICAgdW5saW1pdGVkOiBmYWxzZSxcbiAgICBzZXF1ZW50aWFsUmVhZDogdHJ1ZVxuICB9O1xuICBpZiAoaXMuc3RyaW5nKGlucHV0KSkge1xuICAgIC8vIGZpbGVzeXN0ZW1cbiAgICBpbnB1dERlc2NyaXB0b3IuZmlsZSA9IGlucHV0O1xuICB9IGVsc2UgaWYgKGlzLmJ1ZmZlcihpbnB1dCkpIHtcbiAgICAvLyBCdWZmZXJcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignSW5wdXQgQnVmZmVyIGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGlucHV0RGVzY3JpcHRvci5idWZmZXIgPSBpbnB1dDtcbiAgfSBlbHNlIGlmIChpcy5hcnJheUJ1ZmZlcihpbnB1dCkpIHtcbiAgICBpZiAoaW5wdXQuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lucHV0IGJpdCBBcnJheSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpbnB1dERlc2NyaXB0b3IuYnVmZmVyID0gQnVmZmVyLmZyb20oaW5wdXQsIDAsIGlucHV0LmJ5dGVMZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzLnR5cGVkQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lucHV0IEJpdCBBcnJheSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpbnB1dERlc2NyaXB0b3IuYnVmZmVyID0gQnVmZmVyLmZyb20oaW5wdXQuYnVmZmVyLCBpbnB1dC5ieXRlT2Zmc2V0LCBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChpbnB1dCkgJiYgIWlzLmRlZmluZWQoaW5wdXRPcHRpb25zKSkge1xuICAgIC8vIFBsYWluIE9iamVjdCBkZXNjcmlwdG9yLCBlLmcuIGNyZWF0ZVxuICAgIGlucHV0T3B0aW9ucyA9IGlucHV0O1xuICAgIGlmIChfaW5wdXRPcHRpb25zRnJvbU9iamVjdChpbnB1dE9wdGlvbnMpKSB7XG4gICAgICAvLyBTdHJlYW0gd2l0aCBvcHRpb25zXG4gICAgICBpbnB1dERlc2NyaXB0b3IuYnVmZmVyID0gW107XG4gICAgfVxuICB9IGVsc2UgaWYgKCFpcy5kZWZpbmVkKGlucHV0KSAmJiAhaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMpICYmIGlzLm9iamVjdChjb250YWluZXJPcHRpb25zKSAmJiBjb250YWluZXJPcHRpb25zLmFsbG93U3RyZWFtKSB7XG4gICAgLy8gU3RyZWFtIHdpdGhvdXQgb3B0aW9uc1xuICAgIGlucHV0RGVzY3JpcHRvci5idWZmZXIgPSBbXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBKb2luIGltYWdlcyB0b2dldGhlclxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuam9pbmluZykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuam9pbmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5qb2luID0gaW5wdXQubWFwKGkgPT4gdGhpcy5fY3JlYXRlSW5wdXREZXNjcmlwdG9yKGkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaXZlIGpvaW4gaXMgdW5zdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCB0d28gaW1hZ2VzIHRvIGpvaW4nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBpbnB1dCAnJHtpbnB1dH0nIG9mIHR5cGUgJHt0eXBlb2YgaW5wdXR9JHtcbiAgICAgIGlzLmRlZmluZWQoaW5wdXRPcHRpb25zKSA/IGAgd2hlbiBhbHNvIHByb3ZpZGluZyBvcHRpb25zIG9mIHR5cGUgJHt0eXBlb2YgaW5wdXRPcHRpb25zfWAgOiAnJ1xuICAgIH1gKTtcbiAgfVxuICBpZiAoaXMub2JqZWN0KGlucHV0T3B0aW9ucykpIHtcbiAgICAvLyBEZXByZWNhdGVkOiBmYWlsT25FcnJvclxuICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5mYWlsT25FcnJvcikpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5mYWlsT25FcnJvcikpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLmZhaWxPbiA9IGlucHV0T3B0aW9ucy5mYWlsT25FcnJvciA/ICd3YXJuaW5nJyA6ICdub25lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZmFpbE9uRXJyb3InLCAnYm9vbGVhbicsIGlucHV0T3B0aW9ucy5mYWlsT25FcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZhaWxPblxuICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5mYWlsT24pKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKGlucHV0T3B0aW9ucy5mYWlsT24pICYmIGlzLmluQXJyYXkoaW5wdXRPcHRpb25zLmZhaWxPbiwgWydub25lJywgJ3RydW5jYXRlZCcsICdlcnJvcicsICd3YXJuaW5nJ10pKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5mYWlsT24gPSBpbnB1dE9wdGlvbnMuZmFpbE9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdmYWlsT24nLCAnb25lIG9mOiBub25lLCB0cnVuY2F0ZWQsIGVycm9yLCB3YXJuaW5nJywgaW5wdXRPcHRpb25zLmZhaWxPbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGF1dG9PcmllbnRcbiAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuYXV0b09yaWVudCkpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5hdXRvT3JpZW50KSkge1xuICAgICAgICBpbnB1dERlc2NyaXB0b3IuYXV0b09yaWVudCA9IGlucHV0T3B0aW9ucy5hdXRvT3JpZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdhdXRvT3JpZW50JywgJ2Jvb2xlYW4nLCBpbnB1dE9wdGlvbnMuYXV0b09yaWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERlbnNpdHlcbiAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuZGVuc2l0eSkpIHtcbiAgICAgIGlmIChpcy5pblJhbmdlKGlucHV0T3B0aW9ucy5kZW5zaXR5LCAxLCAxMDAwMDApKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5kZW5zaXR5ID0gaW5wdXRPcHRpb25zLmRlbnNpdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2RlbnNpdHknLCAnbnVtYmVyIGJldHdlZW4gMSBhbmQgMTAwMDAwJywgaW5wdXRPcHRpb25zLmRlbnNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZ25vcmUgZW1iZWRkZGVkIElDQyBwcm9maWxlXG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmlnbm9yZUljYykpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5pZ25vcmVJY2MpKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5pZ25vcmVJY2MgPSBpbnB1dE9wdGlvbnMuaWdub3JlSWNjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdpZ25vcmVJY2MnLCAnYm9vbGVhbicsIGlucHV0T3B0aW9ucy5pZ25vcmVJY2MpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBsaW1pdElucHV0UGl4ZWxzXG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmxpbWl0SW5wdXRQaXhlbHMpKSB7XG4gICAgICBpZiAoaXMuYm9vbChpbnB1dE9wdGlvbnMubGltaXRJbnB1dFBpeGVscykpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLmxpbWl0SW5wdXRQaXhlbHMgPSBpbnB1dE9wdGlvbnMubGltaXRJbnB1dFBpeGVsc1xuICAgICAgICAgID8gTWF0aC5wb3coMHgzRkZGLCAyKVxuICAgICAgICAgIDogMDtcbiAgICAgIH0gZWxzZSBpZiAoaXMuaW50ZWdlcihpbnB1dE9wdGlvbnMubGltaXRJbnB1dFBpeGVscykgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMubGltaXRJbnB1dFBpeGVscywgMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5saW1pdElucHV0UGl4ZWxzID0gaW5wdXRPcHRpb25zLmxpbWl0SW5wdXRQaXhlbHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2xpbWl0SW5wdXRQaXhlbHMnLCAncG9zaXRpdmUgaW50ZWdlcicsIGlucHV0T3B0aW9ucy5saW1pdElucHV0UGl4ZWxzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saW1pdGVkXG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLnVubGltaXRlZCkpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy51bmxpbWl0ZWQpKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci51bmxpbWl0ZWQgPSBpbnB1dE9wdGlvbnMudW5saW1pdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd1bmxpbWl0ZWQnLCAnYm9vbGVhbicsIGlucHV0T3B0aW9ucy51bmxpbWl0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzZXF1ZW50aWFsUmVhZFxuICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5zZXF1ZW50aWFsUmVhZCkpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5zZXF1ZW50aWFsUmVhZCkpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLnNlcXVlbnRpYWxSZWFkID0gaW5wdXRPcHRpb25zLnNlcXVlbnRpYWxSZWFkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdzZXF1ZW50aWFsUmVhZCcsICdib29sZWFuJywgaW5wdXRPcHRpb25zLnNlcXVlbnRpYWxSZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmF3IHBpeGVsIGlucHV0XG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLnJhdykpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaXMub2JqZWN0KGlucHV0T3B0aW9ucy5yYXcpICYmXG4gICAgICAgIGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnJhdy53aWR0aCkgJiYgaW5wdXRPcHRpb25zLnJhdy53aWR0aCA+IDAgJiZcbiAgICAgICAgaXMuaW50ZWdlcihpbnB1dE9wdGlvbnMucmF3LmhlaWdodCkgJiYgaW5wdXRPcHRpb25zLnJhdy5oZWlnaHQgPiAwICYmXG4gICAgICAgIGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnJhdy5jaGFubmVscykgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMucmF3LmNoYW5uZWxzLCAxLCA0KVxuICAgICAgKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5yYXdXaWR0aCA9IGlucHV0T3B0aW9ucy5yYXcud2lkdGg7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5yYXdIZWlnaHQgPSBpbnB1dE9wdGlvbnMucmF3LmhlaWdodDtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0NoYW5uZWxzID0gaW5wdXRPcHRpb25zLnJhdy5jaGFubmVscztcbiAgICAgICAgc3dpdGNoIChpbnB1dC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0RlcHRoID0gJ3VjaGFyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0RlcHRoID0gJ2NoYXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5yYXdEZXB0aCA9ICd1c2hvcnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0RlcHRoID0gJ3Nob3J0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IucmF3RGVwdGggPSAndWludCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IucmF3RGVwdGggPSAnaW50JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0RlcHRoID0gJ2Zsb2F0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRmxvYXQ2NEFycmF5OlxuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0RlcHRoID0gJ2RvdWJsZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnJhd0RlcHRoID0gJ3VjaGFyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHdpZHRoLCBoZWlnaHQgYW5kIGNoYW5uZWxzIGZvciByYXcgcGl4ZWwgaW5wdXQnKTtcbiAgICAgIH1cbiAgICAgIGlucHV0RGVzY3JpcHRvci5yYXdQcmVtdWx0aXBsaWVkID0gZmFsc2U7XG4gICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMucmF3LnByZW11bHRpcGxpZWQpKSB7XG4gICAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5yYXcucHJlbXVsdGlwbGllZCkpIHtcbiAgICAgICAgICBpbnB1dERlc2NyaXB0b3IucmF3UHJlbXVsdGlwbGllZCA9IGlucHV0T3B0aW9ucy5yYXcucHJlbXVsdGlwbGllZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3Jhdy5wcmVtdWx0aXBsaWVkJywgJ2Jvb2xlYW4nLCBpbnB1dE9wdGlvbnMucmF3LnByZW11bHRpcGxpZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnB1dERlc2NyaXB0b3IucmF3UGFnZUhlaWdodCA9IDA7XG4gICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMucmF3LnBhZ2VIZWlnaHQpKSB7XG4gICAgICAgIGlmIChpcy5pbnRlZ2VyKGlucHV0T3B0aW9ucy5yYXcucGFnZUhlaWdodCkgJiYgaW5wdXRPcHRpb25zLnJhdy5wYWdlSGVpZ2h0ID4gMCAmJiBpbnB1dE9wdGlvbnMucmF3LnBhZ2VIZWlnaHQgPD0gaW5wdXRPcHRpb25zLnJhdy5oZWlnaHQpIHtcbiAgICAgICAgICBpZiAoaW5wdXRPcHRpb25zLnJhdy5oZWlnaHQgJSBpbnB1dE9wdGlvbnMucmF3LnBhZ2VIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmF3LmhlaWdodCAke2lucHV0T3B0aW9ucy5yYXcuaGVpZ2h0fSB0byBiZSBhIG11bHRpcGxlIG9mIHJhdy5wYWdlSGVpZ2h0ICR7aW5wdXRPcHRpb25zLnJhdy5wYWdlSGVpZ2h0fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dERlc2NyaXB0b3IucmF3UGFnZUhlaWdodCA9IGlucHV0T3B0aW9ucy5yYXcucGFnZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3Jhdy5wYWdlSGVpZ2h0JywgJ3Bvc2l0aXZlIGludGVnZXInLCBpbnB1dE9wdGlvbnMucmF3LnBhZ2VIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE11bHRpLXBhZ2UgaW5wdXQgKEdJRiwgVElGRiwgUERGKVxuICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5hbmltYXRlZCkpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5hbmltYXRlZCkpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLnBhZ2VzID0gaW5wdXRPcHRpb25zLmFuaW1hdGVkID8gLTEgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdhbmltYXRlZCcsICdib29sZWFuJywgaW5wdXRPcHRpb25zLmFuaW1hdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLnBhZ2VzKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnBhZ2VzKSAmJiBpcy5pblJhbmdlKGlucHV0T3B0aW9ucy5wYWdlcywgLTEsIDEwMDAwMCkpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLnBhZ2VzID0gaW5wdXRPcHRpb25zLnBhZ2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdwYWdlcycsICdpbnRlZ2VyIGJldHdlZW4gLTEgYW5kIDEwMDAwMCcsIGlucHV0T3B0aW9ucy5wYWdlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5wYWdlKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnBhZ2UpICYmIGlzLmluUmFuZ2UoaW5wdXRPcHRpb25zLnBhZ2UsIDAsIDEwMDAwMCkpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLnBhZ2UgPSBpbnB1dE9wdGlvbnMucGFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncGFnZScsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMTAwMDAwJywgaW5wdXRPcHRpb25zLnBhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPcGVuU2xpZGUgc3BlY2lmaWMgb3B0aW9uc1xuICAgIGlmIChpcy5vYmplY3QoaW5wdXRPcHRpb25zLm9wZW5TbGlkZSkgJiYgaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMub3BlblNsaWRlLmxldmVsKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLm9wZW5TbGlkZS5sZXZlbCkgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMub3BlblNsaWRlLmxldmVsLCAwLCAyNTYpKSB7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5vcGVuU2xpZGVMZXZlbCA9IGlucHV0T3B0aW9ucy5vcGVuU2xpZGUubGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wZW5TbGlkZS5sZXZlbCcsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjU2JywgaW5wdXRPcHRpb25zLm9wZW5TbGlkZS5sZXZlbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5sZXZlbCkpIHtcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGlmIChpcy5pbnRlZ2VyKGlucHV0T3B0aW9ucy5sZXZlbCkgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMubGV2ZWwsIDAsIDI1NikpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLm9wZW5TbGlkZUxldmVsID0gaW5wdXRPcHRpb25zLmxldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdsZXZlbCcsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjU2JywgaW5wdXRPcHRpb25zLmxldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVElGRiBzcGVjaWZpYyBvcHRpb25zXG4gICAgaWYgKGlzLm9iamVjdChpbnB1dE9wdGlvbnMudGlmZikgJiYgaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGlmZi5zdWJpZmQpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihpbnB1dE9wdGlvbnMudGlmZi5zdWJpZmQpICYmIGlzLmluUmFuZ2UoaW5wdXRPcHRpb25zLnRpZmYuc3ViaWZkLCAtMSwgMTAwMDAwKSkge1xuICAgICAgICBpbnB1dERlc2NyaXB0b3IudGlmZlN1YmlmZCA9IGlucHV0T3B0aW9ucy50aWZmLnN1YmlmZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGlmZi5zdWJpZmQnLCAnaW50ZWdlciBiZXR3ZWVuIC0xIGFuZCAxMDAwMDAnLCBpbnB1dE9wdGlvbnMudGlmZi5zdWJpZmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuc3ViaWZkKSkge1xuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnN1YmlmZCkgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMuc3ViaWZkLCAtMSwgMTAwMDAwKSkge1xuICAgICAgICBpbnB1dERlc2NyaXB0b3IudGlmZlN1YmlmZCA9IGlucHV0T3B0aW9ucy5zdWJpZmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3N1YmlmZCcsICdpbnRlZ2VyIGJldHdlZW4gLTEgYW5kIDEwMDAwMCcsIGlucHV0T3B0aW9ucy5zdWJpZmQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTVkcgc3BlY2lmaWMgb3B0aW9uc1xuICAgIGlmIChpcy5vYmplY3QoaW5wdXRPcHRpb25zLnN2ZykpIHtcbiAgICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5zdmcuc3R5bGVzaGVldCkpIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhpbnB1dE9wdGlvbnMuc3ZnLnN0eWxlc2hlZXQpKSB7XG4gICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnN2Z1N0eWxlc2hlZXQgPSBpbnB1dE9wdGlvbnMuc3ZnLnN0eWxlc2hlZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdzdmcuc3R5bGVzaGVldCcsICdzdHJpbmcnLCBpbnB1dE9wdGlvbnMuc3ZnLnN0eWxlc2hlZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuc3ZnLmhpZ2hCaXRkZXB0aCkpIHtcbiAgICAgICAgaWYgKGlzLmJvb2woaW5wdXRPcHRpb25zLnN2Zy5oaWdoQml0ZGVwdGgpKSB7XG4gICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnN2Z0hpZ2hCaXRkZXB0aCA9IGlucHV0T3B0aW9ucy5zdmcuaGlnaEJpdGRlcHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignc3ZnLmhpZ2hCaXRkZXB0aCcsICdib29sZWFuJywgaW5wdXRPcHRpb25zLnN2Zy5oaWdoQml0ZGVwdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBERiBzcGVjaWZpYyBvcHRpb25zXG4gICAgaWYgKGlzLm9iamVjdChpbnB1dE9wdGlvbnMucGRmKSAmJiBpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5wZGYuYmFja2dyb3VuZCkpIHtcbiAgICAgIGlucHV0RGVzY3JpcHRvci5wZGZCYWNrZ3JvdW5kID0gdGhpcy5fZ2V0QmFja2dyb3VuZENvbG91ck9wdGlvbihpbnB1dE9wdGlvbnMucGRmLmJhY2tncm91bmQpO1xuICAgIH0gZWxzZSBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMucGRmQmFja2dyb3VuZCkpIHtcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGlucHV0RGVzY3JpcHRvci5wZGZCYWNrZ3JvdW5kID0gdGhpcy5fZ2V0QmFja2dyb3VuZENvbG91ck9wdGlvbihpbnB1dE9wdGlvbnMucGRmQmFja2dyb3VuZCk7XG4gICAgfVxuICAgIC8vIEpQRUcgMjAwMCBzcGVjaWZpYyBvcHRpb25zXG4gICAgaWYgKGlzLm9iamVjdChpbnB1dE9wdGlvbnMuanAyKSAmJiBpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5qcDIub25lc2hvdCkpIHtcbiAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy5qcDIub25lc2hvdCkpIHtcbiAgICAgICAgaW5wdXREZXNjcmlwdG9yLmpwMk9uZXNob3QgPSBpbnB1dE9wdGlvbnMuanAyLm9uZXNob3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2pwMi5vbmVzaG90JywgJ2Jvb2xlYW4nLCBpbnB1dE9wdGlvbnMuanAyLm9uZXNob3QpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDcmVhdGUgbmV3IGltYWdlXG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmNyZWF0ZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaXMub2JqZWN0KGlucHV0T3B0aW9ucy5jcmVhdGUpICYmXG4gICAgICAgIGlzLmludGVnZXIoaW5wdXRPcHRpb25zLmNyZWF0ZS53aWR0aCkgJiYgaW5wdXRPcHRpb25zLmNyZWF0ZS53aWR0aCA+IDAgJiZcbiAgICAgICAgaXMuaW50ZWdlcihpbnB1dE9wdGlvbnMuY3JlYXRlLmhlaWdodCkgJiYgaW5wdXRPcHRpb25zLmNyZWF0ZS5oZWlnaHQgPiAwICYmXG4gICAgICAgIGlzLmludGVnZXIoaW5wdXRPcHRpb25zLmNyZWF0ZS5jaGFubmVscylcbiAgICAgICkge1xuICAgICAgICBpbnB1dERlc2NyaXB0b3IuY3JlYXRlV2lkdGggPSBpbnB1dE9wdGlvbnMuY3JlYXRlLndpZHRoO1xuICAgICAgICBpbnB1dERlc2NyaXB0b3IuY3JlYXRlSGVpZ2h0ID0gaW5wdXRPcHRpb25zLmNyZWF0ZS5oZWlnaHQ7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5jcmVhdGVDaGFubmVscyA9IGlucHV0T3B0aW9ucy5jcmVhdGUuY2hhbm5lbHM7XG4gICAgICAgIGlucHV0RGVzY3JpcHRvci5jcmVhdGVQYWdlSGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmNyZWF0ZS5wYWdlSGVpZ2h0KSkge1xuICAgICAgICAgIGlmIChpcy5pbnRlZ2VyKGlucHV0T3B0aW9ucy5jcmVhdGUucGFnZUhlaWdodCkgJiYgaW5wdXRPcHRpb25zLmNyZWF0ZS5wYWdlSGVpZ2h0ID4gMCAmJiBpbnB1dE9wdGlvbnMuY3JlYXRlLnBhZ2VIZWlnaHQgPD0gaW5wdXRPcHRpb25zLmNyZWF0ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dE9wdGlvbnMuY3JlYXRlLmhlaWdodCAlIGlucHV0T3B0aW9ucy5jcmVhdGUucGFnZUhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGNyZWF0ZS5oZWlnaHQgJHtpbnB1dE9wdGlvbnMuY3JlYXRlLmhlaWdodH0gdG8gYmUgYSBtdWx0aXBsZSBvZiBjcmVhdGUucGFnZUhlaWdodCAke2lucHV0T3B0aW9ucy5jcmVhdGUucGFnZUhlaWdodH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5jcmVhdGVQYWdlSGVpZ2h0ID0gaW5wdXRPcHRpb25zLmNyZWF0ZS5wYWdlSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NyZWF0ZS5wYWdlSGVpZ2h0JywgJ3Bvc2l0aXZlIGludGVnZXInLCBpbnB1dE9wdGlvbnMuY3JlYXRlLnBhZ2VIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb2lzZVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuY3JlYXRlLm5vaXNlKSkge1xuICAgICAgICAgIGlmICghaXMub2JqZWN0KGlucHV0T3B0aW9ucy5jcmVhdGUubm9pc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vaXNlIHRvIGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5wdXRPcHRpb25zLmNyZWF0ZS5ub2lzZS50eXBlICE9PSAnZ2F1c3NpYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZ2F1c3NpYW4gbm9pc2UgaXMgc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXREZXNjcmlwdG9yLmNyZWF0ZU5vaXNlVHlwZSA9IGlucHV0T3B0aW9ucy5jcmVhdGUubm9pc2UudHlwZTtcbiAgICAgICAgICBpZiAoIWlzLmluUmFuZ2UoaW5wdXRPcHRpb25zLmNyZWF0ZS5jaGFubmVscywgMSwgNCkpIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignY3JlYXRlLmNoYW5uZWxzJywgJ251bWJlciBiZXR3ZWVuIDEgYW5kIDQnLCBpbnB1dE9wdGlvbnMuY3JlYXRlLmNoYW5uZWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXREZXNjcmlwdG9yLmNyZWF0ZU5vaXNlTWVhbiA9IDEyODtcbiAgICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuY3JlYXRlLm5vaXNlLm1lYW4pKSB7XG4gICAgICAgICAgICBpZiAoaXMubnVtYmVyKGlucHV0T3B0aW9ucy5jcmVhdGUubm9pc2UubWVhbikgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMuY3JlYXRlLm5vaXNlLm1lYW4sIDAsIDEwMDAwKSkge1xuICAgICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IuY3JlYXRlTm9pc2VNZWFuID0gaW5wdXRPcHRpb25zLmNyZWF0ZS5ub2lzZS5tZWFuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdjcmVhdGUubm9pc2UubWVhbicsICdudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAwMCcsIGlucHV0T3B0aW9ucy5jcmVhdGUubm9pc2UubWVhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5jcmVhdGVOb2lzZVNpZ21hID0gMzA7XG4gICAgICAgICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmNyZWF0ZS5ub2lzZS5zaWdtYSkpIHtcbiAgICAgICAgICAgIGlmIChpcy5udW1iZXIoaW5wdXRPcHRpb25zLmNyZWF0ZS5ub2lzZS5zaWdtYSkgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMuY3JlYXRlLm5vaXNlLnNpZ21hLCAwLCAxMDAwMCkpIHtcbiAgICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLmNyZWF0ZU5vaXNlU2lnbWEgPSBpbnB1dE9wdGlvbnMuY3JlYXRlLm5vaXNlLnNpZ21hO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdjcmVhdGUubm9pc2Uuc2lnbWEnLCAnbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwMDAnLCBpbnB1dE9wdGlvbnMuY3JlYXRlLm5vaXNlLnNpZ21hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuY3JlYXRlLmJhY2tncm91bmQpKSB7XG4gICAgICAgICAgaWYgKCFpcy5pblJhbmdlKGlucHV0T3B0aW9ucy5jcmVhdGUuY2hhbm5lbHMsIDMsIDQpKSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NyZWF0ZS5jaGFubmVscycsICdudW1iZXIgYmV0d2VlbiAzIGFuZCA0JywgaW5wdXRPcHRpb25zLmNyZWF0ZS5jaGFubmVscyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5jcmVhdGVCYWNrZ3JvdW5kID0gdGhpcy5fZ2V0QmFja2dyb3VuZENvbG91ck9wdGlvbihpbnB1dE9wdGlvbnMuY3JlYXRlLmJhY2tncm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgbm9pc2Ugb3IgYmFja2dyb3VuZCB0byBjcmVhdGUgYSBuZXcgaW5wdXQgaW1hZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaW5wdXREZXNjcmlwdG9yLmJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgd2lkdGgsIGhlaWdodCBhbmQgY2hhbm5lbHMgdG8gY3JlYXRlIGEgbmV3IGlucHV0IGltYWdlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbWFnZSB3aXRoIHRleHRcbiAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dCkpIHtcbiAgICAgIGlmIChpcy5vYmplY3QoaW5wdXRPcHRpb25zLnRleHQpICYmIGlzLnN0cmluZyhpbnB1dE9wdGlvbnMudGV4dC50ZXh0KSkge1xuICAgICAgICBpbnB1dERlc2NyaXB0b3IudGV4dFZhbHVlID0gaW5wdXRPcHRpb25zLnRleHQudGV4dDtcbiAgICAgICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLnRleHQuaGVpZ2h0KSAmJiBpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy50ZXh0LmRwaSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG9ubHkgb25lIG9mIGRwaSBvciBoZWlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC5mb250KSkge1xuICAgICAgICAgIGlmIChpcy5zdHJpbmcoaW5wdXRPcHRpb25zLnRleHQuZm9udCkpIHtcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci50ZXh0Rm9udCA9IGlucHV0T3B0aW9ucy50ZXh0LmZvbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGV4dC5mb250JywgJ3N0cmluZycsIGlucHV0T3B0aW9ucy50ZXh0LmZvbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC5mb250ZmlsZSkpIHtcbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKGlucHV0T3B0aW9ucy50ZXh0LmZvbnRmaWxlKSkge1xuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnRleHRGb250ZmlsZSA9IGlucHV0T3B0aW9ucy50ZXh0LmZvbnRmaWxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RleHQuZm9udGZpbGUnLCAnc3RyaW5nJywgaW5wdXRPcHRpb25zLnRleHQuZm9udGZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC53aWR0aCkpIHtcbiAgICAgICAgICBpZiAoaXMuaW50ZWdlcihpbnB1dE9wdGlvbnMudGV4dC53aWR0aCkgJiYgaW5wdXRPcHRpb25zLnRleHQud2lkdGggPiAwKSB7XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IudGV4dFdpZHRoID0gaW5wdXRPcHRpb25zLnRleHQud2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGV4dC53aWR0aCcsICdwb3NpdGl2ZSBpbnRlZ2VyJywgaW5wdXRPcHRpb25zLnRleHQud2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC5oZWlnaHQpKSB7XG4gICAgICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnRleHQuaGVpZ2h0KSAmJiBpbnB1dE9wdGlvbnMudGV4dC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IudGV4dEhlaWdodCA9IGlucHV0T3B0aW9ucy50ZXh0LmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd0ZXh0LmhlaWdodCcsICdwb3NpdGl2ZSBpbnRlZ2VyJywgaW5wdXRPcHRpb25zLnRleHQuaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLnRleHQuYWxpZ24pKSB7XG4gICAgICAgICAgaWYgKGlzLnN0cmluZyhpbnB1dE9wdGlvbnMudGV4dC5hbGlnbikgJiYgaXMuc3RyaW5nKHRoaXMuY29uc3RydWN0b3IuYWxpZ25baW5wdXRPcHRpb25zLnRleHQuYWxpZ25dKSkge1xuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnRleHRBbGlnbiA9IHRoaXMuY29uc3RydWN0b3IuYWxpZ25baW5wdXRPcHRpb25zLnRleHQuYWxpZ25dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RleHQuYWxpZ24nLCAndmFsaWQgYWxpZ25tZW50JywgaW5wdXRPcHRpb25zLnRleHQuYWxpZ24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC5qdXN0aWZ5KSkge1xuICAgICAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy50ZXh0Lmp1c3RpZnkpKSB7XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IudGV4dEp1c3RpZnkgPSBpbnB1dE9wdGlvbnMudGV4dC5qdXN0aWZ5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RleHQuanVzdGlmeScsICdib29sZWFuJywgaW5wdXRPcHRpb25zLnRleHQuanVzdGlmeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy50ZXh0LmRwaSkpIHtcbiAgICAgICAgICBpZiAoaXMuaW50ZWdlcihpbnB1dE9wdGlvbnMudGV4dC5kcGkpICYmIGlzLmluUmFuZ2UoaW5wdXRPcHRpb25zLnRleHQuZHBpLCAxLCAxMDAwMDAwKSkge1xuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnRleHREcGkgPSBpbnB1dE9wdGlvbnMudGV4dC5kcGk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGV4dC5kcGknLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwMDAwMDAnLCBpbnB1dE9wdGlvbnMudGV4dC5kcGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC5yZ2JhKSkge1xuICAgICAgICAgIGlmIChpcy5ib29sKGlucHV0T3B0aW9ucy50ZXh0LnJnYmEpKSB7XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3IudGV4dFJnYmEgPSBpbnB1dE9wdGlvbnMudGV4dC5yZ2JhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RleHQucmdiYScsICdib29sJywgaW5wdXRPcHRpb25zLnRleHQucmdiYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy50ZXh0LnNwYWNpbmcpKSB7XG4gICAgICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLnRleHQuc3BhY2luZykgJiYgaXMuaW5SYW5nZShpbnB1dE9wdGlvbnMudGV4dC5zcGFjaW5nLCAtMTAwMDAwMCwgMTAwMDAwMCkpIHtcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci50ZXh0U3BhY2luZyA9IGlucHV0T3B0aW9ucy50ZXh0LnNwYWNpbmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGV4dC5zcGFjaW5nJywgJ2ludGVnZXIgYmV0d2VlbiAtMTAwMDAwMCBhbmQgMTAwMDAwMCcsIGlucHV0T3B0aW9ucy50ZXh0LnNwYWNpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMudGV4dC53cmFwKSkge1xuICAgICAgICAgIGlmIChpcy5zdHJpbmcoaW5wdXRPcHRpb25zLnRleHQud3JhcCkgJiYgaXMuaW5BcnJheShpbnB1dE9wdGlvbnMudGV4dC53cmFwLCBbJ3dvcmQnLCAnY2hhcicsICd3b3JkLWNoYXInLCAnbm9uZSddKSkge1xuICAgICAgICAgICAgaW5wdXREZXNjcmlwdG9yLnRleHRXcmFwID0gaW5wdXRPcHRpb25zLnRleHQud3JhcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd0ZXh0LndyYXAnLCAnb25lIG9mOiB3b3JkLCBjaGFyLCB3b3JkLWNoYXIsIG5vbmUnLCBpbnB1dE9wdGlvbnMudGV4dC53cmFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGlucHV0RGVzY3JpcHRvci5idWZmZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgdmFsaWQgc3RyaW5nIHRvIGNyZWF0ZSBhbiBpbWFnZSB3aXRoIHRleHQuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEpvaW4gaW1hZ2VzIHRvZ2V0aGVyXG4gICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmpvaW4pKSB7XG4gICAgICBpZiAoaXMuZGVmaW5lZCh0aGlzLm9wdGlvbnMuam9pbikpIHtcbiAgICAgICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmpvaW4uYW5pbWF0ZWQpKSB7XG4gICAgICAgICAgaWYgKGlzLmJvb2woaW5wdXRPcHRpb25zLmpvaW4uYW5pbWF0ZWQpKSB7XG4gICAgICAgICAgICBpbnB1dERlc2NyaXB0b3Iuam9pbkFuaW1hdGVkID0gaW5wdXRPcHRpb25zLmpvaW4uYW5pbWF0ZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignam9pbi5hbmltYXRlZCcsICdib29sZWFuJywgaW5wdXRPcHRpb25zLmpvaW4uYW5pbWF0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuam9pbi5hY3Jvc3MpKSB7XG4gICAgICAgICAgaWYgKGlzLmludGVnZXIoaW5wdXRPcHRpb25zLmpvaW4uYWNyb3NzKSAmJiBpcy5pblJhbmdlKGlucHV0T3B0aW9ucy5qb2luLmFjcm9zcywgMSwgMTAwMDAwMCkpIHtcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5qb2luQWNyb3NzID0gaW5wdXRPcHRpb25zLmpvaW4uYWNyb3NzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2pvaW4uYWNyb3NzJywgJ2ludGVnZXIgYmV0d2VlbiAxIGFuZCAxMDAwMDAnLCBpbnB1dE9wdGlvbnMuam9pbi5hY3Jvc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZGVmaW5lZChpbnB1dE9wdGlvbnMuam9pbi5zaGltKSkge1xuICAgICAgICAgIGlmIChpcy5pbnRlZ2VyKGlucHV0T3B0aW9ucy5qb2luLnNoaW0pICYmIGlzLmluUmFuZ2UoaW5wdXRPcHRpb25zLmpvaW4uc2hpbSwgMCwgMTAwMDAwMCkpIHtcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5qb2luU2hpbSA9IGlucHV0T3B0aW9ucy5qb2luLnNoaW07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignam9pbi5zaGltJywgJ2ludGVnZXIgYmV0d2VlbiAwIGFuZCAxMDAwMDAnLCBpbnB1dE9wdGlvbnMuam9pbi5zaGltKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zLmpvaW4uYmFja2dyb3VuZCkpIHtcbiAgICAgICAgICBpbnB1dERlc2NyaXB0b3Iuam9pbkJhY2tncm91bmQgPSB0aGlzLl9nZXRCYWNrZ3JvdW5kQ29sb3VyT3B0aW9uKGlucHV0T3B0aW9ucy5qb2luLmJhY2tncm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5qb2luLmhhbGlnbikpIHtcbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKGlucHV0T3B0aW9ucy5qb2luLmhhbGlnbikgJiYgaXMuc3RyaW5nKHRoaXMuY29uc3RydWN0b3IuYWxpZ25baW5wdXRPcHRpb25zLmpvaW4uaGFsaWduXSkpIHtcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5qb2luSGFsaWduID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGlnbltpbnB1dE9wdGlvbnMuam9pbi5oYWxpZ25dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2pvaW4uaGFsaWduJywgJ3ZhbGlkIGFsaWdubWVudCcsIGlucHV0T3B0aW9ucy5qb2luLmhhbGlnbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5kZWZpbmVkKGlucHV0T3B0aW9ucy5qb2luLnZhbGlnbikpIHtcbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKGlucHV0T3B0aW9ucy5qb2luLnZhbGlnbikgJiYgaXMuc3RyaW5nKHRoaXMuY29uc3RydWN0b3IuYWxpZ25baW5wdXRPcHRpb25zLmpvaW4udmFsaWduXSkpIHtcbiAgICAgICAgICAgIGlucHV0RGVzY3JpcHRvci5qb2luVmFsaWduID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGlnbltpbnB1dE9wdGlvbnMuam9pbi52YWxpZ25dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2pvaW4udmFsaWduJywgJ3ZhbGlkIGFsaWdubWVudCcsIGlucHV0T3B0aW9ucy5qb2luLnZhbGlnbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlucHV0IHRvIGJlIGFuIGFycmF5IG9mIGltYWdlcyB0byBqb2luJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzLmRlZmluZWQoaW5wdXRPcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvcHRpb25zICcgKyBpbnB1dE9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBpbnB1dERlc2NyaXB0b3I7XG59XG5cbi8qKlxuICogSGFuZGxlIGluY29taW5nIEJ1ZmZlciBjaHVuayBvbiBXcml0YWJsZSBTdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgLSB1bnVzZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIF93cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuaW5wdXQuYnVmZmVyKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzLmJ1ZmZlcihjaHVuaykpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5wdXQuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1JbkZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMuaW5wdXQuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdOb24tQnVmZmVyIGRhdGEgb24gV3JpdGFibGUgU3RyZWFtJykpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZGF0YSBvbiBXcml0YWJsZSBTdHJlYW0nKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyB0aGUgYXJyYXkgb2YgY2h1bmtzIGFjY3VtdWxhdGVkIGluIGlucHV0LmJ1ZmZlci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9mbGF0dGVuQnVmZmVySW4gKCkge1xuICBpZiAodGhpcy5faXNTdHJlYW1JbnB1dCgpKSB7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0LmJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQodGhpcy5vcHRpb25zLmlucHV0LmJ1ZmZlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBBcmUgd2UgZXhwZWN0aW5nIFN0cmVhbS1iYXNlZCBpbnB1dD9cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2lzU3RyZWFtSW5wdXQgKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuaW5wdXQuYnVmZmVyKTtcbn1cblxuLyoqXG4gKiBGYXN0IGFjY2VzcyB0byAodW5jYWNoZWQpIGltYWdlIG1ldGFkYXRhIHdpdGhvdXQgZGVjb2RpbmcgYW55IGNvbXByZXNzZWQgcGl4ZWwgZGF0YS5cbiAqXG4gKiBUaGlzIGlzIHJlYWQgZnJvbSB0aGUgaGVhZGVyIG9mIHRoZSBpbnB1dCBpbWFnZS5cbiAqIEl0IGRvZXMgbm90IHRha2UgaW50byBjb25zaWRlcmF0aW9uIGFueSBvcGVyYXRpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG91dHB1dCBpbWFnZSxcbiAqIHN1Y2ggYXMgcmVzaXplIG9yIHJvdGF0ZS5cbiAqXG4gKiBEaW1lbnNpb25zIGluIHRoZSByZXNwb25zZSB3aWxsIHJlc3BlY3QgdGhlIGBwYWdlYCBhbmQgYHBhZ2VzYCBwcm9wZXJ0aWVzIG9mIHRoZVxuICoge0BsaW5rIC9hcGktY29uc3RydWN0b3IjcGFyYW1ldGVyc3xjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzfS5cbiAqXG4gKiBBIGBQcm9taXNlYCBpcyByZXR1cm5lZCB3aGVuIGBjYWxsYmFja2AgaXMgbm90IHByb3ZpZGVkLlxuICpcbiAqIC0gYGZvcm1hdGA6IE5hbWUgb2YgZGVjb2RlciB1c2VkIHRvIGRlY29tcHJlc3MgaW1hZ2UgZGF0YSBlLmcuIGBqcGVnYCwgYHBuZ2AsIGB3ZWJwYCwgYGdpZmAsIGBzdmdgXG4gKiAtIGBzaXplYDogVG90YWwgc2l6ZSBvZiBpbWFnZSBpbiBieXRlcywgZm9yIFN0cmVhbSBhbmQgQnVmZmVyIGlucHV0IG9ubHlcbiAqIC0gYHdpZHRoYDogTnVtYmVyIG9mIHBpeGVscyB3aWRlIChFWElGIG9yaWVudGF0aW9uIGlzIG5vdCB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIHNlZSBleGFtcGxlIGJlbG93KVxuICogLSBgaGVpZ2h0YDogTnVtYmVyIG9mIHBpeGVscyBoaWdoIChFWElGIG9yaWVudGF0aW9uIGlzIG5vdCB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIHNlZSBleGFtcGxlIGJlbG93KVxuICogLSBgc3BhY2VgOiBOYW1lIG9mIGNvbG91ciBzcGFjZSBpbnRlcnByZXRhdGlvbiBlLmcuIGBzcmdiYCwgYHJnYmAsIGBjbXlrYCwgYGxhYmAsIGBiLXdgIFsuLi5dKGh0dHBzOi8vd3d3LmxpYnZpcHMub3JnL0FQSS9jdXJyZW50L1ZpcHNJbWFnZS5odG1sI1ZpcHNJbnRlcnByZXRhdGlvbilcbiAqIC0gYGNoYW5uZWxzYDogTnVtYmVyIG9mIGJhbmRzIGUuZy4gYDNgIGZvciBzUkdCLCBgNGAgZm9yIENNWUtcbiAqIC0gYGRlcHRoYDogTmFtZSBvZiBwaXhlbCBkZXB0aCBmb3JtYXQgZS5nLiBgdWNoYXJgLCBgY2hhcmAsIGB1c2hvcnRgLCBgZmxvYXRgIFsuLi5dKGh0dHBzOi8vd3d3LmxpYnZpcHMub3JnL0FQSS9jdXJyZW50L1ZpcHNJbWFnZS5odG1sI1ZpcHNCYW5kRm9ybWF0KVxuICogLSBgZGVuc2l0eWA6IE51bWJlciBvZiBwaXhlbHMgcGVyIGluY2ggKERQSSksIGlmIHByZXNlbnRcbiAqIC0gYGNocm9tYVN1YnNhbXBsaW5nYDogU3RyaW5nIGNvbnRhaW5pbmcgSlBFRyBjaHJvbWEgc3Vic2FtcGxpbmcsIGA0OjI6MGAgb3IgYDQ6NDo0YCBmb3IgUkdCLCBgNDoyOjA6NGAgb3IgYDQ6NDo0OjRgIGZvciBDTVlLXG4gKiAtIGBpc1Byb2dyZXNzaXZlYDogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGltYWdlIGlzIGludGVybGFjZWQgdXNpbmcgYSBwcm9ncmVzc2l2ZSBzY2FuXG4gKiAtIGBpc1BhbGV0dGVgOiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgaW1hZ2UgaXMgcGFsZXR0ZS1iYXNlZCAoR0lGLCBQTkcpLlxuICogLSBgYml0c1BlclNhbXBsZWA6IE51bWJlciBvZiBiaXRzIHBlciBzYW1wbGUgZm9yIGVhY2ggY2hhbm5lbCAoR0lGLCBQTkcsIEhFSUYpLlxuICogLSBgcGFnZXNgOiBOdW1iZXIgb2YgcGFnZXMvZnJhbWVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGltYWdlLCB3aXRoIHN1cHBvcnQgZm9yIFRJRkYsIEhFSUYsIFBERiwgYW5pbWF0ZWQgR0lGIGFuZCBhbmltYXRlZCBXZWJQXG4gKiAtIGBwYWdlSGVpZ2h0YDogTnVtYmVyIG9mIHBpeGVscyBoaWdoIGVhY2ggcGFnZSBpbiBhIG11bHRpLXBhZ2UgaW1hZ2Ugd2lsbCBiZS5cbiAqIC0gYGxvb3BgOiBOdW1iZXIgb2YgdGltZXMgdG8gbG9vcCBhbiBhbmltYXRlZCBpbWFnZSwgemVybyByZWZlcnMgdG8gYSBjb250aW51b3VzIGxvb3AuXG4gKiAtIGBkZWxheWA6IERlbGF5IGluIG1zIGJldHdlZW4gZWFjaCBwYWdlIGluIGFuIGFuaW1hdGVkIGltYWdlLCBwcm92aWRlZCBhcyBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbiAqIC0gYHBhZ2VQcmltYXJ5YDogTnVtYmVyIG9mIHRoZSBwcmltYXJ5IHBhZ2UgaW4gYSBIRUlGIGltYWdlXG4gKiAtIGBsZXZlbHNgOiBEZXRhaWxzIG9mIGVhY2ggbGV2ZWwgaW4gYSBtdWx0aS1sZXZlbCBpbWFnZSBwcm92aWRlZCBhcyBhbiBhcnJheSBvZiBvYmplY3RzLCByZXF1aXJlcyBsaWJ2aXBzIGNvbXBpbGVkIHdpdGggc3VwcG9ydCBmb3IgT3BlblNsaWRlXG4gKiAtIGBzdWJpZmRzYDogTnVtYmVyIG9mIFN1YiBJbWFnZSBGaWxlIERpcmVjdG9yaWVzIGluIGFuIE9NRS1USUZGIGltYWdlXG4gKiAtIGBiYWNrZ3JvdW5kYDogRGVmYXVsdCBiYWNrZ3JvdW5kIGNvbG91ciwgaWYgcHJlc2VudCwgZm9yIFBORyAoYktHRCkgYW5kIEdJRiBpbWFnZXNcbiAqIC0gYGNvbXByZXNzaW9uYDogVGhlIGVuY29kZXIgdXNlZCB0byBjb21wcmVzcyBhbiBIRUlGIGZpbGUsIGBhdjFgIChBVklGKSBvciBgaGV2Y2AgKEhFSUMpXG4gKiAtIGByZXNvbHV0aW9uVW5pdGA6IFRoZSB1bml0IG9mIHJlc29sdXRpb24gKGRlbnNpdHkpLCBlaXRoZXIgYGluY2hgIG9yIGBjbWAsIGlmIHByZXNlbnRcbiAqIC0gYGhhc1Byb2ZpbGVgOiBCb29sZWFuIGluZGljYXRpbmcgdGhlIHByZXNlbmNlIG9mIGFuIGVtYmVkZGVkIElDQyBwcm9maWxlXG4gKiAtIGBoYXNBbHBoYWA6IEJvb2xlYW4gaW5kaWNhdGluZyB0aGUgcHJlc2VuY2Ugb2YgYW4gYWxwaGEgdHJhbnNwYXJlbmN5IGNoYW5uZWxcbiAqIC0gYG9yaWVudGF0aW9uYDogTnVtYmVyIHZhbHVlIG9mIHRoZSBFWElGIE9yaWVudGF0aW9uIGhlYWRlciwgaWYgcHJlc2VudFxuICogLSBgZXhpZmA6IEJ1ZmZlciBjb250YWluaW5nIHJhdyBFWElGIGRhdGEsIGlmIHByZXNlbnRcbiAqIC0gYGljY2A6IEJ1ZmZlciBjb250YWluaW5nIHJhdyBbSUNDXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9pY2MpIHByb2ZpbGUgZGF0YSwgaWYgcHJlc2VudFxuICogLSBgaXB0Y2A6IEJ1ZmZlciBjb250YWluaW5nIHJhdyBJUFRDIGRhdGEsIGlmIHByZXNlbnRcbiAqIC0gYHhtcGA6IEJ1ZmZlciBjb250YWluaW5nIHJhdyBYTVAgZGF0YSwgaWYgcHJlc2VudFxuICogLSBgeG1wQXNTdHJpbmdgOiBTdHJpbmcgY29udGFpbmluZyBYTVAgZGF0YSwgaWYgdmFsaWQgVVRGLTguXG4gKiAtIGB0aWZmdGFnUGhvdG9zaG9wYDogQnVmZmVyIGNvbnRhaW5pbmcgcmF3IFRJRkZUQUdfUEhPVE9TSE9QIGRhdGEsIGlmIHByZXNlbnRcbiAqIC0gYGZvcm1hdE1hZ2lja2A6IFN0cmluZyBjb250YWluaW5nIGZvcm1hdCBmb3IgaW1hZ2VzIGxvYWRlZCB2aWEgKm1hZ2lja1xuICogLSBgY29tbWVudHNgOiBBcnJheSBvZiBrZXl3b3JkL3RleHQgcGFpcnMgcmVwcmVzZW50aW5nIFBORyB0ZXh0IGJsb2NrcywgaWYgcHJlc2VudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBzaGFycChpbnB1dCkubWV0YWRhdGEoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgaW1hZ2UgPSBzaGFycChpbnB1dEpwZyk7XG4gKiBpbWFnZVxuICogICAubWV0YWRhdGEoKVxuICogICAudGhlbihmdW5jdGlvbihtZXRhZGF0YSkge1xuICogICAgIHJldHVybiBpbWFnZVxuICogICAgICAgLnJlc2l6ZShNYXRoLnJvdW5kKG1ldGFkYXRhLndpZHRoIC8gMikpXG4gKiAgICAgICAud2VicCgpXG4gKiAgICAgICAudG9CdWZmZXIoKTtcbiAqICAgfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICogICAgIC8vIGRhdGEgY29udGFpbnMgYSBXZWJQIGltYWdlIGhhbGYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIG9yaWdpbmFsIEpQRUdcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEdldCBkaW1lbnNpb25zIHRha2luZyBFWElGIE9yaWVudGF0aW9uIGludG8gYWNjb3VudC5cbiAqIGNvbnN0IHsgYXV0b09yaWVudCB9ID0gYXdhaXQgc2hhcnAoaW5wdXQpLm1ldGFkYXRhKCk7XG4gKiBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGF1dG9PcmllbnQ7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGNhbGxlZCB3aXRoIHRoZSBhcmd1bWVudHMgYChlcnIsIG1ldGFkYXRhKWBcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIG1ldGFkYXRhIChjYWxsYmFjaykge1xuICBjb25zdCBzdGFjayA9IEVycm9yKCk7XG4gIGlmIChpcy5mbihjYWxsYmFjaykpIHtcbiAgICBpZiAodGhpcy5faXNTdHJlYW1JbnB1dCgpKSB7XG4gICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5CdWZmZXJJbigpO1xuICAgICAgICBzaGFycC5tZXRhZGF0YSh0aGlzLm9wdGlvbnMsIChlcnIsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFycC5tZXRhZGF0YSh0aGlzLm9wdGlvbnMsIChlcnIsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhpcy5uYXRpdmVFcnJvcihlcnIsIHN0YWNrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuX2lzU3RyZWFtSW5wdXQoKSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZmxhdHRlbkJ1ZmZlckluKCk7XG4gICAgICAgICAgc2hhcnAubWV0YWRhdGEodGhpcy5vcHRpb25zLCAoZXJyLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShtZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlRmluaXNoZWQpIHtcbiAgICAgICAgICBmaW5pc2hlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25jZSgnZmluaXNoJywgZmluaXNoZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc2hhcnAubWV0YWRhdGEodGhpcy5vcHRpb25zLCAoZXJyLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChpcy5uYXRpdmVFcnJvcihlcnIsIHN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobWV0YWRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2Nlc3MgdG8gcGl4ZWwtZGVyaXZlZCBpbWFnZSBzdGF0aXN0aWNzIGZvciBldmVyeSBjaGFubmVsIGluIHRoZSBpbWFnZS5cbiAqIEEgYFByb21pc2VgIGlzIHJldHVybmVkIHdoZW4gYGNhbGxiYWNrYCBpcyBub3QgcHJvdmlkZWQuXG4gKlxuICogLSBgY2hhbm5lbHNgOiBBcnJheSBvZiBjaGFubmVsIHN0YXRpc3RpY3MgZm9yIGVhY2ggY2hhbm5lbCBpbiB0aGUgaW1hZ2UuIEVhY2ggY2hhbm5lbCBzdGF0aXN0aWMgY29udGFpbnNcbiAqICAgICAtIGBtaW5gIChtaW5pbXVtIHZhbHVlIGluIHRoZSBjaGFubmVsKVxuICogICAgIC0gYG1heGAgKG1heGltdW0gdmFsdWUgaW4gdGhlIGNoYW5uZWwpXG4gKiAgICAgLSBgc3VtYCAoc3VtIG9mIGFsbCB2YWx1ZXMgaW4gYSBjaGFubmVsKVxuICogICAgIC0gYHNxdWFyZXNTdW1gIChzdW0gb2Ygc3F1YXJlZCB2YWx1ZXMgaW4gYSBjaGFubmVsKVxuICogICAgIC0gYG1lYW5gIChtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYSBjaGFubmVsKVxuICogICAgIC0gYHN0ZGV2YCAoc3RhbmRhcmQgZGV2aWF0aW9uIGZvciB0aGUgdmFsdWVzIGluIGEgY2hhbm5lbClcbiAqICAgICAtIGBtaW5YYCAoeC1jb29yZGluYXRlIG9mIG9uZSBvZiB0aGUgcGl4ZWwgd2hlcmUgdGhlIG1pbmltdW0gbGllcylcbiAqICAgICAtIGBtaW5ZYCAoeS1jb29yZGluYXRlIG9mIG9uZSBvZiB0aGUgcGl4ZWwgd2hlcmUgdGhlIG1pbmltdW0gbGllcylcbiAqICAgICAtIGBtYXhYYCAoeC1jb29yZGluYXRlIG9mIG9uZSBvZiB0aGUgcGl4ZWwgd2hlcmUgdGhlIG1heGltdW0gbGllcylcbiAqICAgICAtIGBtYXhZYCAoeS1jb29yZGluYXRlIG9mIG9uZSBvZiB0aGUgcGl4ZWwgd2hlcmUgdGhlIG1heGltdW0gbGllcylcbiAqIC0gYGlzT3BhcXVlYDogSXMgdGhlIGltYWdlIGZ1bGx5IG9wYXF1ZT8gV2lsbCBiZSBgdHJ1ZWAgaWYgdGhlIGltYWdlIGhhcyBubyBhbHBoYSBjaGFubmVsIG9yIGlmIGV2ZXJ5IHBpeGVsIGlzIGZ1bGx5IG9wYXF1ZS5cbiAqIC0gYGVudHJvcHlgOiBIaXN0b2dyYW0tYmFzZWQgZXN0aW1hdGlvbiBvZiBncmV5c2NhbGUgZW50cm9weSwgZGlzY2FyZGluZyBhbHBoYSBjaGFubmVsIGlmIGFueS5cbiAqIC0gYHNoYXJwbmVzc2A6IEVzdGltYXRpb24gb2YgZ3JleXNjYWxlIHNoYXJwbmVzcyBiYXNlZCBvbiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGEgTGFwbGFjaWFuIGNvbnZvbHV0aW9uLCBkaXNjYXJkaW5nIGFscGhhIGNoYW5uZWwgaWYgYW55LlxuICogLSBgZG9taW5hbnRgOiBPYmplY3QgY29udGFpbmluZyBtb3N0IGRvbWluYW50IHNSR0IgY29sb3VyIGJhc2VkIG9uIGEgNDA5Ni1iaW4gM0QgaGlzdG9ncmFtLlxuICpcbiAqICoqTm90ZSoqOiBTdGF0aXN0aWNzIGFyZSBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIGlucHV0IGltYWdlLiBBbnkgb3BlcmF0aW9ucyBwZXJmb3JtZWQgb24gdGhlIGltYWdlIG11c3QgZmlyc3QgYmVcbiAqIHdyaXR0ZW4gdG8gYSBidWZmZXIgaW4gb3JkZXIgdG8gcnVuIGBzdGF0c2Agb24gdGhlIHJlc3VsdCAoc2VlIHRoaXJkIGV4YW1wbGUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBpbWFnZSA9IHNoYXJwKGlucHV0SnBnKTtcbiAqIGltYWdlXG4gKiAgIC5zdGF0cygpXG4gKiAgIC50aGVuKGZ1bmN0aW9uKHN0YXRzKSB7XG4gKiAgICAgIC8vIHN0YXRzIGNvbnRhaW5zIHRoZSBjaGFubmVsLXdpc2Ugc3RhdGlzdGljcyBhcnJheSBhbmQgdGhlIGlzT3BhcXVlIHZhbHVlXG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IGVudHJvcHksIHNoYXJwbmVzcywgZG9taW5hbnQgfSA9IGF3YWl0IHNoYXJwKGlucHV0KS5zdGF0cygpO1xuICogY29uc3QgeyByLCBnLCBiIH0gPSBkb21pbmFudDtcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgaW1hZ2UgPSBzaGFycChpbnB1dCk7XG4gKiAvLyBzdG9yZSBpbnRlcm1lZGlhdGUgcmVzdWx0XG4gKiBjb25zdCBwYXJ0ID0gYXdhaXQgaW1hZ2UuZXh0cmFjdChyZWdpb24pLnRvQnVmZmVyKCk7XG4gKiAvLyBjcmVhdGUgbmV3IGluc3RhbmNlIHRvIG9idGFpbiBzdGF0aXN0aWNzIG9mIGV4dHJhY3RlZCByZWdpb25cbiAqIGNvbnN0IHN0YXRzID0gYXdhaXQgc2hhcnAocGFydCkuc3RhdHMoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gY2FsbGVkIHdpdGggdGhlIGFyZ3VtZW50cyBgKGVyciwgc3RhdHMpYFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZnVuY3Rpb24gc3RhdHMgKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHN0YWNrID0gRXJyb3IoKTtcbiAgaWYgKGlzLmZuKGNhbGxiYWNrKSkge1xuICAgIGlmICh0aGlzLl9pc1N0cmVhbUlucHV0KCkpIHtcbiAgICAgIHRoaXMub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZmxhdHRlbkJ1ZmZlckluKCk7XG4gICAgICAgIHNoYXJwLnN0YXRzKHRoaXMub3B0aW9ucywgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhpcy5uYXRpdmVFcnJvcihlcnIsIHN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJwLnN0YXRzKHRoaXMub3B0aW9ucywgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGlzLm5hdGl2ZUVycm9yKGVyciwgc3RhY2spKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5faXNTdHJlYW1JbnB1dCgpKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fZmxhdHRlbkJ1ZmZlckluKCk7XG4gICAgICAgICAgc2hhcnAuc3RhdHModGhpcy5vcHRpb25zLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNoYXJwLnN0YXRzKHRoaXMub3B0aW9ucywgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHN0YXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVjb3JhdGUgdGhlIFNoYXJwIHByb3RvdHlwZSB3aXRoIGlucHV0LXJlbGF0ZWQgZnVuY3Rpb25zLlxuICogQG1vZHVsZSBTaGFycFxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU2hhcnApIHtcbiAgT2JqZWN0LmFzc2lnbihTaGFycC5wcm90b3R5cGUsIHtcbiAgICAvLyBQcml2YXRlXG4gICAgX2lucHV0T3B0aW9uc0Zyb21PYmplY3QsXG4gICAgX2NyZWF0ZUlucHV0RGVzY3JpcHRvcixcbiAgICBfd3JpdGUsXG4gICAgX2ZsYXR0ZW5CdWZmZXJJbixcbiAgICBfaXNTdHJlYW1JbnB1dCxcbiAgICAvLyBQdWJsaWNcbiAgICBtZXRhZGF0YSxcbiAgICBzdGF0c1xuICB9KTtcbiAgLy8gQ2xhc3MgYXR0cmlidXRlc1xuICBTaGFycC5hbGlnbiA9IGFsaWduO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/input.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\n/**\n * Is this value defined and not null?\n * @private\n */\nconst defined = function (val) {\n  return typeof val !== 'undefined' && val !== null;\n};\n\n/**\n * Is this value an object?\n * @private\n */\nconst object = function (val) {\n  return typeof val === 'object';\n};\n\n/**\n * Is this value a plain object?\n * @private\n */\nconst plainObject = function (val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n};\n\n/**\n * Is this value a function?\n * @private\n */\nconst fn = function (val) {\n  return typeof val === 'function';\n};\n\n/**\n * Is this value a boolean?\n * @private\n */\nconst bool = function (val) {\n  return typeof val === 'boolean';\n};\n\n/**\n * Is this value a Buffer object?\n * @private\n */\nconst buffer = function (val) {\n  return val instanceof Buffer;\n};\n\n/**\n * Is this value a typed array object?. E.g. Uint8Array or Uint8ClampedArray?\n * @private\n */\nconst typedArray = function (val) {\n  if (defined(val)) {\n    switch (val.constructor) {\n      case Uint8Array:\n      case Uint8ClampedArray:\n      case Int8Array:\n      case Uint16Array:\n      case Int16Array:\n      case Uint32Array:\n      case Int32Array:\n      case Float32Array:\n      case Float64Array:\n        return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Is this value an ArrayBuffer object?\n * @private\n */\nconst arrayBuffer = function (val) {\n  return val instanceof ArrayBuffer;\n};\n\n/**\n * Is this value a non-empty string?\n * @private\n */\nconst string = function (val) {\n  return typeof val === 'string' && val.length > 0;\n};\n\n/**\n * Is this value a real number?\n * @private\n */\nconst number = function (val) {\n  return typeof val === 'number' && !Number.isNaN(val);\n};\n\n/**\n * Is this value an integer?\n * @private\n */\nconst integer = function (val) {\n  return Number.isInteger(val);\n};\n\n/**\n * Is this value within an inclusive given range?\n * @private\n */\nconst inRange = function (val, min, max) {\n  return val >= min && val <= max;\n};\n\n/**\n * Is this value within the elements of an array?\n * @private\n */\nconst inArray = function (val, list) {\n  return list.includes(val);\n};\n\n/**\n * Create an Error with a message relating to an invalid parameter.\n *\n * @param {string} name - parameter name.\n * @param {string} expected - description of the type/value/range expected.\n * @param {*} actual - the value received.\n * @returns {Error} Containing the formatted message.\n * @private\n */\nconst invalidParameterError = function (name, expected, actual) {\n  return new Error(\n    `Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`\n  );\n};\n\n/**\n * Ensures an Error from C++ contains a JS stack.\n *\n * @param {Error} native - Error with message from C++.\n * @param {Error} context - Error with stack from JS.\n * @returns {Error} Error with message and stack.\n * @private\n */\nconst nativeError = function (native, context) {\n  context.message = native.message;\n  return context;\n};\n\nmodule.exports = {\n  defined,\n  object,\n  plainObject,\n  fn,\n  bool,\n  buffer,\n  typedArray,\n  arrayBuffer,\n  string,\n  number,\n  integer,\n  inRange,\n  inArray,\n  invalidParameterError,\n  nativeError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvaXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsTUFBTSxNQUFNLGVBQWUsUUFBUSxVQUFVLGNBQWM7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoYXJwQDAuMzQuNC9ub2RlX21vZHVsZXMvc2hhcnAvbGliL2lzLmpzPzk5ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMgTG92ZWxsIEZ1bGxlciBhbmQgb3RoZXJzLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIElzIHRoaXMgdmFsdWUgZGVmaW5lZCBhbmQgbm90IG51bGw/XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBkZWZpbmVkID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBJcyB0aGlzIHZhbHVlIGFuIG9iamVjdD9cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG9iamVjdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufTtcblxuLyoqXG4gKiBJcyB0aGlzIHZhbHVlIGEgcGxhaW4gb2JqZWN0P1xuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcGxhaW5PYmplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59O1xuXG4vKipcbiAqIElzIHRoaXMgdmFsdWUgYSBmdW5jdGlvbj9cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGZuID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbi8qKlxuICogSXMgdGhpcyB2YWx1ZSBhIGJvb2xlYW4/XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBib29sID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuLyoqXG4gKiBJcyB0aGlzIHZhbHVlIGEgQnVmZmVyIG9iamVjdD9cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGJ1ZmZlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcjtcbn07XG5cbi8qKlxuICogSXMgdGhpcyB2YWx1ZSBhIHR5cGVkIGFycmF5IG9iamVjdD8uIEUuZy4gVWludDhBcnJheSBvciBVaW50OENsYW1wZWRBcnJheT9cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHR5cGVkQXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmIChkZWZpbmVkKHZhbCkpIHtcbiAgICBzd2l0Y2ggKHZhbC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheTpcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgRmxvYXQ2NEFycmF5OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIElzIHRoaXMgdmFsdWUgYW4gQXJyYXlCdWZmZXIgb2JqZWN0P1xuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5cbi8qKlxuICogSXMgdGhpcyB2YWx1ZSBhIG5vbi1lbXB0eSBzdHJpbmc/XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzdHJpbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogSXMgdGhpcyB2YWx1ZSBhIHJlYWwgbnVtYmVyP1xuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbnVtYmVyID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc05hTih2YWwpO1xufTtcblxuLyoqXG4gKiBJcyB0aGlzIHZhbHVlIGFuIGludGVnZXI/XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpbnRlZ2VyID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWwpO1xufTtcblxuLyoqXG4gKiBJcyB0aGlzIHZhbHVlIHdpdGhpbiBhbiBpbmNsdXNpdmUgZ2l2ZW4gcmFuZ2U/XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpblJhbmdlID0gZnVuY3Rpb24gKHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heDtcbn07XG5cbi8qKlxuICogSXMgdGhpcyB2YWx1ZSB3aXRoaW4gdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5P1xuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaW5BcnJheSA9IGZ1bmN0aW9uICh2YWwsIGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QuaW5jbHVkZXModmFsKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggYSBtZXNzYWdlIHJlbGF0aW5nIHRvIGFuIGludmFsaWQgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gcGFyYW1ldGVyIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgLSBkZXNjcmlwdGlvbiBvZiB0aGUgdHlwZS92YWx1ZS9yYW5nZSBleHBlY3RlZC5cbiAqIEBwYXJhbSB7Kn0gYWN0dWFsIC0gdGhlIHZhbHVlIHJlY2VpdmVkLlxuICogQHJldHVybnMge0Vycm9yfSBDb250YWluaW5nIHRoZSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGludmFsaWRQYXJhbWV0ZXJFcnJvciA9IGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGZvciAke25hbWV9IGJ1dCByZWNlaXZlZCAke2FjdHVhbH0gb2YgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICApO1xufTtcblxuLyoqXG4gKiBFbnN1cmVzIGFuIEVycm9yIGZyb20gQysrIGNvbnRhaW5zIGEgSlMgc3RhY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gbmF0aXZlIC0gRXJyb3Igd2l0aCBtZXNzYWdlIGZyb20gQysrLlxuICogQHBhcmFtIHtFcnJvcn0gY29udGV4dCAtIEVycm9yIHdpdGggc3RhY2sgZnJvbSBKUy5cbiAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3Igd2l0aCBtZXNzYWdlIGFuZCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5hdGl2ZUVycm9yID0gZnVuY3Rpb24gKG5hdGl2ZSwgY29udGV4dCkge1xuICBjb250ZXh0Lm1lc3NhZ2UgPSBuYXRpdmUubWVzc2FnZTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmaW5lZCxcbiAgb2JqZWN0LFxuICBwbGFpbk9iamVjdCxcbiAgZm4sXG4gIGJvb2wsXG4gIGJ1ZmZlcixcbiAgdHlwZWRBcnJheSxcbiAgYXJyYXlCdWZmZXIsXG4gIHN0cmluZyxcbiAgbnVtYmVyLFxuICBpbnRlZ2VyLFxuICBpblJhbmdlLFxuICBpbkFycmF5LFxuICBpbnZhbGlkUGFyYW1ldGVyRXJyb3IsXG4gIG5hdGl2ZUVycm9yXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/libvips.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/libvips.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst { spawnSync } = __webpack_require__(/*! node:child_process */ \"node:child_process\");\nconst { createHash } = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nconst semverCoerce = __webpack_require__(/*! semver/functions/coerce */ \"(rsc)/./node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js\");\nconst semverGreaterThanOrEqualTo = __webpack_require__(/*! semver/functions/gte */ \"(rsc)/./node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js\");\nconst semverSatisfies = __webpack_require__(/*! semver/functions/satisfies */ \"(rsc)/./node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js\");\nconst detectLibc = __webpack_require__(/*! detect-libc */ \"(rsc)/./node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/detect-libc.js\");\n\nconst { config, engines, optionalDependencies } = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/package.json\");\n\nconst minimumLibvipsVersionLabelled = process.env.npm_package_config_libvips || /* istanbul ignore next */\n  config.libvips;\nconst minimumLibvipsVersion = semverCoerce(minimumLibvipsVersionLabelled).version;\n\nconst prebuiltPlatforms = [\n  'darwin-arm64', 'darwin-x64',\n  'linux-arm', 'linux-arm64', 'linux-ppc64', 'linux-s390x', 'linux-x64',\n  'linuxmusl-arm64', 'linuxmusl-x64',\n  'win32-arm64', 'win32-ia32', 'win32-x64'\n];\n\nconst spawnSyncOptions = {\n  encoding: 'utf8',\n  shell: true\n};\n\nconst log = (item) => {\n  if (item instanceof Error) {\n    console.error(`sharp: Installation error: ${item.message}`);\n  } else {\n    console.log(`sharp: ${item}`);\n  }\n};\n\n/* istanbul ignore next */\nconst runtimeLibc = () => detectLibc.isNonGlibcLinuxSync() ? detectLibc.familySync() : '';\n\nconst runtimePlatformArch = () => `${process.platform}${runtimeLibc()}-${process.arch}`;\n\n/* istanbul ignore next */\nconst buildPlatformArch = () => {\n  if (isEmscripten()) {\n    return 'wasm32';\n  }\n  /* eslint camelcase: [\"error\", { allow: [\"^npm_config_\"] }] */\n  const { npm_config_arch, npm_config_platform, npm_config_libc } = process.env;\n  const libc = typeof npm_config_libc === 'string' ? npm_config_libc : runtimeLibc();\n  return `${npm_config_platform || process.platform}${libc}-${npm_config_arch || process.arch}`;\n};\n\nconst buildSharpLibvipsIncludeDir = () => {\n  try {\n    return __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img sync recursive ^\\\\.\\\\/sharp\\\\-libvips\\\\-dev\\\\-.*\\\\/include$\")(`./sharp-libvips-dev-${buildPlatformArch()}/include`);\n  } catch {\n    try {\n      return __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '@img/sharp-libvips-dev/include'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    } catch {}\n  }\n  /* istanbul ignore next */\n  return '';\n};\n\nconst buildSharpLibvipsCPlusPlusDir = () => {\n  try {\n    return __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '@img/sharp-libvips-dev/cplusplus'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n  } catch {}\n  /* istanbul ignore next */\n  return '';\n};\n\nconst buildSharpLibvipsLibDir = () => {\n  try {\n    return __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img sync recursive ^\\\\.\\\\/sharp\\\\-libvips\\\\-dev\\\\-.*\\\\/lib$\")(`./sharp-libvips-dev-${buildPlatformArch()}/lib`);\n  } catch {\n    try {\n      return __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img sync recursive ^\\\\.\\\\/sharp\\\\-libvips\\\\-.*\\\\/lib$\")(`./sharp-libvips-${buildPlatformArch()}/lib`);\n    } catch {}\n  }\n  /* istanbul ignore next */\n  return '';\n};\n\nconst isUnsupportedNodeRuntime = () => {\n  /* istanbul ignore next */\n  if (process.release?.name === 'node' && process.versions) {\n    if (!semverSatisfies(process.versions.node, engines.node)) {\n      return { found: process.versions.node, expected: engines.node };\n    }\n  }\n};\n\n/* istanbul ignore next */\nconst isEmscripten = () => {\n  const { CC } = process.env;\n  return Boolean(CC && CC.endsWith('/emcc'));\n};\n\nconst isRosetta = () => {\n  /* istanbul ignore next */\n  if (process.platform === 'darwin' && process.arch === 'x64') {\n    const translated = spawnSync('sysctl sysctl.proc_translated', spawnSyncOptions).stdout;\n    return (translated || '').trim() === 'sysctl.proc_translated: 1';\n  }\n  return false;\n};\n\nconst sha512 = (s) => createHash('sha512').update(s).digest('hex');\n\nconst yarnLocator = () => {\n  try {\n    const identHash = sha512(`imgsharp-libvips-${buildPlatformArch()}`);\n    const npmVersion = semverCoerce(optionalDependencies[`@img/sharp-libvips-${buildPlatformArch()}`], {\n      includePrerelease: true\n    }).version;\n    return sha512(`${identHash}npm:${npmVersion}`).slice(0, 10);\n  } catch {}\n  return '';\n};\n\n/* istanbul ignore next */\nconst spawnRebuild = () =>\n  spawnSync(`node-gyp rebuild --directory=src ${isEmscripten() ? '--nodedir=emscripten' : ''}`, {\n    ...spawnSyncOptions,\n    stdio: 'inherit'\n  }).status;\n\nconst globalLibvipsVersion = () => {\n  if (process.platform !== 'win32') {\n    const globalLibvipsVersion = spawnSync('pkg-config --modversion vips-cpp', {\n      ...spawnSyncOptions,\n      env: {\n        ...process.env,\n        PKG_CONFIG_PATH: pkgConfigPath()\n      }\n    }).stdout;\n    /* istanbul ignore next */\n    return (globalLibvipsVersion || '').trim();\n  } else {\n    return '';\n  }\n};\n\n/* istanbul ignore next */\nconst pkgConfigPath = () => {\n  if (process.platform !== 'win32') {\n    const brewPkgConfigPath = spawnSync(\n      'which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d\" \" -f2',\n      spawnSyncOptions\n    ).stdout || '';\n    return [\n      brewPkgConfigPath.trim(),\n      process.env.PKG_CONFIG_PATH,\n      '/usr/local/lib/pkgconfig',\n      '/usr/lib/pkgconfig',\n      '/usr/local/libdata/pkgconfig',\n      '/usr/libdata/pkgconfig'\n    ].filter(Boolean).join(':');\n  } else {\n    return '';\n  }\n};\n\nconst skipSearch = (status, reason, logger) => {\n  if (logger) {\n    logger(`Detected ${reason}, skipping search for globally-installed libvips`);\n  }\n  return status;\n};\n\nconst useGlobalLibvips = (logger) => {\n  if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {\n    return skipSearch(false, 'SHARP_IGNORE_GLOBAL_LIBVIPS', logger);\n  }\n  if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {\n    return skipSearch(true, 'SHARP_FORCE_GLOBAL_LIBVIPS', logger);\n  }\n  /* istanbul ignore next */\n  if (isRosetta()) {\n    return skipSearch(false, 'Rosetta', logger);\n  }\n  const globalVipsVersion = globalLibvipsVersion();\n  return !!globalVipsVersion && /* istanbul ignore next */\n    semverGreaterThanOrEqualTo(globalVipsVersion, minimumLibvipsVersion);\n};\n\nmodule.exports = {\n  minimumLibvipsVersion,\n  prebuiltPlatforms,\n  buildPlatformArch,\n  buildSharpLibvipsIncludeDir,\n  buildSharpLibvipsCPlusPlusDir,\n  buildSharpLibvipsLibDir,\n  isUnsupportedNodeRuntime,\n  runtimePlatformArch,\n  log,\n  yarnLocator,\n  spawnRebuild,\n  globalLibvipsVersion,\n  pkgConfigPath,\n  useGlobalLibvips\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvbGlidmlwcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVhOztBQUViLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsOENBQW9CO0FBQ2xELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsZ0hBQXlCO0FBQ3RELG1DQUFtQyxtQkFBTyxDQUFDLDBHQUFzQjtBQUNqRSx3QkFBd0IsbUJBQU8sQ0FBQyxzSEFBNEI7QUFDNUQsbUJBQW1CLG1CQUFPLENBQUMsNkdBQWE7O0FBRXhDLFFBQVEsd0NBQXdDLEVBQUUsbUJBQU8sQ0FBQyxnR0FBaUI7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdELElBQUk7QUFDSiwwQkFBMEIsS0FBSztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLGlCQUFpQixFQUFFLGNBQWMsR0FBRyxhQUFhOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RCxVQUFVLHdEQUF3RDtBQUNsRTtBQUNBLFlBQVksd0NBQXdDLEVBQUUsS0FBSyxHQUFHLGdDQUFnQztBQUM5Rjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw2VkFBUSxxQkFBd0IsRUFBRSxvQkFBb0IsU0FBUyxDQUFDO0FBQzNFLElBQUk7QUFDSjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2SkFBZ0M7QUFDckQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsK0pBQWtDO0FBQ3JELElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcseVZBQVEscUJBQXdCLEVBQUUsb0JBQW9CLEtBQUssQ0FBQztBQUN2RSxJQUFJO0FBQ0o7QUFDQSxhQUFhLG1WQUFRLGlCQUFvQixFQUFFLG9CQUFvQixLQUFLLENBQUM7QUFDckUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsb0JBQW9CO0FBQ3JFLCtFQUErRSxvQkFBb0I7QUFDbkc7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLFVBQVUsTUFBTSxXQUFXO0FBQ2hELElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsNkNBQTZDO0FBQzdGO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoYXJwQDAuMzQuNC9ub2RlX21vZHVsZXMvc2hhcnAvbGliL2xpYnZpcHMuanM/ZTQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMyBMb3ZlbGwgRnVsbGVyIGFuZCBvdGhlcnMuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgc3Bhd25TeW5jIH0gPSByZXF1aXJlKCdub2RlOmNoaWxkX3Byb2Nlc3MnKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKTtcbmNvbnN0IHNlbXZlckNvZXJjZSA9IHJlcXVpcmUoJ3NlbXZlci9mdW5jdGlvbnMvY29lcmNlJyk7XG5jb25zdCBzZW12ZXJHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IHJlcXVpcmUoJ3NlbXZlci9mdW5jdGlvbnMvZ3RlJyk7XG5jb25zdCBzZW12ZXJTYXRpc2ZpZXMgPSByZXF1aXJlKCdzZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcycpO1xuY29uc3QgZGV0ZWN0TGliYyA9IHJlcXVpcmUoJ2RldGVjdC1saWJjJyk7XG5cbmNvbnN0IHsgY29uZmlnLCBlbmdpbmVzLCBvcHRpb25hbERlcGVuZGVuY2llcyB9ID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbmNvbnN0IG1pbmltdW1MaWJ2aXBzVmVyc2lvbkxhYmVsbGVkID0gcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfY29uZmlnX2xpYnZpcHMgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgY29uZmlnLmxpYnZpcHM7XG5jb25zdCBtaW5pbXVtTGlidmlwc1ZlcnNpb24gPSBzZW12ZXJDb2VyY2UobWluaW11bUxpYnZpcHNWZXJzaW9uTGFiZWxsZWQpLnZlcnNpb247XG5cbmNvbnN0IHByZWJ1aWx0UGxhdGZvcm1zID0gW1xuICAnZGFyd2luLWFybTY0JywgJ2Rhcndpbi14NjQnLFxuICAnbGludXgtYXJtJywgJ2xpbnV4LWFybTY0JywgJ2xpbnV4LXBwYzY0JywgJ2xpbnV4LXMzOTB4JywgJ2xpbnV4LXg2NCcsXG4gICdsaW51eG11c2wtYXJtNjQnLCAnbGludXhtdXNsLXg2NCcsXG4gICd3aW4zMi1hcm02NCcsICd3aW4zMi1pYTMyJywgJ3dpbjMyLXg2NCdcbl07XG5cbmNvbnN0IHNwYXduU3luY09wdGlvbnMgPSB7XG4gIGVuY29kaW5nOiAndXRmOCcsXG4gIHNoZWxsOiB0cnVlXG59O1xuXG5jb25zdCBsb2cgPSAoaXRlbSkgPT4ge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgc2hhcnA6IEluc3RhbGxhdGlvbiBlcnJvcjogJHtpdGVtLm1lc3NhZ2V9YCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coYHNoYXJwOiAke2l0ZW19YCk7XG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBydW50aW1lTGliYyA9ICgpID0+IGRldGVjdExpYmMuaXNOb25HbGliY0xpbnV4U3luYygpID8gZGV0ZWN0TGliYy5mYW1pbHlTeW5jKCkgOiAnJztcblxuY29uc3QgcnVudGltZVBsYXRmb3JtQXJjaCA9ICgpID0+IGAke3Byb2Nlc3MucGxhdGZvcm19JHtydW50aW1lTGliYygpfS0ke3Byb2Nlc3MuYXJjaH1gO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgYnVpbGRQbGF0Zm9ybUFyY2ggPSAoKSA9PiB7XG4gIGlmIChpc0Vtc2NyaXB0ZW4oKSkge1xuICAgIHJldHVybiAnd2FzbTMyJztcbiAgfVxuICAvKiBlc2xpbnQgY2FtZWxjYXNlOiBbXCJlcnJvclwiLCB7IGFsbG93OiBbXCJebnBtX2NvbmZpZ19cIl0gfV0gKi9cbiAgY29uc3QgeyBucG1fY29uZmlnX2FyY2gsIG5wbV9jb25maWdfcGxhdGZvcm0sIG5wbV9jb25maWdfbGliYyB9ID0gcHJvY2Vzcy5lbnY7XG4gIGNvbnN0IGxpYmMgPSB0eXBlb2YgbnBtX2NvbmZpZ19saWJjID09PSAnc3RyaW5nJyA/IG5wbV9jb25maWdfbGliYyA6IHJ1bnRpbWVMaWJjKCk7XG4gIHJldHVybiBgJHtucG1fY29uZmlnX3BsYXRmb3JtIHx8IHByb2Nlc3MucGxhdGZvcm19JHtsaWJjfS0ke25wbV9jb25maWdfYXJjaCB8fCBwcm9jZXNzLmFyY2h9YDtcbn07XG5cbmNvbnN0IGJ1aWxkU2hhcnBMaWJ2aXBzSW5jbHVkZURpciA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZShgQGltZy9zaGFycC1saWJ2aXBzLWRldi0ke2J1aWxkUGxhdGZvcm1BcmNoKCl9L2luY2x1ZGVgKTtcbiAgfSBjYXRjaCB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXF1aXJlKCdAaW1nL3NoYXJwLWxpYnZpcHMtZGV2L2luY2x1ZGUnKTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnO1xufTtcblxuY29uc3QgYnVpbGRTaGFycExpYnZpcHNDUGx1c1BsdXNEaXIgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ0BpbWcvc2hhcnAtbGlidmlwcy1kZXYvY3BsdXNwbHVzJyk7XG4gIH0gY2F0Y2gge31cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnO1xufTtcblxuY29uc3QgYnVpbGRTaGFycExpYnZpcHNMaWJEaXIgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoYEBpbWcvc2hhcnAtbGlidmlwcy1kZXYtJHtidWlsZFBsYXRmb3JtQXJjaCgpfS9saWJgKTtcbiAgfSBjYXRjaCB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXF1aXJlKGBAaW1nL3NoYXJwLWxpYnZpcHMtJHtidWlsZFBsYXRmb3JtQXJjaCgpfS9saWJgKTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnO1xufTtcblxuY29uc3QgaXNVbnN1cHBvcnRlZE5vZGVSdW50aW1lID0gKCkgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAocHJvY2Vzcy5yZWxlYXNlPy5uYW1lID09PSAnbm9kZScgJiYgcHJvY2Vzcy52ZXJzaW9ucykge1xuICAgIGlmICghc2VtdmVyU2F0aXNmaWVzKHByb2Nlc3MudmVyc2lvbnMubm9kZSwgZW5naW5lcy5ub2RlKSkge1xuICAgICAgcmV0dXJuIHsgZm91bmQ6IHByb2Nlc3MudmVyc2lvbnMubm9kZSwgZXhwZWN0ZWQ6IGVuZ2luZXMubm9kZSB9O1xuICAgIH1cbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGlzRW1zY3JpcHRlbiA9ICgpID0+IHtcbiAgY29uc3QgeyBDQyB9ID0gcHJvY2Vzcy5lbnY7XG4gIHJldHVybiBCb29sZWFuKENDICYmIENDLmVuZHNXaXRoKCcvZW1jYycpKTtcbn07XG5cbmNvbnN0IGlzUm9zZXR0YSA9ICgpID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nICYmIHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICBjb25zdCB0cmFuc2xhdGVkID0gc3Bhd25TeW5jKCdzeXNjdGwgc3lzY3RsLnByb2NfdHJhbnNsYXRlZCcsIHNwYXduU3luY09wdGlvbnMpLnN0ZG91dDtcbiAgICByZXR1cm4gKHRyYW5zbGF0ZWQgfHwgJycpLnRyaW0oKSA9PT0gJ3N5c2N0bC5wcm9jX3RyYW5zbGF0ZWQ6IDEnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IHNoYTUxMiA9IChzKSA9PiBjcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUocykuZGlnZXN0KCdoZXgnKTtcblxuY29uc3QgeWFybkxvY2F0b3IgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgaWRlbnRIYXNoID0gc2hhNTEyKGBpbWdzaGFycC1saWJ2aXBzLSR7YnVpbGRQbGF0Zm9ybUFyY2goKX1gKTtcbiAgICBjb25zdCBucG1WZXJzaW9uID0gc2VtdmVyQ29lcmNlKG9wdGlvbmFsRGVwZW5kZW5jaWVzW2BAaW1nL3NoYXJwLWxpYnZpcHMtJHtidWlsZFBsYXRmb3JtQXJjaCgpfWBdLCB7XG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZVxuICAgIH0pLnZlcnNpb247XG4gICAgcmV0dXJuIHNoYTUxMihgJHtpZGVudEhhc2h9bnBtOiR7bnBtVmVyc2lvbn1gKS5zbGljZSgwLCAxMCk7XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuICcnO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHNwYXduUmVidWlsZCA9ICgpID0+XG4gIHNwYXduU3luYyhgbm9kZS1neXAgcmVidWlsZCAtLWRpcmVjdG9yeT1zcmMgJHtpc0Vtc2NyaXB0ZW4oKSA/ICctLW5vZGVkaXI9ZW1zY3JpcHRlbicgOiAnJ31gLCB7XG4gICAgLi4uc3Bhd25TeW5jT3B0aW9ucyxcbiAgICBzdGRpbzogJ2luaGVyaXQnXG4gIH0pLnN0YXR1cztcblxuY29uc3QgZ2xvYmFsTGlidmlwc1ZlcnNpb24gPSAoKSA9PiB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgY29uc3QgZ2xvYmFsTGlidmlwc1ZlcnNpb24gPSBzcGF3blN5bmMoJ3BrZy1jb25maWcgLS1tb2R2ZXJzaW9uIHZpcHMtY3BwJywge1xuICAgICAgLi4uc3Bhd25TeW5jT3B0aW9ucyxcbiAgICAgIGVudjoge1xuICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgUEtHX0NPTkZJR19QQVRIOiBwa2dDb25maWdQYXRoKClcbiAgICAgIH1cbiAgICB9KS5zdGRvdXQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gKGdsb2JhbExpYnZpcHNWZXJzaW9uIHx8ICcnKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcGtnQ29uZmlnUGF0aCA9ICgpID0+IHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICBjb25zdCBicmV3UGtnQ29uZmlnUGF0aCA9IHNwYXduU3luYyhcbiAgICAgICd3aGljaCBicmV3ID4vZGV2L251bGwgMj4mMSAmJiBicmV3IGVudmlyb25tZW50IC0tcGxhaW4gfCBncmVwIFBLR19DT05GSUdfTElCRElSIHwgY3V0IC1kXCIgXCIgLWYyJyxcbiAgICAgIHNwYXduU3luY09wdGlvbnNcbiAgICApLnN0ZG91dCB8fCAnJztcbiAgICByZXR1cm4gW1xuICAgICAgYnJld1BrZ0NvbmZpZ1BhdGgudHJpbSgpLFxuICAgICAgcHJvY2Vzcy5lbnYuUEtHX0NPTkZJR19QQVRILFxuICAgICAgJy91c3IvbG9jYWwvbGliL3BrZ2NvbmZpZycsXG4gICAgICAnL3Vzci9saWIvcGtnY29uZmlnJyxcbiAgICAgICcvdXNyL2xvY2FsL2xpYmRhdGEvcGtnY29uZmlnJyxcbiAgICAgICcvdXNyL2xpYmRhdGEvcGtnY29uZmlnJ1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJzonKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbmNvbnN0IHNraXBTZWFyY2ggPSAoc3RhdHVzLCByZWFzb24sIGxvZ2dlcikgPT4ge1xuICBpZiAobG9nZ2VyKSB7XG4gICAgbG9nZ2VyKGBEZXRlY3RlZCAke3JlYXNvbn0sIHNraXBwaW5nIHNlYXJjaCBmb3IgZ2xvYmFsbHktaW5zdGFsbGVkIGxpYnZpcHNgKTtcbiAgfVxuICByZXR1cm4gc3RhdHVzO1xufTtcblxuY29uc3QgdXNlR2xvYmFsTGlidmlwcyA9IChsb2dnZXIpID0+IHtcbiAgaWYgKEJvb2xlYW4ocHJvY2Vzcy5lbnYuU0hBUlBfSUdOT1JFX0dMT0JBTF9MSUJWSVBTKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBza2lwU2VhcmNoKGZhbHNlLCAnU0hBUlBfSUdOT1JFX0dMT0JBTF9MSUJWSVBTJywgbG9nZ2VyKTtcbiAgfVxuICBpZiAoQm9vbGVhbihwcm9jZXNzLmVudi5TSEFSUF9GT1JDRV9HTE9CQUxfTElCVklQUykgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc2tpcFNlYXJjaCh0cnVlLCAnU0hBUlBfRk9SQ0VfR0xPQkFMX0xJQlZJUFMnLCBsb2dnZXIpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChpc1Jvc2V0dGEoKSkge1xuICAgIHJldHVybiBza2lwU2VhcmNoKGZhbHNlLCAnUm9zZXR0YScsIGxvZ2dlcik7XG4gIH1cbiAgY29uc3QgZ2xvYmFsVmlwc1ZlcnNpb24gPSBnbG9iYWxMaWJ2aXBzVmVyc2lvbigpO1xuICByZXR1cm4gISFnbG9iYWxWaXBzVmVyc2lvbiAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHNlbXZlckdyZWF0ZXJUaGFuT3JFcXVhbFRvKGdsb2JhbFZpcHNWZXJzaW9uLCBtaW5pbXVtTGlidmlwc1ZlcnNpb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1pbmltdW1MaWJ2aXBzVmVyc2lvbixcbiAgcHJlYnVpbHRQbGF0Zm9ybXMsXG4gIGJ1aWxkUGxhdGZvcm1BcmNoLFxuICBidWlsZFNoYXJwTGlidmlwc0luY2x1ZGVEaXIsXG4gIGJ1aWxkU2hhcnBMaWJ2aXBzQ1BsdXNQbHVzRGlyLFxuICBidWlsZFNoYXJwTGlidmlwc0xpYkRpcixcbiAgaXNVbnN1cHBvcnRlZE5vZGVSdW50aW1lLFxuICBydW50aW1lUGxhdGZvcm1BcmNoLFxuICBsb2csXG4gIHlhcm5Mb2NhdG9yLFxuICBzcGF3blJlYnVpbGQsXG4gIGdsb2JhbExpYnZpcHNWZXJzaW9uLFxuICBwa2dDb25maWdQYXRoLFxuICB1c2VHbG9iYWxMaWJ2aXBzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/libvips.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/operation.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/operation.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\n\n/**\n * How accurate an operation should be.\n * @member\n * @private\n */\nconst vipsPrecision = {\n  integer: 'integer',\n  float: 'float',\n  approximate: 'approximate'\n};\n\n/**\n * Rotate the output image.\n *\n * The provided angle is converted to a valid positive degree rotation.\n * For example, `-450` will produce a 270 degree rotation.\n *\n * When rotating by an angle other than a multiple of 90,\n * the background colour can be provided with the `background` option.\n *\n * For backwards compatibility, if no angle is provided, `.autoOrient()` will be called.\n *\n * Only one rotation can occur per pipeline (aside from an initial call without\n * arguments to orient via EXIF data). Previous calls to `rotate` in the same\n * pipeline will be ignored.\n *\n * Multi-page images can only be rotated by 180 degrees.\n *\n * Method order is important when rotating, resizing and/or extracting regions,\n * for example `.rotate(x).extract(y)` will produce a different result to `.extract(y).rotate(x)`.\n *\n * @example\n * const rotateThenResize = await sharp(input)\n *   .rotate(90)\n *   .resize({ width: 16, height: 8, fit: 'fill' })\n *   .toBuffer();\n * const resizeThenRotate = await sharp(input)\n *   .resize({ width: 16, height: 8, fit: 'fill' })\n *   .rotate(90)\n *   .toBuffer();\n *\n * @param {number} [angle=auto] angle of rotation.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string|Object} [options.background=\"#000000\"] parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction rotate (angle, options) {\n  if (!is.defined(angle)) {\n    return this.autoOrient();\n  }\n  if (this.options.angle || this.options.rotationAngle) {\n    this.options.debuglog('ignoring previous rotate options');\n    this.options.angle = 0;\n    this.options.rotationAngle = 0;\n  }\n  if (is.integer(angle) && !(angle % 90)) {\n    this.options.angle = angle;\n  } else if (is.number(angle)) {\n    this.options.rotationAngle = angle;\n    if (is.object(options) && options.background) {\n      this._setBackgroundColourOption('rotationBackground', options.background);\n    }\n  } else {\n    throw is.invalidParameterError('angle', 'numeric', angle);\n  }\n  return this;\n}\n\n/**\n * Auto-orient based on the EXIF `Orientation` tag, then remove the tag.\n * Mirroring is supported and may infer the use of a flip operation.\n *\n * Previous or subsequent use of `rotate(angle)` and either `flip()` or `flop()`\n * will logically occur after auto-orientation, regardless of call order.\n *\n * @example\n * const output = await sharp(input).autoOrient().toBuffer();\n *\n * @example\n * const pipeline = sharp()\n *   .autoOrient()\n *   .resize(null, 200)\n *   .toBuffer(function (err, outputBuffer, info) {\n *     // outputBuffer contains 200px high JPEG image data,\n *     // auto-oriented using EXIF Orientation tag\n *     // info.width and info.height contain the dimensions of the resized image\n *   });\n * readableStream.pipe(pipeline);\n *\n * @returns {Sharp}\n */\nfunction autoOrient () {\n  this.options.input.autoOrient = true;\n  return this;\n}\n\n/**\n * Mirror the image vertically (up-down) about the x-axis.\n * This always occurs before rotation, if any.\n *\n * This operation does not work correctly with multi-page images.\n *\n * @example\n * const output = await sharp(input).flip().toBuffer();\n *\n * @param {Boolean} [flip=true]\n * @returns {Sharp}\n */\nfunction flip (flip) {\n  this.options.flip = is.bool(flip) ? flip : true;\n  return this;\n}\n\n/**\n * Mirror the image horizontally (left-right) about the y-axis.\n * This always occurs before rotation, if any.\n *\n * @example\n * const output = await sharp(input).flop().toBuffer();\n *\n * @param {Boolean} [flop=true]\n * @returns {Sharp}\n */\nfunction flop (flop) {\n  this.options.flop = is.bool(flop) ? flop : true;\n  return this;\n}\n\n/**\n * Perform an affine transform on an image. This operation will always occur after resizing, extraction and rotation, if any.\n *\n * You must provide an array of length 4 or a 2x2 affine transformation matrix.\n * By default, new pixels are filled with a black background. You can provide a background colour with the `background` option.\n * A particular interpolator may also be specified. Set the `interpolator` option to an attribute of the `sharp.interpolators` Object e.g. `sharp.interpolators.nohalo`.\n *\n * In the case of a 2x2 matrix, the transform is:\n * - X = `matrix[0, 0]` \\* (x + `idx`) + `matrix[0, 1]` \\* (y + `idy`) + `odx`\n * - Y = `matrix[1, 0]` \\* (x + `idx`) + `matrix[1, 1]` \\* (y + `idy`) + `ody`\n *\n * where:\n * - x and y are the coordinates in input image.\n * - X and Y are the coordinates in output image.\n * - (0,0) is the upper left corner.\n *\n * @since 0.27.0\n *\n * @example\n * const pipeline = sharp()\n *   .affine([[1, 0.3], [0.1, 0.7]], {\n *      background: 'white',\n *      interpolator: sharp.interpolators.nohalo\n *   })\n *   .toBuffer((err, outputBuffer, info) => {\n *      // outputBuffer contains the transformed image\n *      // info.width and info.height contain the new dimensions\n *   });\n *\n * inputStream\n *   .pipe(pipeline);\n *\n * @param {Array<Array<number>>|Array<number>} matrix - affine transformation matrix\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {String|Object} [options.background=\"#000000\"] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Number} [options.idx=0] - input horizontal offset\n * @param {Number} [options.idy=0] - input vertical offset\n * @param {Number} [options.odx=0] - output horizontal offset\n * @param {Number} [options.ody=0] - output vertical offset\n * @param {String} [options.interpolator=sharp.interpolators.bicubic] - interpolator\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction affine (matrix, options) {\n  const flatMatrix = [].concat(...matrix);\n  if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {\n    this.options.affineMatrix = flatMatrix;\n  } else {\n    throw is.invalidParameterError('matrix', '1x4 or 2x2 array', matrix);\n  }\n\n  if (is.defined(options)) {\n    if (is.object(options)) {\n      this._setBackgroundColourOption('affineBackground', options.background);\n      if (is.defined(options.idx)) {\n        if (is.number(options.idx)) {\n          this.options.affineIdx = options.idx;\n        } else {\n          throw is.invalidParameterError('options.idx', 'number', options.idx);\n        }\n      }\n      if (is.defined(options.idy)) {\n        if (is.number(options.idy)) {\n          this.options.affineIdy = options.idy;\n        } else {\n          throw is.invalidParameterError('options.idy', 'number', options.idy);\n        }\n      }\n      if (is.defined(options.odx)) {\n        if (is.number(options.odx)) {\n          this.options.affineOdx = options.odx;\n        } else {\n          throw is.invalidParameterError('options.odx', 'number', options.odx);\n        }\n      }\n      if (is.defined(options.ody)) {\n        if (is.number(options.ody)) {\n          this.options.affineOdy = options.ody;\n        } else {\n          throw is.invalidParameterError('options.ody', 'number', options.ody);\n        }\n      }\n      if (is.defined(options.interpolator)) {\n        if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n          this.options.affineInterpolator = options.interpolator;\n        } else {\n          throw is.invalidParameterError('options.interpolator', 'valid interpolator name', options.interpolator);\n        }\n      }\n    } else {\n      throw is.invalidParameterError('options', 'object', options);\n    }\n  }\n\n  return this;\n}\n\n/**\n * Sharpen the image.\n *\n * When used without parameters, performs a fast, mild sharpen of the output image.\n *\n * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.\n * Fine-grained control over the level of sharpening in \"flat\" (m1) and \"jagged\" (m2) areas is available.\n *\n * See {@link https://www.libvips.org/API/current/libvips-convolution.html#vips-sharpen|libvips sharpen} operation.\n *\n * @example\n * const data = await sharp(input).sharpen().toBuffer();\n *\n * @example\n * const data = await sharp(input).sharpen({ sigma: 2 }).toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .sharpen({\n *     sigma: 2,\n *     m1: 0,\n *     m2: 3,\n *     x1: 3,\n *     y2: 15,\n *     y3: 15,\n *   })\n *   .toBuffer();\n *\n * @param {Object|number} [options] - if present, is an Object with attributes\n * @param {number} [options.sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`, between 0.000001 and 10\n * @param {number} [options.m1=1.0] - the level of sharpening to apply to \"flat\" areas, between 0 and 1000000\n * @param {number} [options.m2=2.0] - the level of sharpening to apply to \"jagged\" areas, between 0 and 1000000\n * @param {number} [options.x1=2.0] - threshold between \"flat\" and \"jagged\", between 0 and 1000000\n * @param {number} [options.y2=10.0] - maximum amount of brightening, between 0 and 1000000\n * @param {number} [options.y3=20.0] - maximum amount of darkening, between 0 and 1000000\n * @param {number} [flat] - (deprecated) see `options.m1`.\n * @param {number} [jagged] - (deprecated) see `options.m2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction sharpen (options, flat, jagged) {\n  if (!is.defined(options)) {\n    // No arguments: default to mild sharpen\n    this.options.sharpenSigma = -1;\n  } else if (is.bool(options)) {\n    // Deprecated boolean argument: apply mild sharpen?\n    this.options.sharpenSigma = options ? -1 : 0;\n  } else if (is.number(options) && is.inRange(options, 0.01, 10000)) {\n    // Deprecated numeric argument: specific sigma\n    this.options.sharpenSigma = options;\n    // Deprecated control over flat areas\n    if (is.defined(flat)) {\n      if (is.number(flat) && is.inRange(flat, 0, 10000)) {\n        this.options.sharpenM1 = flat;\n      } else {\n        throw is.invalidParameterError('flat', 'number between 0 and 10000', flat);\n      }\n    }\n    // Deprecated control over jagged areas\n    if (is.defined(jagged)) {\n      if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {\n        this.options.sharpenM2 = jagged;\n      } else {\n        throw is.invalidParameterError('jagged', 'number between 0 and 10000', jagged);\n      }\n    }\n  } else if (is.plainObject(options)) {\n    if (is.number(options.sigma) && is.inRange(options.sigma, 0.000001, 10)) {\n      this.options.sharpenSigma = options.sigma;\n    } else {\n      throw is.invalidParameterError('options.sigma', 'number between 0.000001 and 10', options.sigma);\n    }\n    if (is.defined(options.m1)) {\n      if (is.number(options.m1) && is.inRange(options.m1, 0, 1000000)) {\n        this.options.sharpenM1 = options.m1;\n      } else {\n        throw is.invalidParameterError('options.m1', 'number between 0 and 1000000', options.m1);\n      }\n    }\n    if (is.defined(options.m2)) {\n      if (is.number(options.m2) && is.inRange(options.m2, 0, 1000000)) {\n        this.options.sharpenM2 = options.m2;\n      } else {\n        throw is.invalidParameterError('options.m2', 'number between 0 and 1000000', options.m2);\n      }\n    }\n    if (is.defined(options.x1)) {\n      if (is.number(options.x1) && is.inRange(options.x1, 0, 1000000)) {\n        this.options.sharpenX1 = options.x1;\n      } else {\n        throw is.invalidParameterError('options.x1', 'number between 0 and 1000000', options.x1);\n      }\n    }\n    if (is.defined(options.y2)) {\n      if (is.number(options.y2) && is.inRange(options.y2, 0, 1000000)) {\n        this.options.sharpenY2 = options.y2;\n      } else {\n        throw is.invalidParameterError('options.y2', 'number between 0 and 1000000', options.y2);\n      }\n    }\n    if (is.defined(options.y3)) {\n      if (is.number(options.y3) && is.inRange(options.y3, 0, 1000000)) {\n        this.options.sharpenY3 = options.y3;\n      } else {\n        throw is.invalidParameterError('options.y3', 'number between 0 and 1000000', options.y3);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.01 and 10000', options);\n  }\n  return this;\n}\n\n/**\n * Apply median filter.\n * When used without parameters the default window is 3x3.\n *\n * @example\n * const output = await sharp(input).median().toBuffer();\n *\n * @example\n * const output = await sharp(input).median(5).toBuffer();\n *\n * @param {number} [size=3] square mask size: size x size\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction median (size) {\n  if (!is.defined(size)) {\n    // No arguments: default to 3x3\n    this.options.medianSize = 3;\n  } else if (is.integer(size) && is.inRange(size, 1, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.medianSize = size;\n  } else {\n    throw is.invalidParameterError('size', 'integer between 1 and 1000', size);\n  }\n  return this;\n}\n\n/**\n * Blur the image.\n *\n * When used without parameters, performs a fast 3x3 box blur (equivalent to a box linear filter).\n *\n * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.\n *\n * @example\n * const boxBlurred = await sharp(input)\n *   .blur()\n *   .toBuffer();\n *\n * @example\n * const gaussianBlurred = await sharp(input)\n *   .blur(5)\n *   .toBuffer();\n *\n * @param {Object|number|Boolean} [options]\n * @param {number} [options.sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @param {string} [options.precision='integer'] How accurate the operation should be, one of: integer, float, approximate.\n * @param {number} [options.minAmplitude=0.2] A value between 0.001 and 1. A smaller value will generate a larger, more accurate mask.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction blur (options) {\n  let sigma;\n  if (is.number(options)) {\n    sigma = options;\n  } else if (is.plainObject(options)) {\n    if (!is.number(options.sigma)) {\n      throw is.invalidParameterError('options.sigma', 'number between 0.3 and 1000', sigma);\n    }\n    sigma = options.sigma;\n    if ('precision' in options) {\n      if (is.string(vipsPrecision[options.precision])) {\n        this.options.precision = vipsPrecision[options.precision];\n      } else {\n        throw is.invalidParameterError('precision', 'one of: integer, float, approximate', options.precision);\n      }\n    }\n    if ('minAmplitude' in options) {\n      if (is.number(options.minAmplitude) && is.inRange(options.minAmplitude, 0.001, 1)) {\n        this.options.minAmpl = options.minAmplitude;\n      } else {\n        throw is.invalidParameterError('minAmplitude', 'number between 0.001 and 1', options.minAmplitude);\n      }\n    }\n  }\n\n  if (!is.defined(options)) {\n    // No arguments: default to mild blur\n    this.options.blurSigma = -1;\n  } else if (is.bool(options)) {\n    // Boolean argument: apply mild blur?\n    this.options.blurSigma = options ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.blurSigma = sigma;\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.3 and 1000', sigma);\n  }\n\n  return this;\n}\n\n/**\n * Expand foreground objects using the dilate morphological operator.\n *\n * @example\n * const output = await sharp(input)\n *   .dilate()\n *   .toBuffer();\n *\n * @param {Number} [width=1] dilation width in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction dilate (width) {\n  if (!is.defined(width)) {\n    this.options.dilateWidth = 1;\n  } else if (is.integer(width) && width > 0) {\n    this.options.dilateWidth = width;\n  } else {\n    throw is.invalidParameterError('dilate', 'positive integer', dilate);\n  }\n  return this;\n}\n\n/**\n * Shrink foreground objects using the erode morphological operator.\n *\n * @example\n * const output = await sharp(input)\n *   .erode()\n *   .toBuffer();\n *\n * @param {Number} [width=1] erosion width in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction erode (width) {\n  if (!is.defined(width)) {\n    this.options.erodeWidth = 1;\n  } else if (is.integer(width) && width > 0) {\n    this.options.erodeWidth = width;\n  } else {\n    throw is.invalidParameterError('erode', 'positive integer', erode);\n  }\n  return this;\n}\n\n/**\n * Merge alpha transparency channel, if any, with a background, then remove the alpha channel.\n *\n * See also {@link /api-channel#removealpha|removeAlpha}.\n *\n * @example\n * await sharp(rgbaInput)\n *   .flatten({ background: '#F0A703' })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {string|Object} [options.background={r: 0, g: 0, b: 0}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black.\n * @returns {Sharp}\n */\nfunction flatten (options) {\n  this.options.flatten = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    this._setBackgroundColourOption('flattenBackground', options.background);\n  }\n  return this;\n}\n\n/**\n * Ensure the image has an alpha channel\n * with all white pixel values made fully transparent.\n *\n * Existing alpha channel values for non-white pixels remain unchanged.\n *\n * This feature is experimental and the API may change.\n *\n * @since 0.32.1\n *\n * @example\n * await sharp(rgbInput)\n *   .unflatten()\n *   .toBuffer();\n *\n * @example\n * await sharp(rgbInput)\n *   .threshold(128, { grayscale: false }) // converter bright pixels to white\n *   .unflatten()\n *   .toBuffer();\n */\nfunction unflatten () {\n  this.options.unflatten = true;\n  return this;\n}\n\n/**\n * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`\n * then increasing the encoding (brighten) post-resize at a factor of `gamma`.\n * This can improve the perceived brightness of a resized image in non-linear colour spaces.\n * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation\n * when applying a gamma correction.\n *\n * Supply a second argument to use a different output gamma value, otherwise the first value is used in both cases.\n *\n * @param {number} [gamma=2.2] value between 1.0 and 3.0.\n * @param {number} [gammaOut] value between 1.0 and 3.0. (optional, defaults to same as `gamma`)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction gamma (gamma, gammaOut) {\n  if (!is.defined(gamma)) {\n    // Default gamma correction of 2.2 (sRGB)\n    this.options.gamma = 2.2;\n  } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {\n    this.options.gamma = gamma;\n  } else {\n    throw is.invalidParameterError('gamma', 'number between 1.0 and 3.0', gamma);\n  }\n  if (!is.defined(gammaOut)) {\n    // Default gamma correction for output is same as input\n    this.options.gammaOut = this.options.gamma;\n  } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {\n    this.options.gammaOut = gammaOut;\n  } else {\n    throw is.invalidParameterError('gammaOut', 'number between 1.0 and 3.0', gammaOut);\n  }\n  return this;\n}\n\n/**\n * Produce the \"negative\" of the image.\n *\n * @example\n * const output = await sharp(input)\n *   .negate()\n *   .toBuffer();\n *\n * @example\n * const output = await sharp(input)\n *   .negate({ alpha: false })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {Boolean} [options.alpha=true] Whether or not to negate any alpha channel\n * @returns {Sharp}\n */\nfunction negate (options) {\n  this.options.negate = is.bool(options) ? options : true;\n  if (is.plainObject(options) && 'alpha' in options) {\n    if (!is.bool(options.alpha)) {\n      throw is.invalidParameterError('alpha', 'should be boolean value', options.alpha);\n    } else {\n      this.options.negateAlpha = options.alpha;\n    }\n  }\n  return this;\n}\n\n/**\n * Enhance output image contrast by stretching its luminance to cover a full dynamic range.\n *\n * Uses a histogram-based approach, taking a default range of 1% to 99% to reduce sensitivity to noise at the extremes.\n *\n * Luminance values below the `lower` percentile will be underexposed by clipping to zero.\n * Luminance values above the `upper` percentile will be overexposed by clipping to the max pixel value.\n *\n * @example\n * const output = await sharp(input)\n *   .normalise()\n *   .toBuffer();\n *\n * @example\n * const output = await sharp(input)\n *   .normalise({ lower: 0, upper: 100 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.\n * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.\n * @returns {Sharp}\n */\nfunction normalise (options) {\n  if (is.plainObject(options)) {\n    if (is.defined(options.lower)) {\n      if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {\n        this.options.normaliseLower = options.lower;\n      } else {\n        throw is.invalidParameterError('lower', 'number between 0 and 99', options.lower);\n      }\n    }\n    if (is.defined(options.upper)) {\n      if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {\n        this.options.normaliseUpper = options.upper;\n      } else {\n        throw is.invalidParameterError('upper', 'number between 1 and 100', options.upper);\n      }\n    }\n  }\n  if (this.options.normaliseLower >= this.options.normaliseUpper) {\n    throw is.invalidParameterError('range', 'lower to be less than upper',\n      `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);\n  }\n  this.options.normalise = true;\n  return this;\n}\n\n/**\n * Alternative spelling of normalise.\n *\n * @example\n * const output = await sharp(input)\n *   .normalize()\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.\n * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.\n * @returns {Sharp}\n */\nfunction normalize (options) {\n  return this.normalise(options);\n}\n\n/**\n * Perform contrast limiting adaptive histogram equalization\n * {@link https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE|CLAHE}.\n *\n * This will, in general, enhance the clarity of the image by bringing out darker details.\n *\n * @since 0.28.3\n *\n * @example\n * const output = await sharp(input)\n *   .clahe({\n *     width: 3,\n *     height: 3,\n *   })\n *   .toBuffer();\n *\n * @param {Object} options\n * @param {number} options.width - Integral width of the search window, in pixels.\n * @param {number} options.height - Integral height of the search window, in pixels.\n * @param {number} [options.maxSlope=3] - Integral level of brightening, between 0 and 100, where 0 disables contrast limiting.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction clahe (options) {\n  if (is.plainObject(options)) {\n    if (is.integer(options.width) && options.width > 0) {\n      this.options.claheWidth = options.width;\n    } else {\n      throw is.invalidParameterError('width', 'integer greater than zero', options.width);\n    }\n    if (is.integer(options.height) && options.height > 0) {\n      this.options.claheHeight = options.height;\n    } else {\n      throw is.invalidParameterError('height', 'integer greater than zero', options.height);\n    }\n    if (is.defined(options.maxSlope)) {\n      if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {\n        this.options.claheMaxSlope = options.maxSlope;\n      } else {\n        throw is.invalidParameterError('maxSlope', 'integer between 0 and 100', options.maxSlope);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  return this;\n}\n\n/**\n * Convolve the image with the specified kernel.\n *\n * @example\n * sharp(input)\n *   .convolve({\n *     width: 3,\n *     height: 3,\n *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n *   })\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data representing the convolution\n *     // of the input image with the horizontal Sobel operator\n *   });\n *\n * @param {Object} kernel\n * @param {number} kernel.width - width of the kernel in pixels.\n * @param {number} kernel.height - height of the kernel in pixels.\n * @param {Array<number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n * @param {number} [kernel.scale=sum] - the scale of the kernel in pixels.\n * @param {number} [kernel.offset=0] - the offset of the kernel in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction convolve (kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) ||\n      !is.integer(kernel.width) || !is.integer(kernel.height) ||\n      !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) ||\n      kernel.height * kernel.width !== kernel.kernel.length\n  ) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  }\n  // Default scale is sum of kernel values\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n  // Clip scale to a minimum value of 1\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n  this.options.convKernel = kernel;\n  return this;\n}\n\n/**\n * Any pixel value greater than or equal to the threshold value will be set to 255, otherwise it will be set to 0.\n * @param {number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.\n * @param {Object} [options]\n * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.\n * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction threshold (threshold, options) {\n  if (!is.defined(threshold)) {\n    this.options.threshold = 128;\n  } else if (is.bool(threshold)) {\n    this.options.threshold = threshold ? 128 : 0;\n  } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {\n    this.options.threshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'integer between 0 and 255', threshold);\n  }\n  if (!is.object(options) || options.greyscale === true || options.grayscale === true) {\n    this.options.thresholdGrayscale = true;\n  } else {\n    this.options.thresholdGrayscale = false;\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation with operand image.\n *\n * This operation creates an output image where each pixel is the result of\n * the selected bitwise boolean `operation` between the corresponding pixels of the input images.\n *\n * @param {Buffer|string} operand - Buffer containing image data or string containing the path to an image file.\n * @param {string} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @param {Object} [options]\n * @param {Object} [options.raw] - describes operand when using raw pixel data.\n * @param {number} [options.raw.width]\n * @param {number} [options.raw.height]\n * @param {number} [options.raw.channels]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction boolean (operand, operator, options) {\n  this.options.boolean = this._createInputDescriptor(operand, options);\n  if (is.string(operator) && is.inArray(operator, ['and', 'or', 'eor'])) {\n    this.options.booleanOp = operator;\n  } else {\n    throw is.invalidParameterError('operator', 'one of: and, or, eor', operator);\n  }\n  return this;\n}\n\n/**\n * Apply the linear formula `a` * input + `b` to the image to adjust image levels.\n *\n * When a single number is provided, it will be used for all image channels.\n * When an array of numbers is provided, the array length must match the number of channels.\n *\n * @example\n * await sharp(input)\n *   .linear(0.5, 2)\n *   .toBuffer();\n *\n * @example\n * await sharp(rgbInput)\n *   .linear(\n *     [0.25, 0.5, 0.75],\n *     [150, 100, 50]\n *   )\n *   .toBuffer();\n *\n * @param {(number|number[])} [a=[]] multiplier\n * @param {(number|number[])} [b=[]] offset\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction linear (a, b) {\n  if (!is.defined(a) && is.number(b)) {\n    a = 1.0;\n  } else if (is.number(a) && !is.defined(b)) {\n    b = 0.0;\n  }\n  if (!is.defined(a)) {\n    this.options.linearA = [];\n  } else if (is.number(a)) {\n    this.options.linearA = [a];\n  } else if (Array.isArray(a) && a.length && a.every(is.number)) {\n    this.options.linearA = a;\n  } else {\n    throw is.invalidParameterError('a', 'number or array of numbers', a);\n  }\n  if (!is.defined(b)) {\n    this.options.linearB = [];\n  } else if (is.number(b)) {\n    this.options.linearB = [b];\n  } else if (Array.isArray(b) && b.length && b.every(is.number)) {\n    this.options.linearB = b;\n  } else {\n    throw is.invalidParameterError('b', 'number or array of numbers', b);\n  }\n  if (this.options.linearA.length !== this.options.linearB.length) {\n    throw new Error('Expected a and b to be arrays of the same length');\n  }\n  return this;\n}\n\n/**\n * Recombine the image with the specified matrix.\n *\n * @since 0.21.1\n *\n * @example\n * sharp(input)\n *   .recomb([\n *    [0.3588, 0.7044, 0.1368],\n *    [0.2990, 0.5870, 0.1140],\n *    [0.2392, 0.4696, 0.0912],\n *   ])\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data after applying the matrix\n *     // With this example input, a sepia filter has been applied\n *   });\n *\n * @param {Array<Array<number>>} inputMatrix - 3x3 or 4x4 Recombination matrix\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction recomb (inputMatrix) {\n  if (!Array.isArray(inputMatrix)) {\n    throw is.invalidParameterError('inputMatrix', 'array', inputMatrix);\n  }\n  if (inputMatrix.length !== 3 && inputMatrix.length !== 4) {\n    throw is.invalidParameterError('inputMatrix', '3x3 or 4x4 array', inputMatrix.length);\n  }\n  const recombMatrix = inputMatrix.flat().map(Number);\n  if (recombMatrix.length !== 9 && recombMatrix.length !== 16) {\n    throw is.invalidParameterError('inputMatrix', 'cardinality of 9 or 16', recombMatrix.length);\n  }\n  this.options.recombMatrix = recombMatrix;\n  return this;\n}\n\n/**\n * Transforms the image using brightness, saturation, hue rotation, and lightness.\n * Brightness and lightness both operate on luminance, with the difference being that\n * brightness is multiplicative whereas lightness is additive.\n *\n * @since 0.22.1\n *\n * @example\n * // increase brightness by a factor of 2\n * const output = await sharp(input)\n *   .modulate({\n *     brightness: 2\n *   })\n *   .toBuffer();\n *\n * @example\n * // hue-rotate by 180 degrees\n * const output = await sharp(input)\n *   .modulate({\n *     hue: 180\n *   })\n *   .toBuffer();\n *\n * @example\n * // increase lightness by +50\n * const output = await sharp(input)\n *   .modulate({\n *     lightness: 50\n *   })\n *   .toBuffer();\n *\n * @example\n * // decrease brightness and saturation while also hue-rotating by 90 degrees\n * const output = await sharp(input)\n *   .modulate({\n *     brightness: 0.5,\n *     saturation: 0.5,\n *     hue: 90,\n *   })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.brightness] Brightness multiplier\n * @param {number} [options.saturation] Saturation multiplier\n * @param {number} [options.hue] Degrees for hue rotation\n * @param {number} [options.lightness] Lightness addend\n * @returns {Sharp}\n */\nfunction modulate (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  if ('brightness' in options) {\n    if (is.number(options.brightness) && options.brightness >= 0) {\n      this.options.brightness = options.brightness;\n    } else {\n      throw is.invalidParameterError('brightness', 'number above zero', options.brightness);\n    }\n  }\n  if ('saturation' in options) {\n    if (is.number(options.saturation) && options.saturation >= 0) {\n      this.options.saturation = options.saturation;\n    } else {\n      throw is.invalidParameterError('saturation', 'number above zero', options.saturation);\n    }\n  }\n  if ('hue' in options) {\n    if (is.integer(options.hue)) {\n      this.options.hue = options.hue % 360;\n    } else {\n      throw is.invalidParameterError('hue', 'number', options.hue);\n    }\n  }\n  if ('lightness' in options) {\n    if (is.number(options.lightness)) {\n      this.options.lightness = options.lightness;\n    } else {\n      throw is.invalidParameterError('lightness', 'number', options.lightness);\n    }\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with operation-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    autoOrient,\n    rotate,\n    flip,\n    flop,\n    affine,\n    sharpen,\n    erode,\n    dilate,\n    median,\n    blur,\n    flatten,\n    unflatten,\n    gamma,\n    negate,\n    normalise,\n    normalize,\n    clahe,\n    convolve,\n    threshold,\n    boolean,\n    linear,\n    recomb,\n    modulate\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGtGQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFD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Q25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoYXJwQDAuMzQuNC9ub2RlX21vZHVsZXMvc2hhcnAvbGliL29wZXJhdGlvbi5qcz84MDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzIExvdmVsbCBGdWxsZXIgYW5kIG90aGVycy5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbi8qKlxuICogSG93IGFjY3VyYXRlIGFuIG9wZXJhdGlvbiBzaG91bGQgYmUuXG4gKiBAbWVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB2aXBzUHJlY2lzaW9uID0ge1xuICBpbnRlZ2VyOiAnaW50ZWdlcicsXG4gIGZsb2F0OiAnZmxvYXQnLFxuICBhcHByb3hpbWF0ZTogJ2FwcHJveGltYXRlJ1xufTtcblxuLyoqXG4gKiBSb3RhdGUgdGhlIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgYW5nbGUgaXMgY29udmVydGVkIHRvIGEgdmFsaWQgcG9zaXRpdmUgZGVncmVlIHJvdGF0aW9uLlxuICogRm9yIGV4YW1wbGUsIGAtNDUwYCB3aWxsIHByb2R1Y2UgYSAyNzAgZGVncmVlIHJvdGF0aW9uLlxuICpcbiAqIFdoZW4gcm90YXRpbmcgYnkgYW4gYW5nbGUgb3RoZXIgdGhhbiBhIG11bHRpcGxlIG9mIDkwLFxuICogdGhlIGJhY2tncm91bmQgY29sb3VyIGNhbiBiZSBwcm92aWRlZCB3aXRoIHRoZSBgYmFja2dyb3VuZGAgb3B0aW9uLlxuICpcbiAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgaWYgbm8gYW5nbGUgaXMgcHJvdmlkZWQsIGAuYXV0b09yaWVudCgpYCB3aWxsIGJlIGNhbGxlZC5cbiAqXG4gKiBPbmx5IG9uZSByb3RhdGlvbiBjYW4gb2NjdXIgcGVyIHBpcGVsaW5lIChhc2lkZSBmcm9tIGFuIGluaXRpYWwgY2FsbCB3aXRob3V0XG4gKiBhcmd1bWVudHMgdG8gb3JpZW50IHZpYSBFWElGIGRhdGEpLiBQcmV2aW91cyBjYWxscyB0byBgcm90YXRlYCBpbiB0aGUgc2FtZVxuICogcGlwZWxpbmUgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIE11bHRpLXBhZ2UgaW1hZ2VzIGNhbiBvbmx5IGJlIHJvdGF0ZWQgYnkgMTgwIGRlZ3JlZXMuXG4gKlxuICogTWV0aG9kIG9yZGVyIGlzIGltcG9ydGFudCB3aGVuIHJvdGF0aW5nLCByZXNpemluZyBhbmQvb3IgZXh0cmFjdGluZyByZWdpb25zLFxuICogZm9yIGV4YW1wbGUgYC5yb3RhdGUoeCkuZXh0cmFjdCh5KWAgd2lsbCBwcm9kdWNlIGEgZGlmZmVyZW50IHJlc3VsdCB0byBgLmV4dHJhY3QoeSkucm90YXRlKHgpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm90YXRlVGhlblJlc2l6ZSA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAucm90YXRlKDkwKVxuICogICAucmVzaXplKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDgsIGZpdDogJ2ZpbGwnIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICogY29uc3QgcmVzaXplVGhlblJvdGF0ZSA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAucmVzaXplKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDgsIGZpdDogJ2ZpbGwnIH0pXG4gKiAgIC5yb3RhdGUoOTApXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYW5nbGU9YXV0b10gYW5nbGUgb2Ygcm90YXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gaWYgcHJlc2VudCwgaXMgYW4gT2JqZWN0IHdpdGggb3B0aW9uYWwgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW29wdGlvbnMuYmFja2dyb3VuZD1cIiMwMDAwMDBcIl0gcGFyc2VkIGJ5IHRoZSBbY29sb3JdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL2NvbG9yKSBtb2R1bGUgdG8gZXh0cmFjdCB2YWx1ZXMgZm9yIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiByb3RhdGUgKGFuZ2xlLCBvcHRpb25zKSB7XG4gIGlmICghaXMuZGVmaW5lZChhbmdsZSkpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRvT3JpZW50KCk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5hbmdsZSB8fCB0aGlzLm9wdGlvbnMucm90YXRpb25BbmdsZSkge1xuICAgIHRoaXMub3B0aW9ucy5kZWJ1Z2xvZygnaWdub3JpbmcgcHJldmlvdXMgcm90YXRlIG9wdGlvbnMnKTtcbiAgICB0aGlzLm9wdGlvbnMuYW5nbGUgPSAwO1xuICAgIHRoaXMub3B0aW9ucy5yb3RhdGlvbkFuZ2xlID0gMDtcbiAgfVxuICBpZiAoaXMuaW50ZWdlcihhbmdsZSkgJiYgIShhbmdsZSAlIDkwKSkge1xuICAgIHRoaXMub3B0aW9ucy5hbmdsZSA9IGFuZ2xlO1xuICB9IGVsc2UgaWYgKGlzLm51bWJlcihhbmdsZSkpIHtcbiAgICB0aGlzLm9wdGlvbnMucm90YXRpb25BbmdsZSA9IGFuZ2xlO1xuICAgIGlmIChpcy5vYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucy5iYWNrZ3JvdW5kKSB7XG4gICAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3VyT3B0aW9uKCdyb3RhdGlvbkJhY2tncm91bmQnLCBvcHRpb25zLmJhY2tncm91bmQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2FuZ2xlJywgJ251bWVyaWMnLCBhbmdsZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQXV0by1vcmllbnQgYmFzZWQgb24gdGhlIEVYSUYgYE9yaWVudGF0aW9uYCB0YWcsIHRoZW4gcmVtb3ZlIHRoZSB0YWcuXG4gKiBNaXJyb3JpbmcgaXMgc3VwcG9ydGVkIGFuZCBtYXkgaW5mZXIgdGhlIHVzZSBvZiBhIGZsaXAgb3BlcmF0aW9uLlxuICpcbiAqIFByZXZpb3VzIG9yIHN1YnNlcXVlbnQgdXNlIG9mIGByb3RhdGUoYW5nbGUpYCBhbmQgZWl0aGVyIGBmbGlwKClgIG9yIGBmbG9wKClgXG4gKiB3aWxsIGxvZ2ljYWxseSBvY2N1ciBhZnRlciBhdXRvLW9yaWVudGF0aW9uLCByZWdhcmRsZXNzIG9mIGNhbGwgb3JkZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNoYXJwKGlucHV0KS5hdXRvT3JpZW50KCkudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcGlwZWxpbmUgPSBzaGFycCgpXG4gKiAgIC5hdXRvT3JpZW50KClcbiAqICAgLnJlc2l6ZShudWxsLCAyMDApXG4gKiAgIC50b0J1ZmZlcihmdW5jdGlvbiAoZXJyLCBvdXRwdXRCdWZmZXIsIGluZm8pIHtcbiAqICAgICAvLyBvdXRwdXRCdWZmZXIgY29udGFpbnMgMjAwcHggaGlnaCBKUEVHIGltYWdlIGRhdGEsXG4gKiAgICAgLy8gYXV0by1vcmllbnRlZCB1c2luZyBFWElGIE9yaWVudGF0aW9uIHRhZ1xuICogICAgIC8vIGluZm8ud2lkdGggYW5kIGluZm8uaGVpZ2h0IGNvbnRhaW4gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHJlc2l6ZWQgaW1hZ2VcbiAqICAgfSk7XG4gKiByZWFkYWJsZVN0cmVhbS5waXBlKHBpcGVsaW5lKTtcbiAqXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIGF1dG9PcmllbnQgKCkge1xuICB0aGlzLm9wdGlvbnMuaW5wdXQuYXV0b09yaWVudCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIE1pcnJvciB0aGUgaW1hZ2UgdmVydGljYWxseSAodXAtZG93bikgYWJvdXQgdGhlIHgtYXhpcy5cbiAqIFRoaXMgYWx3YXlzIG9jY3VycyBiZWZvcmUgcm90YXRpb24sIGlmIGFueS5cbiAqXG4gKiBUaGlzIG9wZXJhdGlvbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSB3aXRoIG11bHRpLXBhZ2UgaW1hZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dCkuZmxpcCgpLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZmxpcD10cnVlXVxuICogQHJldHVybnMge1NoYXJwfVxuICovXG5mdW5jdGlvbiBmbGlwIChmbGlwKSB7XG4gIHRoaXMub3B0aW9ucy5mbGlwID0gaXMuYm9vbChmbGlwKSA/IGZsaXAgOiB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBNaXJyb3IgdGhlIGltYWdlIGhvcml6b250YWxseSAobGVmdC1yaWdodCkgYWJvdXQgdGhlIHktYXhpcy5cbiAqIFRoaXMgYWx3YXlzIG9jY3VycyBiZWZvcmUgcm90YXRpb24sIGlmIGFueS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgc2hhcnAoaW5wdXQpLmZsb3AoKS50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Zsb3A9dHJ1ZV1cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqL1xuZnVuY3Rpb24gZmxvcCAoZmxvcCkge1xuICB0aGlzLm9wdGlvbnMuZmxvcCA9IGlzLmJvb2woZmxvcCkgPyBmbG9wIDogdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhbiBhZmZpbmUgdHJhbnNmb3JtIG9uIGFuIGltYWdlLiBUaGlzIG9wZXJhdGlvbiB3aWxsIGFsd2F5cyBvY2N1ciBhZnRlciByZXNpemluZywgZXh0cmFjdGlvbiBhbmQgcm90YXRpb24sIGlmIGFueS5cbiAqXG4gKiBZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IG9mIGxlbmd0aCA0IG9yIGEgMngyIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gKiBCeSBkZWZhdWx0LCBuZXcgcGl4ZWxzIGFyZSBmaWxsZWQgd2l0aCBhIGJsYWNrIGJhY2tncm91bmQuIFlvdSBjYW4gcHJvdmlkZSBhIGJhY2tncm91bmQgY29sb3VyIHdpdGggdGhlIGBiYWNrZ3JvdW5kYCBvcHRpb24uXG4gKiBBIHBhcnRpY3VsYXIgaW50ZXJwb2xhdG9yIG1heSBhbHNvIGJlIHNwZWNpZmllZC4gU2V0IHRoZSBgaW50ZXJwb2xhdG9yYCBvcHRpb24gdG8gYW4gYXR0cmlidXRlIG9mIHRoZSBgc2hhcnAuaW50ZXJwb2xhdG9yc2AgT2JqZWN0IGUuZy4gYHNoYXJwLmludGVycG9sYXRvcnMubm9oYWxvYC5cbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiBhIDJ4MiBtYXRyaXgsIHRoZSB0cmFuc2Zvcm0gaXM6XG4gKiAtIFggPSBgbWF0cml4WzAsIDBdYCBcXCogKHggKyBgaWR4YCkgKyBgbWF0cml4WzAsIDFdYCBcXCogKHkgKyBgaWR5YCkgKyBgb2R4YFxuICogLSBZID0gYG1hdHJpeFsxLCAwXWAgXFwqICh4ICsgYGlkeGApICsgYG1hdHJpeFsxLCAxXWAgXFwqICh5ICsgYGlkeWApICsgYG9keWBcbiAqXG4gKiB3aGVyZTpcbiAqIC0geCBhbmQgeSBhcmUgdGhlIGNvb3JkaW5hdGVzIGluIGlucHV0IGltYWdlLlxuICogLSBYIGFuZCBZIGFyZSB0aGUgY29vcmRpbmF0ZXMgaW4gb3V0cHV0IGltYWdlLlxuICogLSAoMCwwKSBpcyB0aGUgdXBwZXIgbGVmdCBjb3JuZXIuXG4gKlxuICogQHNpbmNlIDAuMjcuMFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwaXBlbGluZSA9IHNoYXJwKClcbiAqICAgLmFmZmluZShbWzEsIDAuM10sIFswLjEsIDAuN11dLCB7XG4gKiAgICAgIGJhY2tncm91bmQ6ICd3aGl0ZScsXG4gKiAgICAgIGludGVycG9sYXRvcjogc2hhcnAuaW50ZXJwb2xhdG9ycy5ub2hhbG9cbiAqICAgfSlcbiAqICAgLnRvQnVmZmVyKChlcnIsIG91dHB1dEJ1ZmZlciwgaW5mbykgPT4ge1xuICogICAgICAvLyBvdXRwdXRCdWZmZXIgY29udGFpbnMgdGhlIHRyYW5zZm9ybWVkIGltYWdlXG4gKiAgICAgIC8vIGluZm8ud2lkdGggYW5kIGluZm8uaGVpZ2h0IGNvbnRhaW4gdGhlIG5ldyBkaW1lbnNpb25zXG4gKiAgIH0pO1xuICpcbiAqIGlucHV0U3RyZWFtXG4gKiAgIC5waXBlKHBpcGVsaW5lKTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fEFycmF5PG51bWJlcj59IG1hdHJpeCAtIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBpZiBwcmVzZW50LCBpcyBhbiBPYmplY3Qgd2l0aCBvcHRpb25hbCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbb3B0aW9ucy5iYWNrZ3JvdW5kPVwiIzAwMDAwMFwiXSAtIHBhcnNlZCBieSB0aGUgW2NvbG9yXShodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9jb2xvcikgbW9kdWxlIHRvIGV4dHJhY3QgdmFsdWVzIGZvciByZWQsIGdyZWVuLCBibHVlIGFuZCBhbHBoYS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pZHg9MF0gLSBpbnB1dCBob3Jpem9udGFsIG9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmlkeT0wXSAtIGlucHV0IHZlcnRpY2FsIG9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9keD0wXSAtIG91dHB1dCBob3Jpem9udGFsIG9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9keT0wXSAtIG91dHB1dCB2ZXJ0aWNhbCBvZmZzZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnRlcnBvbGF0b3I9c2hhcnAuaW50ZXJwb2xhdG9ycy5iaWN1YmljXSAtIGludGVycG9sYXRvclxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBhZmZpbmUgKG1hdHJpeCwgb3B0aW9ucykge1xuICBjb25zdCBmbGF0TWF0cml4ID0gW10uY29uY2F0KC4uLm1hdHJpeCk7XG4gIGlmIChmbGF0TWF0cml4Lmxlbmd0aCA9PT0gNCAmJiBmbGF0TWF0cml4LmV2ZXJ5KGlzLm51bWJlcikpIHtcbiAgICB0aGlzLm9wdGlvbnMuYWZmaW5lTWF0cml4ID0gZmxhdE1hdHJpeDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ21hdHJpeCcsICcxeDQgb3IgMngyIGFycmF5JywgbWF0cml4KTtcbiAgfVxuXG4gIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG91ck9wdGlvbignYWZmaW5lQmFja2dyb3VuZCcsIG9wdGlvbnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmlkeCkpIHtcbiAgICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLmlkeCkpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWZmaW5lSWR4ID0gb3B0aW9ucy5pZHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zLmlkeCcsICdudW1iZXInLCBvcHRpb25zLmlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuaWR5KSkge1xuICAgICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMuaWR5KSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZmZpbmVJZHkgPSBvcHRpb25zLmlkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wdGlvbnMuaWR5JywgJ251bWJlcicsIG9wdGlvbnMuaWR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5vZHgpKSB7XG4gICAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5vZHgpKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFmZmluZU9keCA9IG9wdGlvbnMub2R4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3B0aW9ucy5vZHgnLCAnbnVtYmVyJywgb3B0aW9ucy5vZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm9keSkpIHtcbiAgICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLm9keSkpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWZmaW5lT2R5ID0gb3B0aW9ucy5vZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zLm9keScsICdudW1iZXInLCBvcHRpb25zLm9keSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuaW50ZXJwb2xhdG9yKSkge1xuICAgICAgICBpZiAoaXMuaW5BcnJheShvcHRpb25zLmludGVycG9sYXRvciwgT2JqZWN0LnZhbHVlcyh0aGlzLmNvbnN0cnVjdG9yLmludGVycG9sYXRvcnMpKSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZmZpbmVJbnRlcnBvbGF0b3IgPSBvcHRpb25zLmludGVycG9sYXRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wdGlvbnMuaW50ZXJwb2xhdG9yJywgJ3ZhbGlkIGludGVycG9sYXRvciBuYW1lJywgb3B0aW9ucy5pbnRlcnBvbGF0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3B0aW9ucycsICdvYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBTaGFycGVuIHRoZSBpbWFnZS5cbiAqXG4gKiBXaGVuIHVzZWQgd2l0aG91dCBwYXJhbWV0ZXJzLCBwZXJmb3JtcyBhIGZhc3QsIG1pbGQgc2hhcnBlbiBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICpcbiAqIFdoZW4gYSBgc2lnbWFgIGlzIHByb3ZpZGVkLCBwZXJmb3JtcyBhIHNsb3dlciwgbW9yZSBhY2N1cmF0ZSBzaGFycGVuIG9mIHRoZSBMIGNoYW5uZWwgaW4gdGhlIExBQiBjb2xvdXIgc3BhY2UuXG4gKiBGaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBsZXZlbCBvZiBzaGFycGVuaW5nIGluIFwiZmxhdFwiIChtMSkgYW5kIFwiamFnZ2VkXCIgKG0yKSBhcmVhcyBpcyBhdmFpbGFibGUuXG4gKlxuICogU2VlIHtAbGluayBodHRwczovL3d3dy5saWJ2aXBzLm9yZy9BUEkvY3VycmVudC9saWJ2aXBzLWNvbnZvbHV0aW9uLmh0bWwjdmlwcy1zaGFycGVufGxpYnZpcHMgc2hhcnBlbn0gb3BlcmF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpLnNoYXJwZW4oKS50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpLnNoYXJwZW4oeyBzaWdtYTogMiB9KS50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5zaGFycGVuKHtcbiAqICAgICBzaWdtYTogMixcbiAqICAgICBtMTogMCxcbiAqICAgICBtMjogMyxcbiAqICAgICB4MTogMyxcbiAqICAgICB5MjogMTUsXG4gKiAgICAgeTM6IDE1LFxuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSAtIGlmIHByZXNlbnQsIGlzIGFuIE9iamVjdCB3aXRoIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zaWdtYV0gLSB0aGUgc2lnbWEgb2YgdGhlIEdhdXNzaWFuIG1hc2ssIHdoZXJlIGBzaWdtYSA9IDEgKyByYWRpdXMgLyAyYCwgYmV0d2VlbiAwLjAwMDAwMSBhbmQgMTBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tMT0xLjBdIC0gdGhlIGxldmVsIG9mIHNoYXJwZW5pbmcgdG8gYXBwbHkgdG8gXCJmbGF0XCIgYXJlYXMsIGJldHdlZW4gMCBhbmQgMTAwMDAwMFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm0yPTIuMF0gLSB0aGUgbGV2ZWwgb2Ygc2hhcnBlbmluZyB0byBhcHBseSB0byBcImphZ2dlZFwiIGFyZWFzLCBiZXR3ZWVuIDAgYW5kIDEwMDAwMDBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy54MT0yLjBdIC0gdGhyZXNob2xkIGJldHdlZW4gXCJmbGF0XCIgYW5kIFwiamFnZ2VkXCIsIGJldHdlZW4gMCBhbmQgMTAwMDAwMFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnkyPTEwLjBdIC0gbWF4aW11bSBhbW91bnQgb2YgYnJpZ2h0ZW5pbmcsIGJldHdlZW4gMCBhbmQgMTAwMDAwMFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnkzPTIwLjBdIC0gbWF4aW11bSBhbW91bnQgb2YgZGFya2VuaW5nLCBiZXR3ZWVuIDAgYW5kIDEwMDAwMDBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZmxhdF0gLSAoZGVwcmVjYXRlZCkgc2VlIGBvcHRpb25zLm0xYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbamFnZ2VkXSAtIChkZXByZWNhdGVkKSBzZWUgYG9wdGlvbnMubTJgLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBzaGFycGVuIChvcHRpb25zLCBmbGF0LCBqYWdnZWQpIHtcbiAgaWYgKCFpcy5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgLy8gTm8gYXJndW1lbnRzOiBkZWZhdWx0IHRvIG1pbGQgc2hhcnBlblxuICAgIHRoaXMub3B0aW9ucy5zaGFycGVuU2lnbWEgPSAtMTtcbiAgfSBlbHNlIGlmIChpcy5ib29sKG9wdGlvbnMpKSB7XG4gICAgLy8gRGVwcmVjYXRlZCBib29sZWFuIGFyZ3VtZW50OiBhcHBseSBtaWxkIHNoYXJwZW4/XG4gICAgdGhpcy5vcHRpb25zLnNoYXJwZW5TaWdtYSA9IG9wdGlvbnMgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaXMubnVtYmVyKG9wdGlvbnMpICYmIGlzLmluUmFuZ2Uob3B0aW9ucywgMC4wMSwgMTAwMDApKSB7XG4gICAgLy8gRGVwcmVjYXRlZCBudW1lcmljIGFyZ3VtZW50OiBzcGVjaWZpYyBzaWdtYVxuICAgIHRoaXMub3B0aW9ucy5zaGFycGVuU2lnbWEgPSBvcHRpb25zO1xuICAgIC8vIERlcHJlY2F0ZWQgY29udHJvbCBvdmVyIGZsYXQgYXJlYXNcbiAgICBpZiAoaXMuZGVmaW5lZChmbGF0KSkge1xuICAgICAgaWYgKGlzLm51bWJlcihmbGF0KSAmJiBpcy5pblJhbmdlKGZsYXQsIDAsIDEwMDAwKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcnBlbk0xID0gZmxhdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZmxhdCcsICdudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAwMCcsIGZsYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXByZWNhdGVkIGNvbnRyb2wgb3ZlciBqYWdnZWQgYXJlYXNcbiAgICBpZiAoaXMuZGVmaW5lZChqYWdnZWQpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKGphZ2dlZCkgJiYgaXMuaW5SYW5nZShqYWdnZWQsIDAsIDEwMDAwKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcnBlbk0yID0gamFnZ2VkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdqYWdnZWQnLCAnbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwMDAnLCBqYWdnZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5zaWdtYSkgJiYgaXMuaW5SYW5nZShvcHRpb25zLnNpZ21hLCAwLjAwMDAwMSwgMTApKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2hhcnBlblNpZ21hID0gb3B0aW9ucy5zaWdtYTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zLnNpZ21hJywgJ251bWJlciBiZXR3ZWVuIDAuMDAwMDAxIGFuZCAxMCcsIG9wdGlvbnMuc2lnbWEpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm0xKSkge1xuICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLm0xKSAmJiBpcy5pblJhbmdlKG9wdGlvbnMubTEsIDAsIDEwMDAwMDApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaGFycGVuTTEgPSBvcHRpb25zLm0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zLm0xJywgJ251bWJlciBiZXR3ZWVuIDAgYW5kIDEwMDAwMDAnLCBvcHRpb25zLm0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5tMikpIHtcbiAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5tMikgJiYgaXMuaW5SYW5nZShvcHRpb25zLm0yLCAwLCAxMDAwMDAwKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcnBlbk0yID0gb3B0aW9ucy5tMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3B0aW9ucy5tMicsICdudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAwMDAwJywgb3B0aW9ucy5tMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMueDEpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMueDEpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy54MSwgMCwgMTAwMDAwMCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNoYXJwZW5YMSA9IG9wdGlvbnMueDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wdGlvbnMueDEnLCAnbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwMDAwMCcsIG9wdGlvbnMueDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnkyKSkge1xuICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLnkyKSAmJiBpcy5pblJhbmdlKG9wdGlvbnMueTIsIDAsIDEwMDAwMDApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaGFycGVuWTIgPSBvcHRpb25zLnkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zLnkyJywgJ251bWJlciBiZXR3ZWVuIDAgYW5kIDEwMDAwMDAnLCBvcHRpb25zLnkyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy55MykpIHtcbiAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy55MykgJiYgaXMuaW5SYW5nZShvcHRpb25zLnkzLCAwLCAxMDAwMDAwKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcnBlblkzID0gb3B0aW9ucy55MztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3B0aW9ucy55MycsICdudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAwMDAwJywgb3B0aW9ucy55Myk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignc2lnbWEnLCAnbnVtYmVyIGJldHdlZW4gMC4wMSBhbmQgMTAwMDAnLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBBcHBseSBtZWRpYW4gZmlsdGVyLlxuICogV2hlbiB1c2VkIHdpdGhvdXQgcGFyYW1ldGVycyB0aGUgZGVmYXVsdCB3aW5kb3cgaXMgM3gzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dCkubWVkaWFuKCkudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgc2hhcnAoaW5wdXQpLm1lZGlhbig1KS50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0zXSBzcXVhcmUgbWFzayBzaXplOiBzaXplIHggc2l6ZVxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBtZWRpYW4gKHNpemUpIHtcbiAgaWYgKCFpcy5kZWZpbmVkKHNpemUpKSB7XG4gICAgLy8gTm8gYXJndW1lbnRzOiBkZWZhdWx0IHRvIDN4M1xuICAgIHRoaXMub3B0aW9ucy5tZWRpYW5TaXplID0gMztcbiAgfSBlbHNlIGlmIChpcy5pbnRlZ2VyKHNpemUpICYmIGlzLmluUmFuZ2Uoc2l6ZSwgMSwgMTAwMCkpIHtcbiAgICAvLyBOdW1lcmljIGFyZ3VtZW50OiBzcGVjaWZpYyBzaWdtYVxuICAgIHRoaXMub3B0aW9ucy5tZWRpYW5TaXplID0gc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3NpemUnLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwMDAnLCBzaXplKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBCbHVyIHRoZSBpbWFnZS5cbiAqXG4gKiBXaGVuIHVzZWQgd2l0aG91dCBwYXJhbWV0ZXJzLCBwZXJmb3JtcyBhIGZhc3QgM3gzIGJveCBibHVyIChlcXVpdmFsZW50IHRvIGEgYm94IGxpbmVhciBmaWx0ZXIpLlxuICpcbiAqIFdoZW4gYSBgc2lnbWFgIGlzIHByb3ZpZGVkLCBwZXJmb3JtcyBhIHNsb3dlciwgbW9yZSBhY2N1cmF0ZSBHYXVzc2lhbiBibHVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBib3hCbHVycmVkID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5ibHVyKClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGdhdXNzaWFuQmx1cnJlZCA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAuYmx1cig1KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ8Qm9vbGVhbn0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2lnbWFdIGEgdmFsdWUgYmV0d2VlbiAwLjMgYW5kIDEwMDAgcmVwcmVzZW50aW5nIHRoZSBzaWdtYSBvZiB0aGUgR2F1c3NpYW4gbWFzaywgd2hlcmUgYHNpZ21hID0gMSArIHJhZGl1cyAvIDJgLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByZWNpc2lvbj0naW50ZWdlciddIEhvdyBhY2N1cmF0ZSB0aGUgb3BlcmF0aW9uIHNob3VsZCBiZSwgb25lIG9mOiBpbnRlZ2VyLCBmbG9hdCwgYXBwcm94aW1hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluQW1wbGl0dWRlPTAuMl0gQSB2YWx1ZSBiZXR3ZWVuIDAuMDAxIGFuZCAxLiBBIHNtYWxsZXIgdmFsdWUgd2lsbCBnZW5lcmF0ZSBhIGxhcmdlciwgbW9yZSBhY2N1cmF0ZSBtYXNrLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBibHVyIChvcHRpb25zKSB7XG4gIGxldCBzaWdtYTtcbiAgaWYgKGlzLm51bWJlcihvcHRpb25zKSkge1xuICAgIHNpZ21hID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGlmICghaXMubnVtYmVyKG9wdGlvbnMuc2lnbWEpKSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wdGlvbnMuc2lnbWEnLCAnbnVtYmVyIGJldHdlZW4gMC4zIGFuZCAxMDAwJywgc2lnbWEpO1xuICAgIH1cbiAgICBzaWdtYSA9IG9wdGlvbnMuc2lnbWE7XG4gICAgaWYgKCdwcmVjaXNpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcodmlwc1ByZWNpc2lvbltvcHRpb25zLnByZWNpc2lvbl0pKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wcmVjaXNpb24gPSB2aXBzUHJlY2lzaW9uW29wdGlvbnMucHJlY2lzaW9uXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncHJlY2lzaW9uJywgJ29uZSBvZjogaW50ZWdlciwgZmxvYXQsIGFwcHJveGltYXRlJywgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ21pbkFtcGxpdHVkZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLm1pbkFtcGxpdHVkZSkgJiYgaXMuaW5SYW5nZShvcHRpb25zLm1pbkFtcGxpdHVkZSwgMC4wMDEsIDEpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5taW5BbXBsID0gb3B0aW9ucy5taW5BbXBsaXR1ZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ21pbkFtcGxpdHVkZScsICdudW1iZXIgYmV0d2VlbiAwLjAwMSBhbmQgMScsIG9wdGlvbnMubWluQW1wbGl0dWRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWlzLmRlZmluZWQob3B0aW9ucykpIHtcbiAgICAvLyBObyBhcmd1bWVudHM6IGRlZmF1bHQgdG8gbWlsZCBibHVyXG4gICAgdGhpcy5vcHRpb25zLmJsdXJTaWdtYSA9IC0xO1xuICB9IGVsc2UgaWYgKGlzLmJvb2wob3B0aW9ucykpIHtcbiAgICAvLyBCb29sZWFuIGFyZ3VtZW50OiBhcHBseSBtaWxkIGJsdXI/XG4gICAgdGhpcy5vcHRpb25zLmJsdXJTaWdtYSA9IG9wdGlvbnMgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaXMubnVtYmVyKHNpZ21hKSAmJiBpcy5pblJhbmdlKHNpZ21hLCAwLjMsIDEwMDApKSB7XG4gICAgLy8gTnVtZXJpYyBhcmd1bWVudDogc3BlY2lmaWMgc2lnbWFcbiAgICB0aGlzLm9wdGlvbnMuYmx1clNpZ21hID0gc2lnbWE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdzaWdtYScsICdudW1iZXIgYmV0d2VlbiAwLjMgYW5kIDEwMDAnLCBzaWdtYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBFeHBhbmQgZm9yZWdyb3VuZCBvYmplY3RzIHVzaW5nIHRoZSBkaWxhdGUgbW9ycGhvbG9naWNhbCBvcGVyYXRvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5kaWxhdGUoKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTFdIGRpbGF0aW9uIHdpZHRoIGluIHBpeGVscy5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gZGlsYXRlICh3aWR0aCkge1xuICBpZiAoIWlzLmRlZmluZWQod2lkdGgpKSB7XG4gICAgdGhpcy5vcHRpb25zLmRpbGF0ZVdpZHRoID0gMTtcbiAgfSBlbHNlIGlmIChpcy5pbnRlZ2VyKHdpZHRoKSAmJiB3aWR0aCA+IDApIHtcbiAgICB0aGlzLm9wdGlvbnMuZGlsYXRlV2lkdGggPSB3aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2RpbGF0ZScsICdwb3NpdGl2ZSBpbnRlZ2VyJywgZGlsYXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBTaHJpbmsgZm9yZWdyb3VuZCBvYmplY3RzIHVzaW5nIHRoZSBlcm9kZSBtb3JwaG9sb2dpY2FsIG9wZXJhdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLmVyb2RlKClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0xXSBlcm9zaW9uIHdpZHRoIGluIHBpeGVscy5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gZXJvZGUgKHdpZHRoKSB7XG4gIGlmICghaXMuZGVmaW5lZCh3aWR0aCkpIHtcbiAgICB0aGlzLm9wdGlvbnMuZXJvZGVXaWR0aCA9IDE7XG4gIH0gZWxzZSBpZiAoaXMuaW50ZWdlcih3aWR0aCkgJiYgd2lkdGggPiAwKSB7XG4gICAgdGhpcy5vcHRpb25zLmVyb2RlV2lkdGggPSB3aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2Vyb2RlJywgJ3Bvc2l0aXZlIGludGVnZXInLCBlcm9kZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogTWVyZ2UgYWxwaGEgdHJhbnNwYXJlbmN5IGNoYW5uZWwsIGlmIGFueSwgd2l0aCBhIGJhY2tncm91bmQsIHRoZW4gcmVtb3ZlIHRoZSBhbHBoYSBjaGFubmVsLlxuICpcbiAqIFNlZSBhbHNvIHtAbGluayAvYXBpLWNoYW5uZWwjcmVtb3ZlYWxwaGF8cmVtb3ZlQWxwaGF9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBzaGFycChyZ2JhSW5wdXQpXG4gKiAgIC5mbGF0dGVuKHsgYmFja2dyb3VuZDogJyNGMEE3MDMnIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW29wdGlvbnMuYmFja2dyb3VuZD17cjogMCwgZzogMCwgYjogMH1dIC0gYmFja2dyb3VuZCBjb2xvdXIsIHBhcnNlZCBieSB0aGUgW2NvbG9yXShodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9jb2xvcikgbW9kdWxlLCBkZWZhdWx0cyB0byBibGFjay5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbiAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMuZmxhdHRlbiA9IGlzLmJvb2wob3B0aW9ucykgPyBvcHRpb25zIDogdHJ1ZTtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvdXJPcHRpb24oJ2ZsYXR0ZW5CYWNrZ3JvdW5kJywgb3B0aW9ucy5iYWNrZ3JvdW5kKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhlIGltYWdlIGhhcyBhbiBhbHBoYSBjaGFubmVsXG4gKiB3aXRoIGFsbCB3aGl0ZSBwaXhlbCB2YWx1ZXMgbWFkZSBmdWxseSB0cmFuc3BhcmVudC5cbiAqXG4gKiBFeGlzdGluZyBhbHBoYSBjaGFubmVsIHZhbHVlcyBmb3Igbm9uLXdoaXRlIHBpeGVscyByZW1haW4gdW5jaGFuZ2VkLlxuICpcbiAqIFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWwgYW5kIHRoZSBBUEkgbWF5IGNoYW5nZS5cbiAqXG4gKiBAc2luY2UgMC4zMi4xXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IHNoYXJwKHJnYklucHV0KVxuICogICAudW5mbGF0dGVuKClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IHNoYXJwKHJnYklucHV0KVxuICogICAudGhyZXNob2xkKDEyOCwgeyBncmF5c2NhbGU6IGZhbHNlIH0pIC8vIGNvbnZlcnRlciBicmlnaHQgcGl4ZWxzIHRvIHdoaXRlXG4gKiAgIC51bmZsYXR0ZW4oKVxuICogICAudG9CdWZmZXIoKTtcbiAqL1xuZnVuY3Rpb24gdW5mbGF0dGVuICgpIHtcbiAgdGhpcy5vcHRpb25zLnVuZmxhdHRlbiA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEFwcGx5IGEgZ2FtbWEgY29ycmVjdGlvbiBieSByZWR1Y2luZyB0aGUgZW5jb2RpbmcgKGRhcmtlbikgcHJlLXJlc2l6ZSBhdCBhIGZhY3RvciBvZiBgMS9nYW1tYWBcbiAqIHRoZW4gaW5jcmVhc2luZyB0aGUgZW5jb2RpbmcgKGJyaWdodGVuKSBwb3N0LXJlc2l6ZSBhdCBhIGZhY3RvciBvZiBgZ2FtbWFgLlxuICogVGhpcyBjYW4gaW1wcm92ZSB0aGUgcGVyY2VpdmVkIGJyaWdodG5lc3Mgb2YgYSByZXNpemVkIGltYWdlIGluIG5vbi1saW5lYXIgY29sb3VyIHNwYWNlcy5cbiAqIEpQRUcgYW5kIFdlYlAgaW5wdXQgaW1hZ2VzIHdpbGwgbm90IHRha2UgYWR2YW50YWdlIG9mIHRoZSBzaHJpbmstb24tbG9hZCBwZXJmb3JtYW5jZSBvcHRpbWlzYXRpb25cbiAqIHdoZW4gYXBwbHlpbmcgYSBnYW1tYSBjb3JyZWN0aW9uLlxuICpcbiAqIFN1cHBseSBhIHNlY29uZCBhcmd1bWVudCB0byB1c2UgYSBkaWZmZXJlbnQgb3V0cHV0IGdhbW1hIHZhbHVlLCBvdGhlcndpc2UgdGhlIGZpcnN0IHZhbHVlIGlzIHVzZWQgaW4gYm90aCBjYXNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2dhbW1hPTIuMl0gdmFsdWUgYmV0d2VlbiAxLjAgYW5kIDMuMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZ2FtbWFPdXRdIHZhbHVlIGJldHdlZW4gMS4wIGFuZCAzLjAuIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gc2FtZSBhcyBgZ2FtbWFgKVxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBnYW1tYSAoZ2FtbWEsIGdhbW1hT3V0KSB7XG4gIGlmICghaXMuZGVmaW5lZChnYW1tYSkpIHtcbiAgICAvLyBEZWZhdWx0IGdhbW1hIGNvcnJlY3Rpb24gb2YgMi4yIChzUkdCKVxuICAgIHRoaXMub3B0aW9ucy5nYW1tYSA9IDIuMjtcbiAgfSBlbHNlIGlmIChpcy5udW1iZXIoZ2FtbWEpICYmIGlzLmluUmFuZ2UoZ2FtbWEsIDEsIDMpKSB7XG4gICAgdGhpcy5vcHRpb25zLmdhbW1hID0gZ2FtbWE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdnYW1tYScsICdudW1iZXIgYmV0d2VlbiAxLjAgYW5kIDMuMCcsIGdhbW1hKTtcbiAgfVxuICBpZiAoIWlzLmRlZmluZWQoZ2FtbWFPdXQpKSB7XG4gICAgLy8gRGVmYXVsdCBnYW1tYSBjb3JyZWN0aW9uIGZvciBvdXRwdXQgaXMgc2FtZSBhcyBpbnB1dFxuICAgIHRoaXMub3B0aW9ucy5nYW1tYU91dCA9IHRoaXMub3B0aW9ucy5nYW1tYTtcbiAgfSBlbHNlIGlmIChpcy5udW1iZXIoZ2FtbWFPdXQpICYmIGlzLmluUmFuZ2UoZ2FtbWFPdXQsIDEsIDMpKSB7XG4gICAgdGhpcy5vcHRpb25zLmdhbW1hT3V0ID0gZ2FtbWFPdXQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdnYW1tYU91dCcsICdudW1iZXIgYmV0d2VlbiAxLjAgYW5kIDMuMCcsIGdhbW1hT3V0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBQcm9kdWNlIHRoZSBcIm5lZ2F0aXZlXCIgb2YgdGhlIGltYWdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLm5lZ2F0ZSgpXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLm5lZ2F0ZSh7IGFscGhhOiBmYWxzZSB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFscGhhPXRydWVdIFdoZXRoZXIgb3Igbm90IHRvIG5lZ2F0ZSBhbnkgYWxwaGEgY2hhbm5lbFxuICogQHJldHVybnMge1NoYXJwfVxuICovXG5mdW5jdGlvbiBuZWdhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zLm5lZ2F0ZSA9IGlzLmJvb2wob3B0aW9ucykgPyBvcHRpb25zIDogdHJ1ZTtcbiAgaWYgKGlzLnBsYWluT2JqZWN0KG9wdGlvbnMpICYmICdhbHBoYScgaW4gb3B0aW9ucykge1xuICAgIGlmICghaXMuYm9vbChvcHRpb25zLmFscGhhKSkge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdhbHBoYScsICdzaG91bGQgYmUgYm9vbGVhbiB2YWx1ZScsIG9wdGlvbnMuYWxwaGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMubmVnYXRlQWxwaGEgPSBvcHRpb25zLmFscGhhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBFbmhhbmNlIG91dHB1dCBpbWFnZSBjb250cmFzdCBieSBzdHJldGNoaW5nIGl0cyBsdW1pbmFuY2UgdG8gY292ZXIgYSBmdWxsIGR5bmFtaWMgcmFuZ2UuXG4gKlxuICogVXNlcyBhIGhpc3RvZ3JhbS1iYXNlZCBhcHByb2FjaCwgdGFraW5nIGEgZGVmYXVsdCByYW5nZSBvZiAxJSB0byA5OSUgdG8gcmVkdWNlIHNlbnNpdGl2aXR5IHRvIG5vaXNlIGF0IHRoZSBleHRyZW1lcy5cbiAqXG4gKiBMdW1pbmFuY2UgdmFsdWVzIGJlbG93IHRoZSBgbG93ZXJgIHBlcmNlbnRpbGUgd2lsbCBiZSB1bmRlcmV4cG9zZWQgYnkgY2xpcHBpbmcgdG8gemVyby5cbiAqIEx1bWluYW5jZSB2YWx1ZXMgYWJvdmUgdGhlIGB1cHBlcmAgcGVyY2VudGlsZSB3aWxsIGJlIG92ZXJleHBvc2VkIGJ5IGNsaXBwaW5nIHRvIHRoZSBtYXggcGl4ZWwgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAubm9ybWFsaXNlKClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAubm9ybWFsaXNlKHsgbG93ZXI6IDAsIHVwcGVyOiAxMDAgfSlcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvd2VyPTFdIC0gUGVyY2VudGlsZSBiZWxvdyB3aGljaCBsdW1pbmFuY2UgdmFsdWVzIHdpbGwgYmUgdW5kZXJleHBvc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnVwcGVyPTk5XSAtIFBlcmNlbnRpbGUgYWJvdmUgd2hpY2ggbHVtaW5hbmNlIHZhbHVlcyB3aWxsIGJlIG92ZXJleHBvc2VkLlxuICogQHJldHVybnMge1NoYXJwfVxuICovXG5mdW5jdGlvbiBub3JtYWxpc2UgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5sb3dlcikpIHtcbiAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5sb3dlcikgJiYgaXMuaW5SYW5nZShvcHRpb25zLmxvd2VyLCAwLCA5OSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5vcm1hbGlzZUxvd2VyID0gb3B0aW9ucy5sb3dlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignbG93ZXInLCAnbnVtYmVyIGJldHdlZW4gMCBhbmQgOTknLCBvcHRpb25zLmxvd2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy51cHBlcikpIHtcbiAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy51cHBlcikgJiYgaXMuaW5SYW5nZShvcHRpb25zLnVwcGVyLCAxLCAxMDApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ub3JtYWxpc2VVcHBlciA9IG9wdGlvbnMudXBwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3VwcGVyJywgJ251bWJlciBiZXR3ZWVuIDEgYW5kIDEwMCcsIG9wdGlvbnMudXBwZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm5vcm1hbGlzZUxvd2VyID49IHRoaXMub3B0aW9ucy5ub3JtYWxpc2VVcHBlcikge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncmFuZ2UnLCAnbG93ZXIgdG8gYmUgbGVzcyB0aGFuIHVwcGVyJyxcbiAgICAgIGAke3RoaXMub3B0aW9ucy5ub3JtYWxpc2VMb3dlcn0gPj0gJHt0aGlzLm9wdGlvbnMubm9ybWFsaXNlVXBwZXJ9YCk7XG4gIH1cbiAgdGhpcy5vcHRpb25zLm5vcm1hbGlzZSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEFsdGVybmF0aXZlIHNwZWxsaW5nIG9mIG5vcm1hbGlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5ub3JtYWxpemUoKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG93ZXI9MV0gLSBQZXJjZW50aWxlIGJlbG93IHdoaWNoIGx1bWluYW5jZSB2YWx1ZXMgd2lsbCBiZSB1bmRlcmV4cG9zZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudXBwZXI9OTldIC0gUGVyY2VudGlsZSBhYm92ZSB3aGljaCBsdW1pbmFuY2UgdmFsdWVzIHdpbGwgYmUgb3ZlcmV4cG9zZWQuXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5ub3JtYWxpc2Uob3B0aW9ucyk7XG59XG5cbi8qKlxuICogUGVyZm9ybSBjb250cmFzdCBsaW1pdGluZyBhZGFwdGl2ZSBoaXN0b2dyYW0gZXF1YWxpemF0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWRhcHRpdmVfaGlzdG9ncmFtX2VxdWFsaXphdGlvbiNDb250cmFzdF9MaW1pdGVkX0FIRXxDTEFIRX0uXG4gKlxuICogVGhpcyB3aWxsLCBpbiBnZW5lcmFsLCBlbmhhbmNlIHRoZSBjbGFyaXR5IG9mIHRoZSBpbWFnZSBieSBicmluZ2luZyBvdXQgZGFya2VyIGRldGFpbHMuXG4gKlxuICogQHNpbmNlIDAuMjguM1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLmNsYWhlKHtcbiAqICAgICB3aWR0aDogMyxcbiAqICAgICBoZWlnaHQ6IDMsXG4gKiAgIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy53aWR0aCAtIEludGVncmFsIHdpZHRoIG9mIHRoZSBzZWFyY2ggd2luZG93LCBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSBJbnRlZ3JhbCBoZWlnaHQgb2YgdGhlIHNlYXJjaCB3aW5kb3csIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTbG9wZT0zXSAtIEludGVncmFsIGxldmVsIG9mIGJyaWdodGVuaW5nLCBiZXR3ZWVuIDAgYW5kIDEwMCwgd2hlcmUgMCBkaXNhYmxlcyBjb250cmFzdCBsaW1pdGluZy5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gY2xhaGUgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy53aWR0aCkgJiYgb3B0aW9ucy53aWR0aCA+IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jbGFoZVdpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd3aWR0aCcsICdpbnRlZ2VyIGdyZWF0ZXIgdGhhbiB6ZXJvJywgb3B0aW9ucy53aWR0aCk7XG4gICAgfVxuICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuaGVpZ2h0KSAmJiBvcHRpb25zLmhlaWdodCA+IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jbGFoZUhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2hlaWdodCcsICdpbnRlZ2VyIGdyZWF0ZXIgdGhhbiB6ZXJvJywgb3B0aW9ucy5oZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm1heFNsb3BlKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5tYXhTbG9wZSkgJiYgaXMuaW5SYW5nZShvcHRpb25zLm1heFNsb3BlLCAwLCAxMDApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jbGFoZU1heFNsb3BlID0gb3B0aW9ucy5tYXhTbG9wZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignbWF4U2xvcGUnLCAnaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDEwMCcsIG9wdGlvbnMubWF4U2xvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wdGlvbnMnLCAncGxhaW4gb2JqZWN0Jywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ29udm9sdmUgdGhlIGltYWdlIHdpdGggdGhlIHNwZWNpZmllZCBrZXJuZWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAuY29udm9sdmUoe1xuICogICAgIHdpZHRoOiAzLFxuICogICAgIGhlaWdodDogMyxcbiAqICAgICBrZXJuZWw6IFstMSwgMCwgMSwgLTIsIDAsIDIsIC0xLCAwLCAxXVxuICogICB9KVxuICogICAucmF3KClcbiAqICAgLnRvQnVmZmVyKGZ1bmN0aW9uKGVyciwgZGF0YSwgaW5mbykge1xuICogICAgIC8vIGRhdGEgY29udGFpbnMgdGhlIHJhdyBwaXhlbCBkYXRhIHJlcHJlc2VudGluZyB0aGUgY29udm9sdXRpb25cbiAqICAgICAvLyBvZiB0aGUgaW5wdXQgaW1hZ2Ugd2l0aCB0aGUgaG9yaXpvbnRhbCBTb2JlbCBvcGVyYXRvclxuICogICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2VybmVsXG4gKiBAcGFyYW0ge251bWJlcn0ga2VybmVsLndpZHRoIC0gd2lkdGggb2YgdGhlIGtlcm5lbCBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0ga2VybmVsLmhlaWdodCAtIGhlaWdodCBvZiB0aGUga2VybmVsIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0ga2VybmVsLmtlcm5lbCAtIEFycmF5IG9mIGxlbmd0aCBgd2lkdGgqaGVpZ2h0YCBjb250YWluaW5nIHRoZSBrZXJuZWwgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtrZXJuZWwuc2NhbGU9c3VtXSAtIHRoZSBzY2FsZSBvZiB0aGUga2VybmVsIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBba2VybmVsLm9mZnNldD0wXSAtIHRoZSBvZmZzZXQgb2YgdGhlIGtlcm5lbCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGNvbnZvbHZlIChrZXJuZWwpIHtcbiAgaWYgKCFpcy5vYmplY3Qoa2VybmVsKSB8fCAhQXJyYXkuaXNBcnJheShrZXJuZWwua2VybmVsKSB8fFxuICAgICAgIWlzLmludGVnZXIoa2VybmVsLndpZHRoKSB8fCAhaXMuaW50ZWdlcihrZXJuZWwuaGVpZ2h0KSB8fFxuICAgICAgIWlzLmluUmFuZ2Uoa2VybmVsLndpZHRoLCAzLCAxMDAxKSB8fCAhaXMuaW5SYW5nZShrZXJuZWwuaGVpZ2h0LCAzLCAxMDAxKSB8fFxuICAgICAga2VybmVsLmhlaWdodCAqIGtlcm5lbC53aWR0aCAhPT0ga2VybmVsLmtlcm5lbC5sZW5ndGhcbiAgKSB7XG4gICAgLy8gbXVzdCBwYXNzIGluIGEga2VybmVsXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnZvbHV0aW9uIGtlcm5lbCcpO1xuICB9XG4gIC8vIERlZmF1bHQgc2NhbGUgaXMgc3VtIG9mIGtlcm5lbCB2YWx1ZXNcbiAgaWYgKCFpcy5pbnRlZ2VyKGtlcm5lbC5zY2FsZSkpIHtcbiAgICBrZXJuZWwuc2NhbGUgPSBrZXJuZWwua2VybmVsLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH0sIDApO1xuICB9XG4gIC8vIENsaXAgc2NhbGUgdG8gYSBtaW5pbXVtIHZhbHVlIG9mIDFcbiAgaWYgKGtlcm5lbC5zY2FsZSA8IDEpIHtcbiAgICBrZXJuZWwuc2NhbGUgPSAxO1xuICB9XG4gIGlmICghaXMuaW50ZWdlcihrZXJuZWwub2Zmc2V0KSkge1xuICAgIGtlcm5lbC5vZmZzZXQgPSAwO1xuICB9XG4gIHRoaXMub3B0aW9ucy5jb252S2VybmVsID0ga2VybmVsO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBBbnkgcGl4ZWwgdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0aHJlc2hvbGQgdmFsdWUgd2lsbCBiZSBzZXQgdG8gMjU1LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBzZXQgdG8gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGhyZXNob2xkPTEyOF0gLSBhIHZhbHVlIGluIHRoZSByYW5nZSAwLTI1NSByZXByZXNlbnRpbmcgdGhlIGxldmVsIGF0IHdoaWNoIHRoZSB0aHJlc2hvbGQgd2lsbCBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ncmV5c2NhbGU9dHJ1ZV0gLSBjb252ZXJ0IHRvIHNpbmdsZSBjaGFubmVsIGdyZXlzY2FsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ3JheXNjYWxlPXRydWVdIC0gYWx0ZXJuYXRpdmUgc3BlbGxpbmcgZm9yIGdyZXlzY2FsZS5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gdGhyZXNob2xkICh0aHJlc2hvbGQsIG9wdGlvbnMpIHtcbiAgaWYgKCFpcy5kZWZpbmVkKHRocmVzaG9sZCkpIHtcbiAgICB0aGlzLm9wdGlvbnMudGhyZXNob2xkID0gMTI4O1xuICB9IGVsc2UgaWYgKGlzLmJvb2wodGhyZXNob2xkKSkge1xuICAgIHRoaXMub3B0aW9ucy50aHJlc2hvbGQgPSB0aHJlc2hvbGQgPyAxMjggOiAwO1xuICB9IGVsc2UgaWYgKGlzLmludGVnZXIodGhyZXNob2xkKSAmJiBpcy5pblJhbmdlKHRocmVzaG9sZCwgMCwgMjU1KSkge1xuICAgIHRoaXMub3B0aW9ucy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd0aHJlc2hvbGQnLCAnaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDI1NScsIHRocmVzaG9sZCk7XG4gIH1cbiAgaWYgKCFpcy5vYmplY3Qob3B0aW9ucykgfHwgb3B0aW9ucy5ncmV5c2NhbGUgPT09IHRydWUgfHwgb3B0aW9ucy5ncmF5c2NhbGUgPT09IHRydWUpIHtcbiAgICB0aGlzLm9wdGlvbnMudGhyZXNob2xkR3JheXNjYWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMudGhyZXNob2xkR3JheXNjYWxlID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGJpdHdpc2UgYm9vbGVhbiBvcGVyYXRpb24gd2l0aCBvcGVyYW5kIGltYWdlLlxuICpcbiAqIFRoaXMgb3BlcmF0aW9uIGNyZWF0ZXMgYW4gb3V0cHV0IGltYWdlIHdoZXJlIGVhY2ggcGl4ZWwgaXMgdGhlIHJlc3VsdCBvZlxuICogdGhlIHNlbGVjdGVkIGJpdHdpc2UgYm9vbGVhbiBgb3BlcmF0aW9uYCBiZXR3ZWVuIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVscyBvZiB0aGUgaW5wdXQgaW1hZ2VzLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gb3BlcmFuZCAtIEJ1ZmZlciBjb250YWluaW5nIGltYWdlIGRhdGEgb3Igc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHBhdGggdG8gYW4gaW1hZ2UgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciAtIG9uZSBvZiBgYW5kYCwgYG9yYCBvciBgZW9yYCB0byBwZXJmb3JtIHRoYXQgYml0d2lzZSBvcGVyYXRpb24sIGxpa2UgdGhlIEMgbG9naWMgb3BlcmF0b3JzIGAmYCwgYHxgIGFuZCBgXmAgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJhd10gLSBkZXNjcmliZXMgb3BlcmFuZCB3aGVuIHVzaW5nIHJhdyBwaXhlbCBkYXRhLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhdy53aWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYXcuaGVpZ2h0XVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhdy5jaGFubmVsc11cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gYm9vbGVhbiAob3BlcmFuZCwgb3BlcmF0b3IsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zLmJvb2xlYW4gPSB0aGlzLl9jcmVhdGVJbnB1dERlc2NyaXB0b3Iob3BlcmFuZCwgb3B0aW9ucyk7XG4gIGlmIChpcy5zdHJpbmcob3BlcmF0b3IpICYmIGlzLmluQXJyYXkob3BlcmF0b3IsIFsnYW5kJywgJ29yJywgJ2VvciddKSkge1xuICAgIHRoaXMub3B0aW9ucy5ib29sZWFuT3AgPSBvcGVyYXRvcjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wZXJhdG9yJywgJ29uZSBvZjogYW5kLCBvciwgZW9yJywgb3BlcmF0b3IpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEFwcGx5IHRoZSBsaW5lYXIgZm9ybXVsYSBgYWAgKiBpbnB1dCArIGBiYCB0byB0aGUgaW1hZ2UgdG8gYWRqdXN0IGltYWdlIGxldmVscy5cbiAqXG4gKiBXaGVuIGEgc2luZ2xlIG51bWJlciBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIGZvciBhbGwgaW1hZ2UgY2hhbm5lbHMuXG4gKiBXaGVuIGFuIGFycmF5IG9mIG51bWJlcnMgaXMgcHJvdmlkZWQsIHRoZSBhcnJheSBsZW5ndGggbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLmxpbmVhcigwLjUsIDIpXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBzaGFycChyZ2JJbnB1dClcbiAqICAgLmxpbmVhcihcbiAqICAgICBbMC4yNSwgMC41LCAwLjc1XSxcbiAqICAgICBbMTUwLCAxMDAsIDUwXVxuICogICApXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7KG51bWJlcnxudW1iZXJbXSl9IFthPVtdXSBtdWx0aXBsaWVyXG4gKiBAcGFyYW0geyhudW1iZXJ8bnVtYmVyW10pfSBbYj1bXV0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGxpbmVhciAoYSwgYikge1xuICBpZiAoIWlzLmRlZmluZWQoYSkgJiYgaXMubnVtYmVyKGIpKSB7XG4gICAgYSA9IDEuMDtcbiAgfSBlbHNlIGlmIChpcy5udW1iZXIoYSkgJiYgIWlzLmRlZmluZWQoYikpIHtcbiAgICBiID0gMC4wO1xuICB9XG4gIGlmICghaXMuZGVmaW5lZChhKSkge1xuICAgIHRoaXMub3B0aW9ucy5saW5lYXJBID0gW107XG4gIH0gZWxzZSBpZiAoaXMubnVtYmVyKGEpKSB7XG4gICAgdGhpcy5vcHRpb25zLmxpbmVhckEgPSBbYV07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBhLmxlbmd0aCAmJiBhLmV2ZXJ5KGlzLm51bWJlcikpIHtcbiAgICB0aGlzLm9wdGlvbnMubGluZWFyQSA9IGE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdhJywgJ251bWJlciBvciBhcnJheSBvZiBudW1iZXJzJywgYSk7XG4gIH1cbiAgaWYgKCFpcy5kZWZpbmVkKGIpKSB7XG4gICAgdGhpcy5vcHRpb25zLmxpbmVhckIgPSBbXTtcbiAgfSBlbHNlIGlmIChpcy5udW1iZXIoYikpIHtcbiAgICB0aGlzLm9wdGlvbnMubGluZWFyQiA9IFtiXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGIpICYmIGIubGVuZ3RoICYmIGIuZXZlcnkoaXMubnVtYmVyKSkge1xuICAgIHRoaXMub3B0aW9ucy5saW5lYXJCID0gYjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2InLCAnbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnMnLCBiKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmxpbmVhckEubGVuZ3RoICE9PSB0aGlzLm9wdGlvbnMubGluZWFyQi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgYW5kIGIgdG8gYmUgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJlY29tYmluZSB0aGUgaW1hZ2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG1hdHJpeC5cbiAqXG4gKiBAc2luY2UgMC4yMS4xXG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAucmVjb21iKFtcbiAqICAgIFswLjM1ODgsIDAuNzA0NCwgMC4xMzY4XSxcbiAqICAgIFswLjI5OTAsIDAuNTg3MCwgMC4xMTQwXSxcbiAqICAgIFswLjIzOTIsIDAuNDY5NiwgMC4wOTEyXSxcbiAqICAgXSlcbiAqICAgLnJhdygpXG4gKiAgIC50b0J1ZmZlcihmdW5jdGlvbihlcnIsIGRhdGEsIGluZm8pIHtcbiAqICAgICAvLyBkYXRhIGNvbnRhaW5zIHRoZSByYXcgcGl4ZWwgZGF0YSBhZnRlciBhcHBseWluZyB0aGUgbWF0cml4XG4gKiAgICAgLy8gV2l0aCB0aGlzIGV4YW1wbGUgaW5wdXQsIGEgc2VwaWEgZmlsdGVyIGhhcyBiZWVuIGFwcGxpZWRcbiAqICAgfSk7XG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gaW5wdXRNYXRyaXggLSAzeDMgb3IgNHg0IFJlY29tYmluYXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlY29tYiAoaW5wdXRNYXRyaXgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0TWF0cml4KSkge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignaW5wdXRNYXRyaXgnLCAnYXJyYXknLCBpbnB1dE1hdHJpeCk7XG4gIH1cbiAgaWYgKGlucHV0TWF0cml4Lmxlbmd0aCAhPT0gMyAmJiBpbnB1dE1hdHJpeC5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2lucHV0TWF0cml4JywgJzN4MyBvciA0eDQgYXJyYXknLCBpbnB1dE1hdHJpeC5sZW5ndGgpO1xuICB9XG4gIGNvbnN0IHJlY29tYk1hdHJpeCA9IGlucHV0TWF0cml4LmZsYXQoKS5tYXAoTnVtYmVyKTtcbiAgaWYgKHJlY29tYk1hdHJpeC5sZW5ndGggIT09IDkgJiYgcmVjb21iTWF0cml4Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2lucHV0TWF0cml4JywgJ2NhcmRpbmFsaXR5IG9mIDkgb3IgMTYnLCByZWNvbWJNYXRyaXgubGVuZ3RoKTtcbiAgfVxuICB0aGlzLm9wdGlvbnMucmVjb21iTWF0cml4ID0gcmVjb21iTWF0cml4O1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBpbWFnZSB1c2luZyBicmlnaHRuZXNzLCBzYXR1cmF0aW9uLCBodWUgcm90YXRpb24sIGFuZCBsaWdodG5lc3MuXG4gKiBCcmlnaHRuZXNzIGFuZCBsaWdodG5lc3MgYm90aCBvcGVyYXRlIG9uIGx1bWluYW5jZSwgd2l0aCB0aGUgZGlmZmVyZW5jZSBiZWluZyB0aGF0XG4gKiBicmlnaHRuZXNzIGlzIG11bHRpcGxpY2F0aXZlIHdoZXJlYXMgbGlnaHRuZXNzIGlzIGFkZGl0aXZlLlxuICpcbiAqIEBzaW5jZSAwLjIyLjFcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gaW5jcmVhc2UgYnJpZ2h0bmVzcyBieSBhIGZhY3RvciBvZiAyXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLm1vZHVsYXRlKHtcbiAqICAgICBicmlnaHRuZXNzOiAyXG4gKiAgIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBodWUtcm90YXRlIGJ5IDE4MCBkZWdyZWVzXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLm1vZHVsYXRlKHtcbiAqICAgICBodWU6IDE4MFxuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gaW5jcmVhc2UgbGlnaHRuZXNzIGJ5ICs1MFxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5tb2R1bGF0ZSh7XG4gKiAgICAgbGlnaHRuZXNzOiA1MFxuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gZGVjcmVhc2UgYnJpZ2h0bmVzcyBhbmQgc2F0dXJhdGlvbiB3aGlsZSBhbHNvIGh1ZS1yb3RhdGluZyBieSA5MCBkZWdyZWVzXG4gKiBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLm1vZHVsYXRlKHtcbiAqICAgICBicmlnaHRuZXNzOiAwLjUsXG4gKiAgICAgc2F0dXJhdGlvbjogMC41LFxuICogICAgIGh1ZTogOTAsXG4gKiAgIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5icmlnaHRuZXNzXSBCcmlnaHRuZXNzIG11bHRpcGxpZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zYXR1cmF0aW9uXSBTYXR1cmF0aW9uIG11bHRpcGxpZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5odWVdIERlZ3JlZXMgZm9yIGh1ZSByb3RhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpZ2h0bmVzc10gTGlnaHRuZXNzIGFkZGVuZFxuICogQHJldHVybnMge1NoYXJwfVxuICovXG5mdW5jdGlvbiBtb2R1bGF0ZSAob3B0aW9ucykge1xuICBpZiAoIWlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zJywgJ3BsYWluIG9iamVjdCcsIG9wdGlvbnMpO1xuICB9XG4gIGlmICgnYnJpZ2h0bmVzcycgaW4gb3B0aW9ucykge1xuICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5icmlnaHRuZXNzKSAmJiBvcHRpb25zLmJyaWdodG5lc3MgPj0gMCkge1xuICAgICAgdGhpcy5vcHRpb25zLmJyaWdodG5lc3MgPSBvcHRpb25zLmJyaWdodG5lc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignYnJpZ2h0bmVzcycsICdudW1iZXIgYWJvdmUgemVybycsIG9wdGlvbnMuYnJpZ2h0bmVzcyk7XG4gICAgfVxuICB9XG4gIGlmICgnc2F0dXJhdGlvbicgaW4gb3B0aW9ucykge1xuICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5zYXR1cmF0aW9uKSAmJiBvcHRpb25zLnNhdHVyYXRpb24gPj0gMCkge1xuICAgICAgdGhpcy5vcHRpb25zLnNhdHVyYXRpb24gPSBvcHRpb25zLnNhdHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignc2F0dXJhdGlvbicsICdudW1iZXIgYWJvdmUgemVybycsIG9wdGlvbnMuc2F0dXJhdGlvbik7XG4gICAgfVxuICB9XG4gIGlmICgnaHVlJyBpbiBvcHRpb25zKSB7XG4gICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5odWUpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaHVlID0gb3B0aW9ucy5odWUgJSAzNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignaHVlJywgJ251bWJlcicsIG9wdGlvbnMuaHVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKCdsaWdodG5lc3MnIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMubGlnaHRuZXNzKSkge1xuICAgICAgdGhpcy5vcHRpb25zLmxpZ2h0bmVzcyA9IG9wdGlvbnMubGlnaHRuZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2xpZ2h0bmVzcycsICdudW1iZXInLCBvcHRpb25zLmxpZ2h0bmVzcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIERlY29yYXRlIHRoZSBTaGFycCBwcm90b3R5cGUgd2l0aCBvcGVyYXRpb24tcmVsYXRlZCBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlIFNoYXJwXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTaGFycCkge1xuICBPYmplY3QuYXNzaWduKFNoYXJwLnByb3RvdHlwZSwge1xuICAgIGF1dG9PcmllbnQsXG4gICAgcm90YXRlLFxuICAgIGZsaXAsXG4gICAgZmxvcCxcbiAgICBhZmZpbmUsXG4gICAgc2hhcnBlbixcbiAgICBlcm9kZSxcbiAgICBkaWxhdGUsXG4gICAgbWVkaWFuLFxuICAgIGJsdXIsXG4gICAgZmxhdHRlbixcbiAgICB1bmZsYXR0ZW4sXG4gICAgZ2FtbWEsXG4gICAgbmVnYXRlLFxuICAgIG5vcm1hbGlzZSxcbiAgICBub3JtYWxpemUsXG4gICAgY2xhaGUsXG4gICAgY29udm9sdmUsXG4gICAgdGhyZXNob2xkLFxuICAgIGJvb2xlYW4sXG4gICAgbGluZWFyLFxuICAgIHJlY29tYixcbiAgICBtb2R1bGF0ZVxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/operation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/output.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/output.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst path = __webpack_require__(/*! node:path */ \"node:path\");\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\nconst sharp = __webpack_require__(/*! ./sharp */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js\");\n\nconst formats = new Map([\n  ['heic', 'heif'],\n  ['heif', 'heif'],\n  ['avif', 'avif'],\n  ['jpeg', 'jpeg'],\n  ['jpg', 'jpeg'],\n  ['jpe', 'jpeg'],\n  ['tile', 'tile'],\n  ['dz', 'tile'],\n  ['png', 'png'],\n  ['raw', 'raw'],\n  ['tiff', 'tiff'],\n  ['tif', 'tiff'],\n  ['webp', 'webp'],\n  ['gif', 'gif'],\n  ['jp2', 'jp2'],\n  ['jpx', 'jp2'],\n  ['j2k', 'jp2'],\n  ['j2c', 'jp2'],\n  ['jxl', 'jxl']\n]);\n\nconst jp2Regex = /\\.(jp[2x]|j2[kc])$/i;\n\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\n\nconst bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * Animated output will also contain `pageHeight` and `pages`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(path.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    const stack = Error();\n    return this._pipeline(callback, stack);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * Animated output will also contain `pageHeight` and `pages`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  const stack = Error();\n  return this._pipeline(is.fn(options) ? options : callback, stack);\n}\n\n/**\n * Keep all EXIF metadata from the input image in the output image.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithExif = await sharp(inputWithExif)\n *   .keepExif()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepExif () {\n  this.options.keepMetadata |= 0b00001;\n  return this;\n}\n\n/**\n * Set EXIF metadata in the output image, ignoring any EXIF in the input image.\n *\n * @since 0.33.0\n *\n * @example\n * const dataWithExif = await sharp(input)\n *   .withExif({\n *     IFD0: {\n *       Copyright: 'The National Gallery'\n *     },\n *     IFD3: {\n *       GPSLatitudeRef: 'N',\n *       GPSLatitude: '51/1 30/1 3230/100',\n *       GPSLongitudeRef: 'W',\n *       GPSLongitude: '0/1 7/1 4366/100'\n *     }\n *   })\n *   .toBuffer();\n *\n * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withExif (exif) {\n  if (is.object(exif)) {\n    for (const [ifd, entries] of Object.entries(exif)) {\n      if (is.object(entries)) {\n        for (const [k, v] of Object.entries(entries)) {\n          if (is.string(v)) {\n            this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;\n          } else {\n            throw is.invalidParameterError(`${ifd}.${k}`, 'string', v);\n          }\n        }\n      } else {\n        throw is.invalidParameterError(ifd, 'object', entries);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('exif', 'object', exif);\n  }\n  this.options.withExifMerge = false;\n  return this.keepExif();\n}\n\n/**\n * Update EXIF metadata from the input image in the output image.\n *\n * @since 0.33.0\n *\n * @example\n * const dataWithMergedExif = await sharp(inputWithExif)\n *   .withExifMerge({\n *     IFD0: {\n *       Copyright: 'The National Gallery'\n *     }\n *   })\n *   .toBuffer();\n *\n * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withExifMerge (exif) {\n  this.withExif(exif);\n  this.options.withExifMerge = true;\n  return this;\n}\n\n/**\n * Keep ICC profile from the input image in the output image.\n *\n * Where necessary, will attempt to convert the output colour space to match the profile.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithIccProfile = await sharp(inputWithIccProfile)\n *   .keepIccProfile()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepIccProfile () {\n  this.options.keepMetadata |= 0b01000;\n  return this;\n}\n\n/**\n * Transform using an ICC profile and attach to the output image.\n *\n * This can either be an absolute filesystem path or\n * built-in profile name (`srgb`, `p3`, `cmyk`).\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithP3 = await sharp(input)\n *   .withIccProfile('p3')\n *   .toBuffer();\n *\n * @param {string} icc - Absolute filesystem path to output ICC profile or built-in profile name (srgb, p3, cmyk).\n * @param {Object} [options]\n * @param {number} [options.attach=true] Should the ICC profile be included in the output image metadata?\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withIccProfile (icc, options) {\n  if (is.string(icc)) {\n    this.options.withIccProfile = icc;\n  } else {\n    throw is.invalidParameterError('icc', 'string', icc);\n  }\n  this.keepIccProfile();\n  if (is.object(options)) {\n    if (is.defined(options.attach)) {\n      if (is.bool(options.attach)) {\n        if (!options.attach) {\n          this.options.keepMetadata &= ~0b01000;\n        }\n      } else {\n        throw is.invalidParameterError('attach', 'boolean', options.attach);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Keep XMP metadata from the input image in the output image.\n *\n * @since 0.34.3\n *\n * @example\n * const outputWithXmp = await sharp(inputWithXmp)\n *   .keepXmp()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepXmp () {\n  this.options.keepMetadata |= 0b00010;\n  return this;\n}\n\n/**\n * Set XMP metadata in the output image.\n *\n * Supported by PNG, JPEG, WebP, and TIFF output.\n *\n * @since 0.34.3\n *\n * @example\n * const xmpString = `\n *   <?xml version=\"1.0\"?>\n *   <x:xmpmeta xmlns:x=\"adobe:ns:meta/\">\n *     <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n *       <rdf:Description rdf:about=\"\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n *         <dc:creator><rdf:Seq><rdf:li>John Doe</rdf:li></rdf:Seq></dc:creator>\n *       </rdf:Description>\n *     </rdf:RDF>\n *   </x:xmpmeta>`;\n *\n * const data = await sharp(input)\n *   .withXmp(xmpString)\n *   .toBuffer();\n *\n * @param {string} xmp String containing XMP metadata to be embedded in the output image.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withXmp (xmp) {\n  if (is.string(xmp) && xmp.length > 0) {\n    this.options.withXmp = xmp;\n    this.options.keepMetadata |= 0b00010;\n  } else {\n    throw is.invalidParameterError('xmp', 'non-empty string', xmp);\n  }\n  return this;\n}\n\n/**\n * Keep all metadata (EXIF, ICC, XMP, IPTC) from the input image in the output image.\n *\n * The default behaviour, when `keepMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * @since 0.33.0\n *\n * @example\n * const outputWithMetadata = await sharp(inputWithMetadata)\n *   .keepMetadata()\n *   .toBuffer();\n *\n * @returns {Sharp}\n */\nfunction keepMetadata () {\n  this.options.keepMetadata = 0b11111;\n  return this;\n}\n\n/**\n * Keep most metadata (EXIF, XMP, IPTC) from the input image in the output image.\n *\n * This will also convert to and add a web-friendly sRGB ICC profile if appropriate.\n *\n * Allows orientation and density to be set or updated.\n *\n * @example\n * const outputSrgbWithMetadata = await sharp(inputRgbWithMetadata)\n *   .withMetadata()\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] Used to update the EXIF `Orientation` tag, integer between 1 and 8.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (options) {\n  this.keepMetadata();\n  this.withIccProfile('srgb');\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      this.withIccProfile(options.icc);\n    }\n    if (is.defined(options.exif)) {\n      this.withExifMerge(options.exif);\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 bits per pixel.\n *\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * For 16 bits per pixel output, convert to `rgb16` via\n * {@link /api-colour#tocolourspace|toColourspace}.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @example\n * // Output 16 bits per pixel RGB(A)\n * const data = await sharp(input)\n *  .toColourspace('rgb16')\n *  .png()\n *  .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {boolean} [options.smartDeblock=false] - auto-adjust the deblocking filter, can improve low contrast edges (slow)\n * @param {string} [options.preset='default'] - named preset for preprocessing/filtering, one of: default, photo, picture, drawing, icon, text\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    if (is.defined(options.smartDeblock)) {\n      this._setBooleanOption('webpSmartDeblock', options.smartDeblock);\n    }\n    if (is.defined(options.preset)) {\n      if (is.string(options.preset) && is.inArray(options.preset, ['default', 'photo', 'picture', 'drawing', 'icon', 'text'])) {\n        this.options.webpPreset = options.preset;\n      } else {\n        throw is.invalidParameterError('preset', 'one of: default, photo, picture, drawing, icon, text', options.preset);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {boolean} [options.keepDuplicateFrames=false] - keep duplicate frames in the output instead of combining them\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n    if (is.defined(options.keepDuplicateFrames)) {\n      if (is.bool(options.keepDuplicateFrames)) {\n        this._setBooleanOption('gifKeepDuplicateFrames', options.keepDuplicateFrames);\n      } else {\n        throw is.invalidParameterError('keepDuplicateFrames', 'boolean', options.keepDuplicateFrames);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/* istanbul ignore next */\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jp2 (options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions (source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (\n      Array.isArray(source.delay) &&\n      source.delay.every(is.integer) &&\n      source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @param {boolean} [options.miniswhite=false] - write 1-bit images as miniswhite\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // miniswhite\n    if (is.defined(options.miniswhite)) {\n      this._setBooleanOption('tiffMiniswhite', options.miniswhite);\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * AVIF image sequences are not supported.\n * Prebuilt binaries support a bitdepth of 8 only.\n *\n * This feature is experimental on the Windows ARM64 platform\n * and requires a CPU with ARM64v8.4 or later.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif (options) {\n  return this.heif({ ...options, compression: 'av1' });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} options - output options\n * @param {string} options.compression - compression format: av1, hevc\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif (options) {\n  if (is.object(options)) {\n    if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n      this.options.heifCompression = options.compression;\n    } else {\n      throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n    }\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [8, 10, 12])) {\n        if (options.bitdepth !== 8 && this.constructor.versions.heif) {\n          throw is.invalidParameterError('bitdepth when using prebuilt binaries', 8, options.bitdepth);\n        }\n        this.options.heifBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '8, 10 or 12', options.bitdepth);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('options', 'Object', options);\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 9 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jxl (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30\n          ? 0.1 + (100 - options.quality) * 0.09\n          : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 1, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 9', options.effort);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('jxl', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction raw (options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth,\n        ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex']\n      )) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] Threshold to skip tile generation. Range is 0-255 for 8-bit images, 0-65535 for 16-bit images. Default is 5 for `google` layout, -1 (no skip) otherwise.\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n    // Basename for zip container\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    const stack = Error();\n    this._pipeline(undefined, stack);\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback, stack) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            callback(is.nativeError(err, stack));\n          } else {\n            callback(null, data, info);\n          }\n        });\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          callback(is.nativeError(err, stack));\n        } else {\n          callback(null, data, info);\n        }\n      });\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', is.nativeError(err, stack));\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', is.nativeError(err, stack));\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(is.nativeError(err, stack));\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({ data, info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(is.nativeError(err, stack));\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({ data, info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    keepExif,\n    withExif,\n    withExifMerge,\n    keepIccProfile,\n    withIccProfile,\n    keepXmp,\n    withXmp,\n    keepMetadata,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvb3V0cHV0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDRCQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxrRkFBTTtBQUN6QixjQUFjLG1CQUFPLENBQUMsd0ZBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEIsaURBQWlELFdBQVcsR0FBRyxXQUFXO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NoYXJwQDAuMzQuNC9ub2RlX21vZHVsZXMvc2hhcnAvbGliL291dHB1dC5qcz84ZDBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzIExvdmVsbCBGdWxsZXIgYW5kIG90aGVycy5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpO1xuY29uc3QgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5jb25zdCBzaGFycCA9IHJlcXVpcmUoJy4vc2hhcnAnKTtcblxuY29uc3QgZm9ybWF0cyA9IG5ldyBNYXAoW1xuICBbJ2hlaWMnLCAnaGVpZiddLFxuICBbJ2hlaWYnLCAnaGVpZiddLFxuICBbJ2F2aWYnLCAnYXZpZiddLFxuICBbJ2pwZWcnLCAnanBlZyddLFxuICBbJ2pwZycsICdqcGVnJ10sXG4gIFsnanBlJywgJ2pwZWcnXSxcbiAgWyd0aWxlJywgJ3RpbGUnXSxcbiAgWydkeicsICd0aWxlJ10sXG4gIFsncG5nJywgJ3BuZyddLFxuICBbJ3JhdycsICdyYXcnXSxcbiAgWyd0aWZmJywgJ3RpZmYnXSxcbiAgWyd0aWYnLCAndGlmZiddLFxuICBbJ3dlYnAnLCAnd2VicCddLFxuICBbJ2dpZicsICdnaWYnXSxcbiAgWydqcDInLCAnanAyJ10sXG4gIFsnanB4JywgJ2pwMiddLFxuICBbJ2oyaycsICdqcDInXSxcbiAgWydqMmMnLCAnanAyJ10sXG4gIFsnanhsJywgJ2p4bCddXG5dKTtcblxuY29uc3QganAyUmVnZXggPSAvXFwuKGpwWzJ4XXxqMltrY10pJC9pO1xuXG5jb25zdCBlcnJKcDJTYXZlID0gKCkgPT4gbmV3IEVycm9yKCdKUDIgb3V0cHV0IHJlcXVpcmVzIGxpYnZpcHMgd2l0aCBzdXBwb3J0IGZvciBPcGVuSlBFRycpO1xuXG5jb25zdCBiaXRkZXB0aEZyb21Db2xvdXJDb3VudCA9IChjb2xvdXJzKSA9PiAxIDw8IDMxIC0gTWF0aC5jbHozMihNYXRoLmNlaWwoTWF0aC5sb2cyKGNvbG91cnMpKSk7XG5cbi8qKlxuICogV3JpdGUgb3V0cHV0IGltYWdlIGRhdGEgdG8gYSBmaWxlLlxuICpcbiAqIElmIGFuIGV4cGxpY2l0IG91dHB1dCBmb3JtYXQgaXMgbm90IHNlbGVjdGVkLCBpdCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlIGV4dGVuc2lvbixcbiAqIHdpdGggSlBFRywgUE5HLCBXZWJQLCBBVklGLCBUSUZGLCBHSUYsIERaSSwgYW5kIGxpYnZpcHMnIFYgZm9ybWF0IHN1cHBvcnRlZC5cbiAqIE5vdGUgdGhhdCByYXcgcGl4ZWwgZGF0YSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgYnVmZmVyIG91dHB1dC5cbiAqXG4gKiBCeSBkZWZhdWx0IGFsbCBtZXRhZGF0YSB3aWxsIGJlIHJlbW92ZWQsIHdoaWNoIGluY2x1ZGVzIEVYSUYtYmFzZWQgb3JpZW50YXRpb24uXG4gKiBTZWUge0BsaW5rICN3aXRobWV0YWRhdGF8d2l0aE1ldGFkYXRhfSBmb3IgY29udHJvbCBvdmVyIHRoaXMuXG4gKlxuICogVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgZGlyZWN0b3J5IHN0cnVjdHVyZXMgYW5kIHBlcm1pc3Npb25zIGV4aXN0LlxuICpcbiAqIEEgYFByb21pc2VgIGlzIHJldHVybmVkIHdoZW4gYGNhbGxiYWNrYCBpcyBub3QgcHJvdmlkZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAudG9GaWxlKCdvdXRwdXQucG5nJywgKGVyciwgaW5mbykgPT4geyAuLi4gfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAudG9GaWxlKCdvdXRwdXQucG5nJylcbiAqICAgLnRoZW4oaW5mbyA9PiB7IC4uLiB9KVxuICogICAuY2F0Y2goZXJyID0+IHsgLi4uIH0pO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlT3V0IC0gdGhlIHBhdGggdG8gd3JpdGUgdGhlIGltYWdlIGRhdGEgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gY2FsbGVkIG9uIGNvbXBsZXRpb24gd2l0aCB0d28gYXJndW1lbnRzIGAoZXJyLCBpbmZvKWAuXG4gKiBgaW5mb2AgY29udGFpbnMgdGhlIG91dHB1dCBpbWFnZSBgZm9ybWF0YCwgYHNpemVgIChieXRlcyksIGB3aWR0aGAsIGBoZWlnaHRgLFxuICogYGNoYW5uZWxzYCBhbmQgYHByZW11bHRpcGxpZWRgIChpbmRpY2F0aW5nIGlmIHByZW11bHRpcGxpY2F0aW9uIHdhcyB1c2VkKS5cbiAqIFdoZW4gdXNpbmcgYSBjcm9wIHN0cmF0ZWd5IGFsc28gY29udGFpbnMgYGNyb3BPZmZzZXRMZWZ0YCBhbmQgYGNyb3BPZmZzZXRUb3BgLlxuICogV2hlbiB1c2luZyB0aGUgYXR0ZW50aW9uIGNyb3Agc3RyYXRlZ3kgYWxzbyBjb250YWlucyBgYXR0ZW50aW9uWGAgYW5kIGBhdHRlbnRpb25ZYCwgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjcm9wcGVkIHJlZ2lvbi5cbiAqIEFuaW1hdGVkIG91dHB1dCB3aWxsIGFsc28gY29udGFpbiBgcGFnZUhlaWdodGAgYW5kIGBwYWdlc2AuXG4gKiBNYXkgYWxzbyBjb250YWluIGB0ZXh0QXV0b2ZpdERwaWAgKGRwaSB0aGUgZm9udCB3YXMgcmVuZGVyZWQgYXQpIGlmIGltYWdlIHdhcyBjcmVhdGVkIGZyb20gdGV4dC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gd2hlbiBubyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiB0b0ZpbGUgKGZpbGVPdXQsIGNhbGxiYWNrKSB7XG4gIGxldCBlcnI7XG4gIGlmICghaXMuc3RyaW5nKGZpbGVPdXQpKSB7XG4gICAgZXJyID0gbmV3IEVycm9yKCdNaXNzaW5nIG91dHB1dCBmaWxlIHBhdGgnKTtcbiAgfSBlbHNlIGlmIChpcy5zdHJpbmcodGhpcy5vcHRpb25zLmlucHV0LmZpbGUpICYmIHBhdGgucmVzb2x2ZSh0aGlzLm9wdGlvbnMuaW5wdXQuZmlsZSkgPT09IHBhdGgucmVzb2x2ZShmaWxlT3V0KSkge1xuICAgIGVyciA9IG5ldyBFcnJvcignQ2Fubm90IHVzZSBzYW1lIGZpbGUgZm9yIGlucHV0IGFuZCBvdXRwdXQnKTtcbiAgfSBlbHNlIGlmIChqcDJSZWdleC50ZXN0KHBhdGguZXh0bmFtZShmaWxlT3V0KSkgJiYgIXRoaXMuY29uc3RydWN0b3IuZm9ybWF0LmpwMmsub3V0cHV0LmZpbGUpIHtcbiAgICBlcnIgPSBlcnJKcDJTYXZlKCk7XG4gIH1cbiAgaWYgKGVycikge1xuICAgIGlmIChpcy5mbihjYWxsYmFjaykpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuZmlsZU91dCA9IGZpbGVPdXQ7XG4gICAgY29uc3Qgc3RhY2sgPSBFcnJvcigpO1xuICAgIHJldHVybiB0aGlzLl9waXBlbGluZShjYWxsYmFjaywgc3RhY2spO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFdyaXRlIG91dHB1dCB0byBhIEJ1ZmZlci5cbiAqIEpQRUcsIFBORywgV2ViUCwgQVZJRiwgVElGRiwgR0lGIGFuZCByYXcgcGl4ZWwgZGF0YSBvdXRwdXQgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBVc2Uge0BsaW5rICN0b2Zvcm1hdHx0b0Zvcm1hdH0gb3Igb25lIG9mIHRoZSBmb3JtYXQtc3BlY2lmaWMgZnVuY3Rpb25zIHN1Y2ggYXMge0BsaW5rIGpwZWd9LCB7QGxpbmsgcG5nfSBldGMuIHRvIHNldCB0aGUgb3V0cHV0IGZvcm1hdC5cbiAqXG4gKiBJZiBubyBleHBsaWNpdCBmb3JtYXQgaXMgc2V0LCB0aGUgb3V0cHV0IGZvcm1hdCB3aWxsIG1hdGNoIHRoZSBpbnB1dCBpbWFnZSwgZXhjZXB0IFNWRyBpbnB1dCB3aGljaCBiZWNvbWVzIFBORyBvdXRwdXQuXG4gKlxuICogQnkgZGVmYXVsdCBhbGwgbWV0YWRhdGEgd2lsbCBiZSByZW1vdmVkLCB3aGljaCBpbmNsdWRlcyBFWElGLWJhc2VkIG9yaWVudGF0aW9uLlxuICogU2VlIHtAbGluayAjd2l0aG1ldGFkYXRhfHdpdGhNZXRhZGF0YX0gZm9yIGNvbnRyb2wgb3ZlciB0aGlzLlxuICpcbiAqIGBjYWxsYmFja2AsIGlmIHByZXNlbnQsIGdldHMgdGhyZWUgYXJndW1lbnRzIGAoZXJyLCBkYXRhLCBpbmZvKWAgd2hlcmU6XG4gKiAtIGBlcnJgIGlzIGFuIGVycm9yLCBpZiBhbnkuXG4gKiAtIGBkYXRhYCBpcyB0aGUgb3V0cHV0IGltYWdlIGRhdGEuXG4gKiAtIGBpbmZvYCBjb250YWlucyB0aGUgb3V0cHV0IGltYWdlIGBmb3JtYXRgLCBgc2l6ZWAgKGJ5dGVzKSwgYHdpZHRoYCwgYGhlaWdodGAsXG4gKiBgY2hhbm5lbHNgIGFuZCBgcHJlbXVsdGlwbGllZGAgKGluZGljYXRpbmcgaWYgcHJlbXVsdGlwbGljYXRpb24gd2FzIHVzZWQpLlxuICogV2hlbiB1c2luZyBhIGNyb3Agc3RyYXRlZ3kgYWxzbyBjb250YWlucyBgY3JvcE9mZnNldExlZnRgIGFuZCBgY3JvcE9mZnNldFRvcGAuXG4gKiBBbmltYXRlZCBvdXRwdXQgd2lsbCBhbHNvIGNvbnRhaW4gYHBhZ2VIZWlnaHRgIGFuZCBgcGFnZXNgLlxuICogTWF5IGFsc28gY29udGFpbiBgdGV4dEF1dG9maXREcGlgIChkcGkgdGhlIGZvbnQgd2FzIHJlbmRlcmVkIGF0KSBpZiBpbWFnZSB3YXMgY3JlYXRlZCBmcm9tIHRleHQuXG4gKlxuICogQSBgUHJvbWlzZWAgaXMgcmV0dXJuZWQgd2hlbiBgY2FsbGJhY2tgIGlzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2hhcnAoaW5wdXQpXG4gKiAgIC50b0J1ZmZlcigoZXJyLCBkYXRhLCBpbmZvKSA9PiB7IC4uLiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogc2hhcnAoaW5wdXQpXG4gKiAgIC50b0J1ZmZlcigpXG4gKiAgIC50aGVuKGRhdGEgPT4geyAuLi4gfSlcbiAqICAgLmNhdGNoKGVyciA9PiB7IC4uLiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogc2hhcnAoaW5wdXQpXG4gKiAgIC5wbmcoKVxuICogICAudG9CdWZmZXIoeyByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSB9KVxuICogICAudGhlbigoeyBkYXRhLCBpbmZvIH0pID0+IHsgLi4uIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4geyAuLi4gfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgZGF0YSwgaW5mbyB9ID0gYXdhaXQgc2hhcnAoJ215LWltYWdlLmpwZycpXG4gKiAgIC8vIG91dHB1dCB0aGUgcmF3IHBpeGVsc1xuICogICAucmF3KClcbiAqICAgLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSk7XG4gKlxuICogLy8gY3JlYXRlIGEgbW9yZSB0eXBlIHNhZmUgd2F5IHRvIHdvcmsgd2l0aCB0aGUgcmF3IHBpeGVsIGRhdGFcbiAqIC8vIHRoaXMgd2lsbCBub3QgY29weSB0aGUgZGF0YSwgaW5zdGVhZCBpdCB3aWxsIGNoYW5nZSBgZGF0YWBzIHVuZGVybHlpbmcgQXJyYXlCdWZmZXJcbiAqIC8vIHNvIGBkYXRhYCBhbmQgYHBpeGVsQXJyYXlgIHBvaW50IHRvIHRoZSBzYW1lIG1lbW9yeSBsb2NhdGlvblxuICogY29uc3QgcGl4ZWxBcnJheSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShkYXRhLmJ1ZmZlcik7XG4gKlxuICogLy8gV2hlbiB5b3UgYXJlIGRvbmUgY2hhbmdpbmcgdGhlIHBpeGVsQXJyYXksIHNoYXJwIHRha2VzIHRoZSBgcGl4ZWxBcnJheWAgYXMgYW4gaW5wdXRcbiAqIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMgfSA9IGluZm87XG4gKiBhd2FpdCBzaGFycChwaXhlbEFycmF5LCB7IHJhdzogeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscyB9IH0pXG4gKiAgIC50b0ZpbGUoJ215LWNoYW5nZWQtaW1hZ2UuanBnJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNvbHZlV2l0aE9iamVjdF0gUmVzb2x2ZSB0aGUgUHJvbWlzZSB3aXRoIGFuIE9iamVjdCBjb250YWluaW5nIGBkYXRhYCBhbmQgYGluZm9gIHByb3BlcnRpZXMgaW5zdGVhZCBvZiByZXNvbHZpbmcgb25seSB3aXRoIGBkYXRhYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IC0gd2hlbiBubyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICovXG5mdW5jdGlvbiB0b0J1ZmZlciAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIHRoaXMuX3NldEJvb2xlYW5PcHRpb24oJ3Jlc29sdmVXaXRoT2JqZWN0Jywgb3B0aW9ucy5yZXNvbHZlV2l0aE9iamVjdCk7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnJlc29sdmVXaXRoT2JqZWN0KSB7XG4gICAgdGhpcy5vcHRpb25zLnJlc29sdmVXaXRoT2JqZWN0ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5vcHRpb25zLmZpbGVPdXQgPSAnJztcbiAgY29uc3Qgc3RhY2sgPSBFcnJvcigpO1xuICByZXR1cm4gdGhpcy5fcGlwZWxpbmUoaXMuZm4ob3B0aW9ucykgPyBvcHRpb25zIDogY2FsbGJhY2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBLZWVwIGFsbCBFWElGIG1ldGFkYXRhIGZyb20gdGhlIGlucHV0IGltYWdlIGluIHRoZSBvdXRwdXQgaW1hZ2UuXG4gKlxuICogRVhJRiBtZXRhZGF0YSBpcyB1bnN1cHBvcnRlZCBmb3IgVElGRiBvdXRwdXQuXG4gKlxuICogQHNpbmNlIDAuMzMuMFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXRXaXRoRXhpZiA9IGF3YWl0IHNoYXJwKGlucHV0V2l0aEV4aWYpXG4gKiAgIC5rZWVwRXhpZigpXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqL1xuZnVuY3Rpb24ga2VlcEV4aWYgKCkge1xuICB0aGlzLm9wdGlvbnMua2VlcE1ldGFkYXRhIHw9IDBiMDAwMDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCBFWElGIG1ldGFkYXRhIGluIHRoZSBvdXRwdXQgaW1hZ2UsIGlnbm9yaW5nIGFueSBFWElGIGluIHRoZSBpbnB1dCBpbWFnZS5cbiAqXG4gKiBAc2luY2UgMC4zMy4wXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGRhdGFXaXRoRXhpZiA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAud2l0aEV4aWYoe1xuICogICAgIElGRDA6IHtcbiAqICAgICAgIENvcHlyaWdodDogJ1RoZSBOYXRpb25hbCBHYWxsZXJ5J1xuICogICAgIH0sXG4gKiAgICAgSUZEMzoge1xuICogICAgICAgR1BTTGF0aXR1ZGVSZWY6ICdOJyxcbiAqICAgICAgIEdQU0xhdGl0dWRlOiAnNTEvMSAzMC8xIDMyMzAvMTAwJyxcbiAqICAgICAgIEdQU0xvbmdpdHVkZVJlZjogJ1cnLFxuICogICAgICAgR1BTTG9uZ2l0dWRlOiAnMC8xIDcvMSA0MzY2LzEwMCdcbiAqICAgICB9XG4gKiAgIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgc3RyaW5nPj59IGV4aWYgT2JqZWN0IGtleWVkIGJ5IElGRDAsIElGRDEgZXRjLiBvZiBrZXkvdmFsdWUgc3RyaW5nIHBhaXJzIHRvIHdyaXRlIGFzIEVYSUYgZGF0YS5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gd2l0aEV4aWYgKGV4aWYpIHtcbiAgaWYgKGlzLm9iamVjdChleGlmKSkge1xuICAgIGZvciAoY29uc3QgW2lmZCwgZW50cmllc10gb2YgT2JqZWN0LmVudHJpZXMoZXhpZikpIHtcbiAgICAgIGlmIChpcy5vYmplY3QoZW50cmllcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZW50cmllcykpIHtcbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKHYpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMud2l0aEV4aWZbYGV4aWYtJHtpZmQudG9Mb3dlckNhc2UoKX0tJHtrfWBdID0gdjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKGAke2lmZH0uJHtrfWAsICdzdHJpbmcnLCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcihpZmQsICdvYmplY3QnLCBlbnRyaWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdleGlmJywgJ29iamVjdCcsIGV4aWYpO1xuICB9XG4gIHRoaXMub3B0aW9ucy53aXRoRXhpZk1lcmdlID0gZmFsc2U7XG4gIHJldHVybiB0aGlzLmtlZXBFeGlmKCk7XG59XG5cbi8qKlxuICogVXBkYXRlIEVYSUYgbWV0YWRhdGEgZnJvbSB0aGUgaW5wdXQgaW1hZ2UgaW4gdGhlIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBAc2luY2UgMC4zMy4wXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGRhdGFXaXRoTWVyZ2VkRXhpZiA9IGF3YWl0IHNoYXJwKGlucHV0V2l0aEV4aWYpXG4gKiAgIC53aXRoRXhpZk1lcmdlKHtcbiAqICAgICBJRkQwOiB7XG4gKiAgICAgICBDb3B5cmlnaHQ6ICdUaGUgTmF0aW9uYWwgR2FsbGVyeSdcbiAqICAgICB9XG4gKiAgIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgc3RyaW5nPj59IGV4aWYgT2JqZWN0IGtleWVkIGJ5IElGRDAsIElGRDEgZXRjLiBvZiBrZXkvdmFsdWUgc3RyaW5nIHBhaXJzIHRvIHdyaXRlIGFzIEVYSUYgZGF0YS5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gd2l0aEV4aWZNZXJnZSAoZXhpZikge1xuICB0aGlzLndpdGhFeGlmKGV4aWYpO1xuICB0aGlzLm9wdGlvbnMud2l0aEV4aWZNZXJnZSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEtlZXAgSUNDIHByb2ZpbGUgZnJvbSB0aGUgaW5wdXQgaW1hZ2UgaW4gdGhlIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBXaGVyZSBuZWNlc3NhcnksIHdpbGwgYXR0ZW1wdCB0byBjb252ZXJ0IHRoZSBvdXRwdXQgY29sb3VyIHNwYWNlIHRvIG1hdGNoIHRoZSBwcm9maWxlLlxuICpcbiAqIEBzaW5jZSAwLjMzLjBcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0V2l0aEljY1Byb2ZpbGUgPSBhd2FpdCBzaGFycChpbnB1dFdpdGhJY2NQcm9maWxlKVxuICogICAua2VlcEljY1Byb2ZpbGUoKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIGtlZXBJY2NQcm9maWxlICgpIHtcbiAgdGhpcy5vcHRpb25zLmtlZXBNZXRhZGF0YSB8PSAwYjAxMDAwO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdXNpbmcgYW4gSUNDIHByb2ZpbGUgYW5kIGF0dGFjaCB0byB0aGUgb3V0cHV0IGltYWdlLlxuICpcbiAqIFRoaXMgY2FuIGVpdGhlciBiZSBhbiBhYnNvbHV0ZSBmaWxlc3lzdGVtIHBhdGggb3JcbiAqIGJ1aWx0LWluIHByb2ZpbGUgbmFtZSAoYHNyZ2JgLCBgcDNgLCBgY215a2ApLlxuICpcbiAqIEBzaW5jZSAwLjMzLjBcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0V2l0aFAzID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC53aXRoSWNjUHJvZmlsZSgncDMnKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWNjIC0gQWJzb2x1dGUgZmlsZXN5c3RlbSBwYXRoIHRvIG91dHB1dCBJQ0MgcHJvZmlsZSBvciBidWlsdC1pbiBwcm9maWxlIG5hbWUgKHNyZ2IsIHAzLCBjbXlrKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hdHRhY2g9dHJ1ZV0gU2hvdWxkIHRoZSBJQ0MgcHJvZmlsZSBiZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0IGltYWdlIG1ldGFkYXRhP1xuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiB3aXRoSWNjUHJvZmlsZSAoaWNjLCBvcHRpb25zKSB7XG4gIGlmIChpcy5zdHJpbmcoaWNjKSkge1xuICAgIHRoaXMub3B0aW9ucy53aXRoSWNjUHJvZmlsZSA9IGljYztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2ljYycsICdzdHJpbmcnLCBpY2MpO1xuICB9XG4gIHRoaXMua2VlcEljY1Byb2ZpbGUoKTtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuYXR0YWNoKSkge1xuICAgICAgaWYgKGlzLmJvb2wob3B0aW9ucy5hdHRhY2gpKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5hdHRhY2gpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMua2VlcE1ldGFkYXRhICY9IH4wYjAxMDAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2F0dGFjaCcsICdib29sZWFuJywgb3B0aW9ucy5hdHRhY2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBLZWVwIFhNUCBtZXRhZGF0YSBmcm9tIHRoZSBpbnB1dCBpbWFnZSBpbiB0aGUgb3V0cHV0IGltYWdlLlxuICpcbiAqIEBzaW5jZSAwLjM0LjNcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3V0cHV0V2l0aFhtcCA9IGF3YWl0IHNoYXJwKGlucHV0V2l0aFhtcClcbiAqICAgLmtlZXBYbXAoKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIGtlZXBYbXAgKCkge1xuICB0aGlzLm9wdGlvbnMua2VlcE1ldGFkYXRhIHw9IDBiMDAwMTA7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCBYTVAgbWV0YWRhdGEgaW4gdGhlIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBTdXBwb3J0ZWQgYnkgUE5HLCBKUEVHLCBXZWJQLCBhbmQgVElGRiBvdXRwdXQuXG4gKlxuICogQHNpbmNlIDAuMzQuM1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB4bXBTdHJpbmcgPSBgXG4gKiAgIDw/eG1sIHZlcnNpb249XCIxLjBcIj8+XG4gKiAgIDx4OnhtcG1ldGEgeG1sbnM6eD1cImFkb2JlOm5zOm1ldGEvXCI+XG4gKiAgICAgPHJkZjpSREYgeG1sbnM6cmRmPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiPlxuICogICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9XCJcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCI+XG4gKiAgICAgICAgIDxkYzpjcmVhdG9yPjxyZGY6U2VxPjxyZGY6bGk+Sm9obiBEb2U8L3JkZjpsaT48L3JkZjpTZXE+PC9kYzpjcmVhdG9yPlxuICogICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gKiAgICAgPC9yZGY6UkRGPlxuICogICA8L3g6eG1wbWV0YT5gO1xuICpcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLndpdGhYbXAoeG1wU3RyaW5nKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30geG1wIFN0cmluZyBjb250YWluaW5nIFhNUCBtZXRhZGF0YSB0byBiZSBlbWJlZGRlZCBpbiB0aGUgb3V0cHV0IGltYWdlLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiB3aXRoWG1wICh4bXApIHtcbiAgaWYgKGlzLnN0cmluZyh4bXApICYmIHhtcC5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5vcHRpb25zLndpdGhYbXAgPSB4bXA7XG4gICAgdGhpcy5vcHRpb25zLmtlZXBNZXRhZGF0YSB8PSAwYjAwMDEwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigneG1wJywgJ25vbi1lbXB0eSBzdHJpbmcnLCB4bXApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEtlZXAgYWxsIG1ldGFkYXRhIChFWElGLCBJQ0MsIFhNUCwgSVBUQykgZnJvbSB0aGUgaW5wdXQgaW1hZ2UgaW4gdGhlIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBiZWhhdmlvdXIsIHdoZW4gYGtlZXBNZXRhZGF0YWAgaXMgbm90IHVzZWQsIGlzIHRvIGNvbnZlcnQgdG8gdGhlIGRldmljZS1pbmRlcGVuZGVudFxuICogc1JHQiBjb2xvdXIgc3BhY2UgYW5kIHN0cmlwIGFsbCBtZXRhZGF0YSwgaW5jbHVkaW5nIHRoZSByZW1vdmFsIG9mIGFueSBJQ0MgcHJvZmlsZS5cbiAqXG4gKiBAc2luY2UgMC4zMy4wXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG91dHB1dFdpdGhNZXRhZGF0YSA9IGF3YWl0IHNoYXJwKGlucHV0V2l0aE1ldGFkYXRhKVxuICogICAua2VlcE1ldGFkYXRhKClcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHJldHVybnMge1NoYXJwfVxuICovXG5mdW5jdGlvbiBrZWVwTWV0YWRhdGEgKCkge1xuICB0aGlzLm9wdGlvbnMua2VlcE1ldGFkYXRhID0gMGIxMTExMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogS2VlcCBtb3N0IG1ldGFkYXRhIChFWElGLCBYTVAsIElQVEMpIGZyb20gdGhlIGlucHV0IGltYWdlIGluIHRoZSBvdXRwdXQgaW1hZ2UuXG4gKlxuICogVGhpcyB3aWxsIGFsc28gY29udmVydCB0byBhbmQgYWRkIGEgd2ViLWZyaWVuZGx5IHNSR0IgSUNDIHByb2ZpbGUgaWYgYXBwcm9wcmlhdGUuXG4gKlxuICogQWxsb3dzIG9yaWVudGF0aW9uIGFuZCBkZW5zaXR5IHRvIGJlIHNldCBvciB1cGRhdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvdXRwdXRTcmdiV2l0aE1ldGFkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXRSZ2JXaXRoTWV0YWRhdGEpXG4gKiAgIC53aXRoTWV0YWRhdGEoKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IG91dHB1dCBtZXRhZGF0YSB0byA5NiBEUElcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLndpdGhNZXRhZGF0YSh7IGRlbnNpdHk6IDk2IH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5vcmllbnRhdGlvbl0gVXNlZCB0byB1cGRhdGUgdGhlIEVYSUYgYE9yaWVudGF0aW9uYCB0YWcsIGludGVnZXIgYmV0d2VlbiAxIGFuZCA4LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlbnNpdHldIE51bWJlciBvZiBwaXhlbHMgcGVyIGluY2ggKERQSSkuXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIHdpdGhNZXRhZGF0YSAob3B0aW9ucykge1xuICB0aGlzLmtlZXBNZXRhZGF0YSgpO1xuICB0aGlzLndpdGhJY2NQcm9maWxlKCdzcmdiJyk7XG4gIGlmIChpcy5vYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm9yaWVudGF0aW9uKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5vcmllbnRhdGlvbikgJiYgaXMuaW5SYW5nZShvcHRpb25zLm9yaWVudGF0aW9uLCAxLCA4KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2l0aE1ldGFkYXRhT3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcmllbnRhdGlvbicsICdpbnRlZ2VyIGJldHdlZW4gMSBhbmQgOCcsIG9wdGlvbnMub3JpZW50YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmRlbnNpdHkpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMuZGVuc2l0eSkgJiYgb3B0aW9ucy5kZW5zaXR5ID4gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2l0aE1ldGFkYXRhRGVuc2l0eSA9IG9wdGlvbnMuZGVuc2l0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZGVuc2l0eScsICdwb3NpdGl2ZSBudW1iZXInLCBvcHRpb25zLmRlbnNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmljYykpIHtcbiAgICAgIHRoaXMud2l0aEljY1Byb2ZpbGUob3B0aW9ucy5pY2MpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmV4aWYpKSB7XG4gICAgICB0aGlzLndpdGhFeGlmTWVyZ2Uob3B0aW9ucy5leGlmKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogRm9yY2Ugb3V0cHV0IHRvIGEgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IGFueSBpbnB1dCB0byBQTkcgb3V0cHV0XG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC50b0Zvcm1hdCgncG5nJylcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IGZvcm1hdCAtIGFzIGEgc3RyaW5nIG9yIGFuIE9iamVjdCB3aXRoIGFuICdpZCcgYXR0cmlidXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG91dHB1dCBvcHRpb25zXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gdW5zdXBwb3J0ZWQgZm9ybWF0IG9yIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtYXQgKGZvcm1hdCwgb3B0aW9ucykge1xuICBjb25zdCBhY3R1YWxGb3JtYXQgPSBmb3JtYXRzLmdldCgoaXMub2JqZWN0KGZvcm1hdCkgJiYgaXMuc3RyaW5nKGZvcm1hdC5pZCkgPyBmb3JtYXQuaWQgOiBmb3JtYXQpLnRvTG93ZXJDYXNlKCkpO1xuICBpZiAoIWFjdHVhbEZvcm1hdCkge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZm9ybWF0JywgYG9uZSBvZjogJHtbLi4uZm9ybWF0cy5rZXlzKCldLmpvaW4oJywgJyl9YCwgZm9ybWF0KTtcbiAgfVxuICByZXR1cm4gdGhpc1thY3R1YWxGb3JtYXRdKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFVzZSB0aGVzZSBKUEVHIG9wdGlvbnMgZm9yIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBhbnkgaW5wdXQgdG8gdmVyeSBoaWdoIHF1YWxpdHkgSlBFRyBvdXRwdXRcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLmpwZWcoe1xuICogICAgIHF1YWxpdHk6IDEwMCxcbiAqICAgICBjaHJvbWFTdWJzYW1wbGluZzogJzQ6NDo0J1xuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVXNlIG1vempwZWcgdG8gcmVkdWNlIG91dHB1dCBKUEVHIGZpbGUgc2l6ZSAoc2xvd2VyKVxuICogY29uc3QgZGF0YSA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAuanBlZyh7IG1vempwZWc6IHRydWUgfSlcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG91dHB1dCBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhbGl0eT04MF0gLSBxdWFsaXR5LCBpbnRlZ2VyIDEtMTAwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByb2dyZXNzaXZlPWZhbHNlXSAtIHVzZSBwcm9ncmVzc2l2ZSAoaW50ZXJsYWNlKSBzY2FuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2hyb21hU3Vic2FtcGxpbmc9JzQ6MjowJ10gLSBzZXQgdG8gJzQ6NDo0JyB0byBwcmV2ZW50IGNocm9tYSBzdWJzYW1wbGluZyBvdGhlcndpc2UgZGVmYXVsdHMgdG8gJzQ6MjowJyBjaHJvbWEgc3Vic2FtcGxpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub3B0aW1pc2VDb2Rpbmc9dHJ1ZV0gLSBvcHRpbWlzZSBIdWZmbWFuIGNvZGluZyB0YWJsZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub3B0aW1pemVDb2Rpbmc9dHJ1ZV0gLSBhbHRlcm5hdGl2ZSBzcGVsbGluZyBvZiBvcHRpbWlzZUNvZGluZ1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5tb3pqcGVnPWZhbHNlXSAtIHVzZSBtb3pqcGVnIGRlZmF1bHRzLCBlcXVpdmFsZW50IHRvIGB7IHRyZWxsaXNRdWFudGlzYXRpb246IHRydWUsIG92ZXJzaG9vdERlcmluZ2luZzogdHJ1ZSwgb3B0aW1pc2VTY2FuczogdHJ1ZSwgcXVhbnRpc2F0aW9uVGFibGU6IDMgfWBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJlbGxpc1F1YW50aXNhdGlvbj1mYWxzZV0gLSBhcHBseSB0cmVsbGlzIHF1YW50aXNhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vdmVyc2hvb3REZXJpbmdpbmc9ZmFsc2VdIC0gYXBwbHkgb3ZlcnNob290IGRlcmluZ2luZ1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vcHRpbWlzZVNjYW5zPWZhbHNlXSAtIG9wdGltaXNlIHByb2dyZXNzaXZlIHNjYW5zLCBmb3JjZXMgcHJvZ3Jlc3NpdmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub3B0aW1pemVTY2Fucz1mYWxzZV0gLSBhbHRlcm5hdGl2ZSBzcGVsbGluZyBvZiBvcHRpbWlzZVNjYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhbnRpc2F0aW9uVGFibGU9MF0gLSBxdWFudGl6YXRpb24gdGFibGUgdG8gdXNlLCBpbnRlZ2VyIDAtOFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnF1YW50aXphdGlvblRhYmxlPTBdIC0gYWx0ZXJuYXRpdmUgc3BlbGxpbmcgb2YgcXVhbnRpc2F0aW9uVGFibGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2U9dHJ1ZV0gLSBmb3JjZSBKUEVHIG91dHB1dCwgb3RoZXJ3aXNlIGF0dGVtcHQgdG8gdXNlIGlucHV0IGZvcm1hdFxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBqcGVnIChvcHRpb25zKSB7XG4gIGlmIChpcy5vYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnF1YWxpdHkpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLnF1YWxpdHkpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5xdWFsaXR5LCAxLCAxMDApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5qcGVnUXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncXVhbGl0eScsICdpbnRlZ2VyIGJldHdlZW4gMSBhbmQgMTAwJywgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5wcm9ncmVzc2l2ZSkpIHtcbiAgICAgIHRoaXMuX3NldEJvb2xlYW5PcHRpb24oJ2pwZWdQcm9ncmVzc2l2ZScsIG9wdGlvbnMucHJvZ3Jlc3NpdmUpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nKSkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nKSAmJiBpcy5pbkFycmF5KG9wdGlvbnMuY2hyb21hU3Vic2FtcGxpbmcsIFsnNDoyOjAnLCAnNDo0OjQnXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmpwZWdDaHJvbWFTdWJzYW1wbGluZyA9IG9wdGlvbnMuY2hyb21hU3Vic2FtcGxpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2Nocm9tYVN1YnNhbXBsaW5nJywgJ29uZSBvZjogNDoyOjAsIDQ6NDo0Jywgb3B0aW9ucy5jaHJvbWFTdWJzYW1wbGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9wdGltaXNlQ29kaW5nID0gaXMuYm9vbChvcHRpb25zLm9wdGltaXplQ29kaW5nKSA/IG9wdGlvbnMub3B0aW1pemVDb2RpbmcgOiBvcHRpb25zLm9wdGltaXNlQ29kaW5nO1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGltaXNlQ29kaW5nKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignanBlZ09wdGltaXNlQ29kaW5nJywgb3B0aW1pc2VDb2RpbmcpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm1vempwZWcpKSB7XG4gICAgICBpZiAoaXMuYm9vbChvcHRpb25zLm1vempwZWcpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1vempwZWcpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuanBlZ1RyZWxsaXNRdWFudGlzYXRpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5qcGVnT3ZlcnNob290RGVyaW5naW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuanBlZ09wdGltaXNlU2NhbnMgPSB0cnVlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5qcGVnUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5qcGVnUXVhbnRpc2F0aW9uVGFibGUgPSAzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ21vempwZWcnLCAnYm9vbGVhbicsIG9wdGlvbnMubW96anBlZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWxsaXNRdWFudGlzYXRpb24gPSBpcy5ib29sKG9wdGlvbnMudHJlbGxpc1F1YW50aXphdGlvbikgPyBvcHRpb25zLnRyZWxsaXNRdWFudGl6YXRpb24gOiBvcHRpb25zLnRyZWxsaXNRdWFudGlzYXRpb247XG4gICAgaWYgKGlzLmRlZmluZWQodHJlbGxpc1F1YW50aXNhdGlvbikpIHtcbiAgICAgIHRoaXMuX3NldEJvb2xlYW5PcHRpb24oJ2pwZWdUcmVsbGlzUXVhbnRpc2F0aW9uJywgdHJlbGxpc1F1YW50aXNhdGlvbik7XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMub3ZlcnNob290RGVyaW5naW5nKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignanBlZ092ZXJzaG9vdERlcmluZ2luZycsIG9wdGlvbnMub3ZlcnNob290RGVyaW5naW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW1pc2VTY2FucyA9IGlzLmJvb2wob3B0aW9ucy5vcHRpbWl6ZVNjYW5zKSA/IG9wdGlvbnMub3B0aW1pemVTY2FucyA6IG9wdGlvbnMub3B0aW1pc2VTY2FucztcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpbWlzZVNjYW5zKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignanBlZ09wdGltaXNlU2NhbnMnLCBvcHRpbWlzZVNjYW5zKTtcbiAgICAgIGlmIChvcHRpbWlzZVNjYW5zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5qcGVnUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBxdWFudGlzYXRpb25UYWJsZSA9IGlzLm51bWJlcihvcHRpb25zLnF1YW50aXphdGlvblRhYmxlKSA/IG9wdGlvbnMucXVhbnRpemF0aW9uVGFibGUgOiBvcHRpb25zLnF1YW50aXNhdGlvblRhYmxlO1xuICAgIGlmIChpcy5kZWZpbmVkKHF1YW50aXNhdGlvblRhYmxlKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIocXVhbnRpc2F0aW9uVGFibGUpICYmIGlzLmluUmFuZ2UocXVhbnRpc2F0aW9uVGFibGUsIDAsIDgpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5qcGVnUXVhbnRpc2F0aW9uVGFibGUgPSBxdWFudGlzYXRpb25UYWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncXVhbnRpc2F0aW9uVGFibGUnLCAnaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDgnLCBxdWFudGlzYXRpb25UYWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLl91cGRhdGVGb3JtYXRPdXQoJ2pwZWcnLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBVc2UgdGhlc2UgUE5HIG9wdGlvbnMgZm9yIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBQTkcgb3V0cHV0IGlzIGZ1bGwgY29sb3VyIGF0IDggYml0cyBwZXIgcGl4ZWwuXG4gKlxuICogSW5kZXhlZCBQTkcgaW5wdXQgYXQgMSwgMiBvciA0IGJpdHMgcGVyIHBpeGVsIGlzIGNvbnZlcnRlZCB0byA4IGJpdHMgcGVyIHBpeGVsLlxuICogU2V0IGBwYWxldHRlYCB0byBgdHJ1ZWAgZm9yIHNsb3dlciwgaW5kZXhlZCBQTkcgb3V0cHV0LlxuICpcbiAqIEZvciAxNiBiaXRzIHBlciBwaXhlbCBvdXRwdXQsIGNvbnZlcnQgdG8gYHJnYjE2YCB2aWFcbiAqIHtAbGluayAvYXBpLWNvbG91ciN0b2NvbG91cnNwYWNlfHRvQ29sb3Vyc3BhY2V9LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IGFueSBpbnB1dCB0byBmdWxsIGNvbG91ciBQTkcgb3V0cHV0XG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5wbmcoKVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBhbnkgaW5wdXQgdG8gaW5kZXhlZCBQTkcgb3V0cHV0IChzbG93ZXIpXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5wbmcoeyBwYWxldHRlOiB0cnVlIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBPdXRwdXQgMTYgYml0cyBwZXIgcGl4ZWwgUkdCKEEpXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgLnRvQ29sb3Vyc3BhY2UoJ3JnYjE2JylcbiAqICAucG5nKClcbiAqICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByb2dyZXNzaXZlPWZhbHNlXSAtIHVzZSBwcm9ncmVzc2l2ZSAoaW50ZXJsYWNlKSBzY2FuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29tcHJlc3Npb25MZXZlbD02XSAtIHpsaWIgY29tcHJlc3Npb24gbGV2ZWwsIDAgKGZhc3Rlc3QsIGxhcmdlc3QpIHRvIDkgKHNsb3dlc3QsIHNtYWxsZXN0KVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGFwdGl2ZUZpbHRlcmluZz1mYWxzZV0gLSB1c2UgYWRhcHRpdmUgcm93IGZpbHRlcmluZ1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYWxldHRlPWZhbHNlXSAtIHF1YW50aXNlIHRvIGEgcGFsZXR0ZS1iYXNlZCBpbWFnZSB3aXRoIGFscGhhIHRyYW5zcGFyZW5jeSBzdXBwb3J0XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xMDBdIC0gdXNlIHRoZSBsb3dlc3QgbnVtYmVyIG9mIGNvbG91cnMgbmVlZGVkIHRvIGFjaGlldmUgZ2l2ZW4gcXVhbGl0eSwgc2V0cyBgcGFsZXR0ZWAgdG8gYHRydWVgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZWZmb3J0PTddIC0gQ1BVIGVmZm9ydCwgYmV0d2VlbiAxIChmYXN0ZXN0KSBhbmQgMTAgKHNsb3dlc3QpLCBzZXRzIGBwYWxldHRlYCB0byBgdHJ1ZWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xvdXJzPTI1Nl0gLSBtYXhpbXVtIG51bWJlciBvZiBwYWxldHRlIGVudHJpZXMsIHNldHMgYHBhbGV0dGVgIHRvIGB0cnVlYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbG9ycz0yNTZdIC0gYWx0ZXJuYXRpdmUgc3BlbGxpbmcgb2YgYG9wdGlvbnMuY29sb3Vyc2AsIHNldHMgYHBhbGV0dGVgIHRvIGB0cnVlYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpdGhlcj0xLjBdIC0gbGV2ZWwgb2YgRmxveWQtU3RlaW5iZXJnIGVycm9yIGRpZmZ1c2lvbiwgc2V0cyBgcGFsZXR0ZWAgdG8gYHRydWVgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlPXRydWVdIC0gZm9yY2UgUE5HIG91dHB1dCwgb3RoZXJ3aXNlIGF0dGVtcHQgdG8gdXNlIGlucHV0IGZvcm1hdFxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwbmcgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucHJvZ3Jlc3NpdmUpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCdwbmdQcm9ncmVzc2l2ZScsIG9wdGlvbnMucHJvZ3Jlc3NpdmUpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmNvbXByZXNzaW9uTGV2ZWwpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLmNvbXByZXNzaW9uTGV2ZWwpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5jb21wcmVzc2lvbkxldmVsLCAwLCA5KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucG5nQ29tcHJlc3Npb25MZXZlbCA9IG9wdGlvbnMuY29tcHJlc3Npb25MZXZlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignY29tcHJlc3Npb25MZXZlbCcsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgOScsIG9wdGlvbnMuY29tcHJlc3Npb25MZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuYWRhcHRpdmVGaWx0ZXJpbmcpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCdwbmdBZGFwdGl2ZUZpbHRlcmluZycsIG9wdGlvbnMuYWRhcHRpdmVGaWx0ZXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvdXJzID0gb3B0aW9ucy5jb2xvdXJzIHx8IG9wdGlvbnMuY29sb3JzO1xuICAgIGlmIChpcy5kZWZpbmVkKGNvbG91cnMpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihjb2xvdXJzKSAmJiBpcy5pblJhbmdlKGNvbG91cnMsIDIsIDI1NikpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBuZ0JpdGRlcHRoID0gYml0ZGVwdGhGcm9tQ29sb3VyQ291bnQoY29sb3Vycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NvbG91cnMnLCAnaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDI1NicsIGNvbG91cnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnBhbGV0dGUpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCdwbmdQYWxldHRlJywgb3B0aW9ucy5wYWxldHRlKTtcbiAgICB9IGVsc2UgaWYgKFtvcHRpb25zLnF1YWxpdHksIG9wdGlvbnMuZWZmb3J0LCBvcHRpb25zLmNvbG91cnMsIG9wdGlvbnMuY29sb3JzLCBvcHRpb25zLmRpdGhlcl0uc29tZShpcy5kZWZpbmVkKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbigncG5nUGFsZXR0ZScsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnBuZ1BhbGV0dGUpIHtcbiAgICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucXVhbGl0eSkpIHtcbiAgICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5xdWFsaXR5KSAmJiBpcy5pblJhbmdlKG9wdGlvbnMucXVhbGl0eSwgMCwgMTAwKSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5wbmdRdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncXVhbGl0eScsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMTAwJywgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5lZmZvcnQpKSB7XG4gICAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuZWZmb3J0KSAmJiBpcy5pblJhbmdlKG9wdGlvbnMuZWZmb3J0LCAxLCAxMCkpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucG5nRWZmb3J0ID0gb3B0aW9ucy5lZmZvcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdlZmZvcnQnLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwJywgb3B0aW9ucy5lZmZvcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmRpdGhlcikpIHtcbiAgICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLmRpdGhlcikgJiYgaXMuaW5SYW5nZShvcHRpb25zLmRpdGhlciwgMCwgMSkpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucG5nRGl0aGVyID0gb3B0aW9ucy5kaXRoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdkaXRoZXInLCAnbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAnLCBvcHRpb25zLmRpdGhlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZvcm1hdE91dCgncG5nJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXNlIHRoZXNlIFdlYlAgb3B0aW9ucyBmb3Igb3V0cHV0IGltYWdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IGFueSBpbnB1dCB0byBsb3NzbGVzcyBXZWJQIG91dHB1dFxuICogY29uc3QgZGF0YSA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAud2VicCh7IGxvc3NsZXNzOiB0cnVlIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBPcHRpbWlzZSB0aGUgZmlsZSBzaXplIG9mIGFuIGFuaW1hdGVkIFdlYlBcbiAqIGNvbnN0IG91dHB1dFdlYnAgPSBhd2FpdCBzaGFycChpbnB1dFdlYnAsIHsgYW5pbWF0ZWQ6IHRydWUgfSlcbiAqICAgLndlYnAoeyBlZmZvcnQ6IDYgfSlcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG91dHB1dCBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhbGl0eT04MF0gLSBxdWFsaXR5LCBpbnRlZ2VyIDEtMTAwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYWxwaGFRdWFsaXR5PTEwMF0gLSBxdWFsaXR5IG9mIGFscGhhIGxheWVyLCBpbnRlZ2VyIDAtMTAwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxvc3NsZXNzPWZhbHNlXSAtIHVzZSBsb3NzbGVzcyBjb21wcmVzc2lvbiBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5lYXJMb3NzbGVzcz1mYWxzZV0gLSB1c2UgbmVhcl9sb3NzbGVzcyBjb21wcmVzc2lvbiBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNtYXJ0U3Vic2FtcGxlPWZhbHNlXSAtIHVzZSBoaWdoIHF1YWxpdHkgY2hyb21hIHN1YnNhbXBsaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNtYXJ0RGVibG9jaz1mYWxzZV0gLSBhdXRvLWFkanVzdCB0aGUgZGVibG9ja2luZyBmaWx0ZXIsIGNhbiBpbXByb3ZlIGxvdyBjb250cmFzdCBlZGdlcyAoc2xvdylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcmVzZXQ9J2RlZmF1bHQnXSAtIG5hbWVkIHByZXNldCBmb3IgcHJlcHJvY2Vzc2luZy9maWx0ZXJpbmcsIG9uZSBvZjogZGVmYXVsdCwgcGhvdG8sIHBpY3R1cmUsIGRyYXdpbmcsIGljb24sIHRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5lZmZvcnQ9NF0gLSBDUFUgZWZmb3J0LCBiZXR3ZWVuIDAgKGZhc3Rlc3QpIGFuZCA2IChzbG93ZXN0KVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3A9MF0gLSBudW1iZXIgb2YgYW5pbWF0aW9uIGl0ZXJhdGlvbnMsIHVzZSAwIGZvciBpbmZpbml0ZSBhbmltYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbb3B0aW9ucy5kZWxheV0gLSBkZWxheShzKSBiZXR3ZWVuIGFuaW1hdGlvbiBmcmFtZXMgKGluIG1pbGxpc2Vjb25kcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubWluU2l6ZT1mYWxzZV0gLSBwcmV2ZW50IHVzZSBvZiBhbmltYXRpb24ga2V5IGZyYW1lcyB0byBtaW5pbWlzZSBmaWxlIHNpemUgKHNsb3cpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm1peGVkPWZhbHNlXSAtIGFsbG93IG1peHR1cmUgb2YgbG9zc3kgYW5kIGxvc3NsZXNzIGFuaW1hdGlvbiBmcmFtZXMgKHNsb3cpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlPXRydWVdIC0gZm9yY2UgV2ViUCBvdXRwdXQsIG90aGVyd2lzZSBhdHRlbXB0IHRvIHVzZSBpbnB1dCBmb3JtYXRcbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gd2VicCAob3B0aW9ucykge1xuICBpZiAoaXMub2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5xdWFsaXR5KSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5xdWFsaXR5KSAmJiBpcy5pblJhbmdlKG9wdGlvbnMucXVhbGl0eSwgMSwgMTAwKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2VicFF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3F1YWxpdHknLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwMCcsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuYWxwaGFRdWFsaXR5KSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5hbHBoYVF1YWxpdHkpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5hbHBoYVF1YWxpdHksIDAsIDEwMCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLndlYnBBbHBoYVF1YWxpdHkgPSBvcHRpb25zLmFscGhhUXVhbGl0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignYWxwaGFRdWFsaXR5JywgJ2ludGVnZXIgYmV0d2VlbiAwIGFuZCAxMDAnLCBvcHRpb25zLmFscGhhUXVhbGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMubG9zc2xlc3MpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd3ZWJwTG9zc2xlc3MnLCBvcHRpb25zLmxvc3NsZXNzKTtcbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5uZWFyTG9zc2xlc3MpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd3ZWJwTmVhckxvc3NsZXNzJywgb3B0aW9ucy5uZWFyTG9zc2xlc3MpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnNtYXJ0U3Vic2FtcGxlKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignd2VicFNtYXJ0U3Vic2FtcGxlJywgb3B0aW9ucy5zbWFydFN1YnNhbXBsZSk7XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuc21hcnREZWJsb2NrKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignd2VicFNtYXJ0RGVibG9jaycsIG9wdGlvbnMuc21hcnREZWJsb2NrKTtcbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5wcmVzZXQpKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKG9wdGlvbnMucHJlc2V0KSAmJiBpcy5pbkFycmF5KG9wdGlvbnMucHJlc2V0LCBbJ2RlZmF1bHQnLCAncGhvdG8nLCAncGljdHVyZScsICdkcmF3aW5nJywgJ2ljb24nLCAndGV4dCddKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2VicFByZXNldCA9IG9wdGlvbnMucHJlc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdwcmVzZXQnLCAnb25lIG9mOiBkZWZhdWx0LCBwaG90bywgcGljdHVyZSwgZHJhd2luZywgaWNvbiwgdGV4dCcsIG9wdGlvbnMucHJlc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5lZmZvcnQpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLmVmZm9ydCkgJiYgaXMuaW5SYW5nZShvcHRpb25zLmVmZm9ydCwgMCwgNikpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLndlYnBFZmZvcnQgPSBvcHRpb25zLmVmZm9ydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZWZmb3J0JywgJ2ludGVnZXIgYmV0d2VlbiAwIGFuZCA2Jywgb3B0aW9ucy5lZmZvcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm1pblNpemUpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd3ZWJwTWluU2l6ZScsIG9wdGlvbnMubWluU2l6ZSk7XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMubWl4ZWQpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd3ZWJwTWl4ZWQnLCBvcHRpb25zLm1peGVkKTtcbiAgICB9XG4gIH1cbiAgdHJ5U2V0QW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5fdXBkYXRlRm9ybWF0T3V0KCd3ZWJwJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXNlIHRoZXNlIEdJRiBvcHRpb25zIGZvciB0aGUgb3V0cHV0IGltYWdlLlxuICpcbiAqIFRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgcGFsZXR0ZSBpcyByZXNlcnZlZCBmb3IgdHJhbnNwYXJlbmN5LlxuICpcbiAqIFRoZSBwYWxldHRlIG9mIHRoZSBpbnB1dCBpbWFnZSB3aWxsIGJlIHJlLXVzZWQgaWYgcG9zc2libGUuXG4gKlxuICogQHNpbmNlIDAuMzAuMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IFBORyB0byBHSUZcbiAqIGF3YWl0IHNoYXJwKHBuZ0J1ZmZlcilcbiAqICAgLmdpZigpXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IGFuaW1hdGVkIFdlYlAgdG8gYW5pbWF0ZWQgR0lGXG4gKiBhd2FpdCBzaGFycCgnYW5pbWF0ZWQud2VicCcsIHsgYW5pbWF0ZWQ6IHRydWUgfSlcbiAqICAgLnRvRmlsZSgnYW5pbWF0ZWQuZ2lmJyk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhIDEyOHgxMjgsIGNyb3BwZWQsIG5vbi1kaXRoZXJlZCwgYW5pbWF0ZWQgdGh1bWJuYWlsIG9mIGFuIGFuaW1hdGVkIEdJRlxuICogY29uc3Qgb3V0ID0gYXdhaXQgc2hhcnAoJ2luLmdpZicsIHsgYW5pbWF0ZWQ6IHRydWUgfSlcbiAqICAgLnJlc2l6ZSh7IHdpZHRoOiAxMjgsIGhlaWdodDogMTI4IH0pXG4gKiAgIC5naWYoeyBkaXRoZXI6IDAgfSlcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIExvc3N5IGZpbGUgc2l6ZSByZWR1Y3Rpb24gb2YgYW5pbWF0ZWQgR0lGXG4gKiBhd2FpdCBzaGFycCgnaW4uZ2lmJywgeyBhbmltYXRlZDogdHJ1ZSB9KVxuICogICAuZ2lmKHsgaW50ZXJGcmFtZU1heEVycm9yOiA4IH0pXG4gKiAgIC50b0ZpbGUoJ29wdGltLmdpZicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvdXRwdXQgb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXVzZT10cnVlXSAtIHJlLXVzZSBleGlzdGluZyBwYWxldHRlLCBvdGhlcndpc2UgZ2VuZXJhdGUgbmV3IChzbG93KVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcm9ncmVzc2l2ZT1mYWxzZV0gLSB1c2UgcHJvZ3Jlc3NpdmUgKGludGVybGFjZSkgc2NhblxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbG91cnM9MjU2XSAtIG1heGltdW0gbnVtYmVyIG9mIHBhbGV0dGUgZW50cmllcywgaW5jbHVkaW5nIHRyYW5zcGFyZW5jeSwgYmV0d2VlbiAyIGFuZCAyNTZcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xvcnM9MjU2XSAtIGFsdGVybmF0aXZlIHNwZWxsaW5nIG9mIGBvcHRpb25zLmNvbG91cnNgXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZWZmb3J0PTddIC0gQ1BVIGVmZm9ydCwgYmV0d2VlbiAxIChmYXN0ZXN0KSBhbmQgMTAgKHNsb3dlc3QpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGl0aGVyPTEuMF0gLSBsZXZlbCBvZiBGbG95ZC1TdGVpbmJlcmcgZXJyb3IgZGlmZnVzaW9uLCBiZXR3ZWVuIDAgKGxlYXN0KSBhbmQgMSAobW9zdClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbnRlckZyYW1lTWF4RXJyb3I9MF0gLSBtYXhpbXVtIGludGVyLWZyYW1lIGVycm9yIGZvciB0cmFuc3BhcmVuY3ksIGJldHdlZW4gMCAobG9zc2xlc3MpIGFuZCAzMlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmludGVyUGFsZXR0ZU1heEVycm9yPTNdIC0gbWF4aW11bSBpbnRlci1wYWxldHRlIGVycm9yIGZvciBwYWxldHRlIHJldXNlLCBiZXR3ZWVuIDAgYW5kIDI1NlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5rZWVwRHVwbGljYXRlRnJhbWVzPWZhbHNlXSAtIGtlZXAgZHVwbGljYXRlIGZyYW1lcyBpbiB0aGUgb3V0cHV0IGluc3RlYWQgb2YgY29tYmluaW5nIHRoZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb29wPTBdIC0gbnVtYmVyIG9mIGFuaW1hdGlvbiBpdGVyYXRpb25zLCB1c2UgMCBmb3IgaW5maW5pdGUgYW5pbWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW29wdGlvbnMuZGVsYXldIC0gZGVsYXkocykgYmV0d2VlbiBhbmltYXRpb24gZnJhbWVzIChpbiBtaWxsaXNlY29uZHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlPXRydWVdIC0gZm9yY2UgR0lGIG91dHB1dCwgb3RoZXJ3aXNlIGF0dGVtcHQgdG8gdXNlIGlucHV0IGZvcm1hdFxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnaWYgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucmV1c2UpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCdnaWZSZXVzZScsIG9wdGlvbnMucmV1c2UpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnByb2dyZXNzaXZlKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignZ2lmUHJvZ3Jlc3NpdmUnLCBvcHRpb25zLnByb2dyZXNzaXZlKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3VycyA9IG9wdGlvbnMuY29sb3VycyB8fCBvcHRpb25zLmNvbG9ycztcbiAgICBpZiAoaXMuZGVmaW5lZChjb2xvdXJzKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoY29sb3VycykgJiYgaXMuaW5SYW5nZShjb2xvdXJzLCAyLCAyNTYpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5naWZCaXRkZXB0aCA9IGJpdGRlcHRoRnJvbUNvbG91ckNvdW50KGNvbG91cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdjb2xvdXJzJywgJ2ludGVnZXIgYmV0d2VlbiAyIGFuZCAyNTYnLCBjb2xvdXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5lZmZvcnQpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMuZWZmb3J0KSAmJiBpcy5pblJhbmdlKG9wdGlvbnMuZWZmb3J0LCAxLCAxMCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdpZkVmZm9ydCA9IG9wdGlvbnMuZWZmb3J0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdlZmZvcnQnLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwJywgb3B0aW9ucy5lZmZvcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmRpdGhlcikpIHtcbiAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5kaXRoZXIpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5kaXRoZXIsIDAsIDEpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5naWZEaXRoZXIgPSBvcHRpb25zLmRpdGhlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZGl0aGVyJywgJ251bWJlciBiZXR3ZWVuIDAuMCBhbmQgMS4wJywgb3B0aW9ucy5kaXRoZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmludGVyRnJhbWVNYXhFcnJvcikpIHtcbiAgICAgIGlmIChpcy5udW1iZXIob3B0aW9ucy5pbnRlckZyYW1lTWF4RXJyb3IpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5pbnRlckZyYW1lTWF4RXJyb3IsIDAsIDMyKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ2lmSW50ZXJGcmFtZU1heEVycm9yID0gb3B0aW9ucy5pbnRlckZyYW1lTWF4RXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2ludGVyRnJhbWVNYXhFcnJvcicsICdudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDMyLjAnLCBvcHRpb25zLmludGVyRnJhbWVNYXhFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuaW50ZXJQYWxldHRlTWF4RXJyb3IpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMuaW50ZXJQYWxldHRlTWF4RXJyb3IpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5pbnRlclBhbGV0dGVNYXhFcnJvciwgMCwgMjU2KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ2lmSW50ZXJQYWxldHRlTWF4RXJyb3IgPSBvcHRpb25zLmludGVyUGFsZXR0ZU1heEVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdpbnRlclBhbGV0dGVNYXhFcnJvcicsICdudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDI1Ni4wJywgb3B0aW9ucy5pbnRlclBhbGV0dGVNYXhFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMua2VlcER1cGxpY2F0ZUZyYW1lcykpIHtcbiAgICAgIGlmIChpcy5ib29sKG9wdGlvbnMua2VlcER1cGxpY2F0ZUZyYW1lcykpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbignZ2lmS2VlcER1cGxpY2F0ZUZyYW1lcycsIG9wdGlvbnMua2VlcER1cGxpY2F0ZUZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2tlZXBEdXBsaWNhdGVGcmFtZXMnLCAnYm9vbGVhbicsIG9wdGlvbnMua2VlcER1cGxpY2F0ZUZyYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRyeVNldEFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZvcm1hdE91dCgnZ2lmJywgb3B0aW9ucyk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFVzZSB0aGVzZSBKUDIgb3B0aW9ucyBmb3Igb3V0cHV0IGltYWdlLlxuICpcbiAqIFJlcXVpcmVzIGxpYnZpcHMgY29tcGlsZWQgd2l0aCBzdXBwb3J0IGZvciBPcGVuSlBFRy5cbiAqIFRoZSBwcmVidWlsdCBiaW5hcmllcyBkbyBub3QgaW5jbHVkZSB0aGlzIC0gc2VlXG4gKiB7QGxpbmsgaHR0cHM6Ly9zaGFycC5waXhlbHBsdW1iaW5nLmNvbS9pbnN0YWxsI2N1c3RvbS1saWJ2aXBzIGluc3RhbGxpbmcgYSBjdXN0b20gbGlidmlwc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgYW55IGlucHV0IHRvIGxvc3NsZXNzIEpQMiBvdXRwdXRcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLmpwMih7IGxvc3NsZXNzOiB0cnVlIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IGFueSBpbnB1dCB0byB2ZXJ5IGhpZ2ggcXVhbGl0eSBKUDIgb3V0cHV0XG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5qcDIoe1xuICogICAgIHF1YWxpdHk6IDEwMCxcbiAqICAgICBjaHJvbWFTdWJzYW1wbGluZzogJzQ6NDo0J1xuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAc2luY2UgMC4yOS4xXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG91dHB1dCBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhbGl0eT04MF0gLSBxdWFsaXR5LCBpbnRlZ2VyIDEtMTAwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxvc3NsZXNzPWZhbHNlXSAtIHVzZSBsb3NzbGVzcyBjb21wcmVzc2lvbiBtb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGlsZVdpZHRoPTUxMl0gLSBob3Jpem9udGFsIHRpbGUgc2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbGVIZWlnaHQ9NTEyXSAtIHZlcnRpY2FsIHRpbGUgc2l6ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nPSc0OjQ6NCddIC0gc2V0IHRvICc0OjI6MCcgdG8gdXNlIGNocm9tYSBzdWJzYW1wbGluZ1xuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBqcDIgKG9wdGlvbnMpIHtcbiAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLmZvcm1hdC5qcDJrLm91dHB1dC5idWZmZXIpIHtcbiAgICB0aHJvdyBlcnJKcDJTYXZlKCk7XG4gIH1cbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucXVhbGl0eSkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMucXVhbGl0eSkgJiYgaXMuaW5SYW5nZShvcHRpb25zLnF1YWxpdHksIDEsIDEwMCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmpwMlF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3F1YWxpdHknLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwMCcsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMubG9zc2xlc3MpKSB7XG4gICAgICBpZiAoaXMuYm9vbChvcHRpb25zLmxvc3NsZXNzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuanAyTG9zc2xlc3MgPSBvcHRpb25zLmxvc3NsZXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdsb3NzbGVzcycsICdib29sZWFuJywgb3B0aW9ucy5sb3NzbGVzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMudGlsZVdpZHRoKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy50aWxlV2lkdGgpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy50aWxlV2lkdGgsIDEsIDMyNzY4KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuanAyVGlsZVdpZHRoID0gb3B0aW9ucy50aWxlV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RpbGVXaWR0aCcsICdpbnRlZ2VyIGJldHdlZW4gMSBhbmQgMzI3NjgnLCBvcHRpb25zLnRpbGVXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMudGlsZUhlaWdodCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMudGlsZUhlaWdodCkgJiYgaXMuaW5SYW5nZShvcHRpb25zLnRpbGVIZWlnaHQsIDEsIDMyNzY4KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuanAyVGlsZUhlaWdodCA9IG9wdGlvbnMudGlsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGlsZUhlaWdodCcsICdpbnRlZ2VyIGJldHdlZW4gMSBhbmQgMzI3NjgnLCBvcHRpb25zLnRpbGVIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nKSkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nKSAmJiBpcy5pbkFycmF5KG9wdGlvbnMuY2hyb21hU3Vic2FtcGxpbmcsIFsnNDoyOjAnLCAnNDo0OjQnXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmpwMkNocm9tYVN1YnNhbXBsaW5nID0gb3B0aW9ucy5jaHJvbWFTdWJzYW1wbGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignY2hyb21hU3Vic2FtcGxpbmcnLCAnb25lIG9mOiA0OjI6MCwgNDo0OjQnLCBvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZvcm1hdE91dCgnanAyJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogU2V0IGFuaW1hdGlvbiBvcHRpb25zIGlmIGF2YWlsYWJsZS5cbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtzb3VyY2VdIC0gb3V0cHV0IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc291cmNlLmxvb3A9MF0gLSBudW1iZXIgb2YgYW5pbWF0aW9uIGl0ZXJhdGlvbnMsIHVzZSAwIGZvciBpbmZpbml0ZSBhbmltYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyW119IFtzb3VyY2UuZGVsYXldIC0gbGlzdCBvZiBkZWxheXMgYmV0d2VlbiBhbmltYXRpb24gZnJhbWVzIChpbiBtaWxsaXNlY29uZHMpXG4gKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gLSB0YXJnZXQgb2JqZWN0IGZvciB2YWxpZCBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHRyeVNldEFuaW1hdGlvbk9wdGlvbnMgKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIGlmIChpcy5vYmplY3Qoc291cmNlKSAmJiBpcy5kZWZpbmVkKHNvdXJjZS5sb29wKSkge1xuICAgIGlmIChpcy5pbnRlZ2VyKHNvdXJjZS5sb29wKSAmJiBpcy5pblJhbmdlKHNvdXJjZS5sb29wLCAwLCA2NTUzNSkpIHtcbiAgICAgIHRhcmdldC5sb29wID0gc291cmNlLmxvb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignbG9vcCcsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNjU1MzUnLCBzb3VyY2UubG9vcCk7XG4gICAgfVxuICB9XG4gIGlmIChpcy5vYmplY3Qoc291cmNlKSAmJiBpcy5kZWZpbmVkKHNvdXJjZS5kZWxheSkpIHtcbiAgICAvLyBXZSBhbGxvdyBzaW5ndWxhciB2YWx1ZXMgYXMgd2VsbFxuICAgIGlmIChpcy5pbnRlZ2VyKHNvdXJjZS5kZWxheSkgJiYgaXMuaW5SYW5nZShzb3VyY2UuZGVsYXksIDAsIDY1NTM1KSkge1xuICAgICAgdGFyZ2V0LmRlbGF5ID0gW3NvdXJjZS5kZWxheV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoc291cmNlLmRlbGF5KSAmJlxuICAgICAgc291cmNlLmRlbGF5LmV2ZXJ5KGlzLmludGVnZXIpICYmXG4gICAgICBzb3VyY2UuZGVsYXkuZXZlcnkodiA9PiBpcy5pblJhbmdlKHYsIDAsIDY1NTM1KSkpIHtcbiAgICAgIHRhcmdldC5kZWxheSA9IHNvdXJjZS5kZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdkZWxheScsICdpbnRlZ2VyIG9yIGFuIGFycmF5IG9mIGludGVnZXJzIGJldHdlZW4gMCBhbmQgNjU1MzUnLCBzb3VyY2UuZGVsYXkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVzZSB0aGVzZSBUSUZGIG9wdGlvbnMgZm9yIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBUaGUgYGRlbnNpdHlgIGNhbiBiZSBzZXQgaW4gcGl4ZWxzL2luY2ggdmlhIHtAbGluayAjd2l0aG1ldGFkYXRhfHdpdGhNZXRhZGF0YX1cbiAqIGluc3RlYWQgb2YgcHJvdmlkaW5nIGB4cmVzYCBhbmQgYHlyZXNgIGluIHBpeGVscy9tbS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBTVkcgaW5wdXQgdG8gTFpXLWNvbXByZXNzZWQsIDEgYml0IHBlciBwaXhlbCBUSUZGIG91dHB1dFxuICogc2hhcnAoJ2lucHV0LnN2ZycpXG4gKiAgIC50aWZmKHtcbiAqICAgICBjb21wcmVzc2lvbjogJ2x6dycsXG4gKiAgICAgYml0ZGVwdGg6IDFcbiAqICAgfSlcbiAqICAgLnRvRmlsZSgnMS1icHAtb3V0cHV0LnRpZmYnKVxuICogICAudGhlbihpbmZvID0+IHsgLi4uIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvdXRwdXQgb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9ODBdIC0gcXVhbGl0eSwgaW50ZWdlciAxLTEwMFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZT10cnVlXSAtIGZvcmNlIFRJRkYgb3V0cHV0LCBvdGhlcndpc2UgYXR0ZW1wdCB0byB1c2UgaW5wdXQgZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29tcHJlc3Npb249J2pwZWcnXSAtIGNvbXByZXNzaW9uIG9wdGlvbnM6IG5vbmUsIGpwZWcsIGRlZmxhdGUsIHBhY2tiaXRzLCBjY2l0dGZheDQsIGx6dywgd2VicCwgenN0ZCwganAya1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByZWRpY3Rvcj0naG9yaXpvbnRhbCddIC0gY29tcHJlc3Npb24gcHJlZGljdG9yIG9wdGlvbnM6IG5vbmUsIGhvcml6b250YWwsIGZsb2F0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnB5cmFtaWQ9ZmFsc2VdIC0gd3JpdGUgYW4gaW1hZ2UgcHlyYW1pZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aWxlPWZhbHNlXSAtIHdyaXRlIGEgdGlsZWQgdGlmZlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbGVXaWR0aD0yNTZdIC0gaG9yaXpvbnRhbCB0aWxlIHNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50aWxlSGVpZ2h0PTI1Nl0gLSB2ZXJ0aWNhbCB0aWxlIHNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy54cmVzPTEuMF0gLSBob3Jpem9udGFsIHJlc29sdXRpb24gaW4gcGl4ZWxzL21tXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueXJlcz0xLjBdIC0gdmVydGljYWwgcmVzb2x1dGlvbiBpbiBwaXhlbHMvbW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXNvbHV0aW9uVW5pdD0naW5jaCddIC0gcmVzb2x1dGlvbiB1bml0IG9wdGlvbnM6IGluY2gsIGNtXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYml0ZGVwdGg9OF0gLSByZWR1Y2UgYml0ZGVwdGggdG8gMSwgMiBvciA0IGJpdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5taW5pc3doaXRlPWZhbHNlXSAtIHdyaXRlIDEtYml0IGltYWdlcyBhcyBtaW5pc3doaXRlXG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHRpZmYgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucXVhbGl0eSkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMucXVhbGl0eSkgJiYgaXMuaW5SYW5nZShvcHRpb25zLnF1YWxpdHksIDEsIDEwMCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpZmZRdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdxdWFsaXR5JywgJ2ludGVnZXIgYmV0d2VlbiAxIGFuZCAxMDAnLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmJpdGRlcHRoKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5iaXRkZXB0aCkgJiYgaXMuaW5BcnJheShvcHRpb25zLmJpdGRlcHRoLCBbMSwgMiwgNCwgOF0pKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aWZmQml0ZGVwdGggPSBvcHRpb25zLmJpdGRlcHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdiaXRkZXB0aCcsICcxLCAyLCA0IG9yIDgnLCBvcHRpb25zLmJpdGRlcHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdGlsaW5nXG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy50aWxlKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbigndGlmZlRpbGUnLCBvcHRpb25zLnRpbGUpO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnRpbGVXaWR0aCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMudGlsZVdpZHRoKSAmJiBvcHRpb25zLnRpbGVXaWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpZmZUaWxlV2lkdGggPSBvcHRpb25zLnRpbGVXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigndGlsZVdpZHRoJywgJ2ludGVnZXIgZ3JlYXRlciB0aGFuIHplcm8nLCBvcHRpb25zLnRpbGVXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMudGlsZUhlaWdodCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMudGlsZUhlaWdodCkgJiYgb3B0aW9ucy50aWxlSGVpZ2h0ID4gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGlmZlRpbGVIZWlnaHQgPSBvcHRpb25zLnRpbGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RpbGVIZWlnaHQnLCAnaW50ZWdlciBncmVhdGVyIHRoYW4gemVybycsIG9wdGlvbnMudGlsZUhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG1pbmlzd2hpdGVcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLm1pbmlzd2hpdGUpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd0aWZmTWluaXN3aGl0ZScsIG9wdGlvbnMubWluaXN3aGl0ZSk7XG4gICAgfVxuICAgIC8vIHB5cmFtaWRcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnB5cmFtaWQpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd0aWZmUHlyYW1pZCcsIG9wdGlvbnMucHlyYW1pZCk7XG4gICAgfVxuICAgIC8vIHJlc29sdXRpb25cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnhyZXMpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMueHJlcykgJiYgb3B0aW9ucy54cmVzID4gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGlmZlhyZXMgPSBvcHRpb25zLnhyZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3hyZXMnLCAnbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvJywgb3B0aW9ucy54cmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy55cmVzKSkge1xuICAgICAgaWYgKGlzLm51bWJlcihvcHRpb25zLnlyZXMpICYmIG9wdGlvbnMueXJlcyA+IDApIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpZmZZcmVzID0gb3B0aW9ucy55cmVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd5cmVzJywgJ251bWJlciBncmVhdGVyIHRoYW4gemVybycsIG9wdGlvbnMueXJlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbXByZXNzaW9uXG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5jb21wcmVzc2lvbikpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5jb21wcmVzc2lvbikgJiYgaXMuaW5BcnJheShvcHRpb25zLmNvbXByZXNzaW9uLCBbJ25vbmUnLCAnanBlZycsICdkZWZsYXRlJywgJ3BhY2tiaXRzJywgJ2NjaXR0ZmF4NCcsICdsencnLCAnd2VicCcsICd6c3RkJywgJ2pwMmsnXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpZmZDb21wcmVzc2lvbiA9IG9wdGlvbnMuY29tcHJlc3Npb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2NvbXByZXNzaW9uJywgJ29uZSBvZjogbm9uZSwganBlZywgZGVmbGF0ZSwgcGFja2JpdHMsIGNjaXR0ZmF4NCwgbHp3LCB3ZWJwLCB6c3RkLCBqcDJrJywgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByZWRpY3RvclxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucHJlZGljdG9yKSkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLnByZWRpY3RvcikgJiYgaXMuaW5BcnJheShvcHRpb25zLnByZWRpY3RvciwgWydub25lJywgJ2hvcml6b250YWwnLCAnZmxvYXQnXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpZmZQcmVkaWN0b3IgPSBvcHRpb25zLnByZWRpY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncHJlZGljdG9yJywgJ29uZSBvZjogbm9uZSwgaG9yaXpvbnRhbCwgZmxvYXQnLCBvcHRpb25zLnByZWRpY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlc29sdXRpb25Vbml0XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5yZXNvbHV0aW9uVW5pdCkpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5yZXNvbHV0aW9uVW5pdCkgJiYgaXMuaW5BcnJheShvcHRpb25zLnJlc29sdXRpb25Vbml0LCBbJ2luY2gnLCAnY20nXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpZmZSZXNvbHV0aW9uVW5pdCA9IG9wdGlvbnMucmVzb2x1dGlvblVuaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3Jlc29sdXRpb25Vbml0JywgJ29uZSBvZjogaW5jaCwgY20nLCBvcHRpb25zLnJlc29sdXRpb25Vbml0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZvcm1hdE91dCgndGlmZicsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFVzZSB0aGVzZSBBVklGIG9wdGlvbnMgZm9yIG91dHB1dCBpbWFnZS5cbiAqXG4gKiBBVklGIGltYWdlIHNlcXVlbmNlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqIFByZWJ1aWx0IGJpbmFyaWVzIHN1cHBvcnQgYSBiaXRkZXB0aCBvZiA4IG9ubHkuXG4gKlxuICogVGhpcyBmZWF0dXJlIGlzIGV4cGVyaW1lbnRhbCBvbiB0aGUgV2luZG93cyBBUk02NCBwbGF0Zm9ybVxuICogYW5kIHJlcXVpcmVzIGEgQ1BVIHdpdGggQVJNNjR2OC40IG9yIGxhdGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5hdmlmKHsgZWZmb3J0OiAyIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5hdmlmKHsgbG9zc2xlc3M6IHRydWUgfSlcbiAqICAgLnRvQnVmZmVyKCk7XG4gKlxuICogQHNpbmNlIDAuMjcuMFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvdXRwdXQgb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9NTBdIC0gcXVhbGl0eSwgaW50ZWdlciAxLTEwMFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sb3NzbGVzcz1mYWxzZV0gLSB1c2UgbG9zc2xlc3MgY29tcHJlc3Npb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5lZmZvcnQ9NF0gLSBDUFUgZWZmb3J0LCBiZXR3ZWVuIDAgKGZhc3Rlc3QpIGFuZCA5IChzbG93ZXN0KVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nPSc0OjQ6NCddIC0gc2V0IHRvICc0OjI6MCcgdG8gdXNlIGNocm9tYSBzdWJzYW1wbGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJpdGRlcHRoPThdIC0gc2V0IGJpdGRlcHRoIHRvIDgsIDEwIG9yIDEyIGJpdFxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhdmlmIChvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmhlaWYoeyAuLi5vcHRpb25zLCBjb21wcmVzc2lvbjogJ2F2MScgfSk7XG59XG5cbi8qKlxuICogVXNlIHRoZXNlIEhFSUYgb3B0aW9ucyBmb3Igb3V0cHV0IGltYWdlLlxuICpcbiAqIFN1cHBvcnQgZm9yIHBhdGVudC1lbmN1bWJlcmVkIEhFSUMgaW1hZ2VzIHVzaW5nIGBoZXZjYCBjb21wcmVzc2lvbiByZXF1aXJlcyB0aGUgdXNlIG9mIGFcbiAqIGdsb2JhbGx5LWluc3RhbGxlZCBsaWJ2aXBzIGNvbXBpbGVkIHdpdGggc3VwcG9ydCBmb3IgbGliaGVpZiwgbGliZGUyNjUgYW5kIHgyNjUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLmhlaWYoeyBjb21wcmVzc2lvbjogJ2hldmMnIH0pXG4gKiAgIC50b0J1ZmZlcigpO1xuICpcbiAqIEBzaW5jZSAwLjIzLjBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG91dHB1dCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb21wcmVzc2lvbiAtIGNvbXByZXNzaW9uIGZvcm1hdDogYXYxLCBoZXZjXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhbGl0eT01MF0gLSBxdWFsaXR5LCBpbnRlZ2VyIDEtMTAwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxvc3NsZXNzPWZhbHNlXSAtIHVzZSBsb3NzbGVzcyBjb21wcmVzc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmVmZm9ydD00XSAtIENQVSBlZmZvcnQsIGJldHdlZW4gMCAoZmFzdGVzdCkgYW5kIDkgKHNsb3dlc3QpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2hyb21hU3Vic2FtcGxpbmc9JzQ6NDo0J10gLSBzZXQgdG8gJzQ6MjowJyB0byB1c2UgY2hyb21hIHN1YnNhbXBsaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYml0ZGVwdGg9OF0gLSBzZXQgYml0ZGVwdGggdG8gOCwgMTAgb3IgMTIgYml0XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGhlaWYgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5jb21wcmVzc2lvbikgJiYgaXMuaW5BcnJheShvcHRpb25zLmNvbXByZXNzaW9uLCBbJ2F2MScsICdoZXZjJ10pKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaGVpZkNvbXByZXNzaW9uID0gb3B0aW9ucy5jb21wcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdjb21wcmVzc2lvbicsICdvbmUgb2Y6IGF2MSwgaGV2YycsIG9wdGlvbnMuY29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnF1YWxpdHkpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLnF1YWxpdHkpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5xdWFsaXR5LCAxLCAxMDApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWlmUXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncXVhbGl0eScsICdpbnRlZ2VyIGJldHdlZW4gMSBhbmQgMTAwJywgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5sb3NzbGVzcykpIHtcbiAgICAgIGlmIChpcy5ib29sKG9wdGlvbnMubG9zc2xlc3MpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWlmTG9zc2xlc3MgPSBvcHRpb25zLmxvc3NsZXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdsb3NzbGVzcycsICdib29sZWFuJywgb3B0aW9ucy5sb3NzbGVzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuZWZmb3J0KSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5lZmZvcnQpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5lZmZvcnQsIDAsIDkpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWlmRWZmb3J0ID0gb3B0aW9ucy5lZmZvcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2VmZm9ydCcsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgOScsIG9wdGlvbnMuZWZmb3J0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5jaHJvbWFTdWJzYW1wbGluZykpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5jaHJvbWFTdWJzYW1wbGluZykgJiYgaXMuaW5BcnJheShvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nLCBbJzQ6MjowJywgJzQ6NDo0J10pKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWlmQ2hyb21hU3Vic2FtcGxpbmcgPSBvcHRpb25zLmNocm9tYVN1YnNhbXBsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdjaHJvbWFTdWJzYW1wbGluZycsICdvbmUgb2Y6IDQ6MjowLCA0OjQ6NCcsIG9wdGlvbnMuY2hyb21hU3Vic2FtcGxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmJpdGRlcHRoKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5iaXRkZXB0aCkgJiYgaXMuaW5BcnJheShvcHRpb25zLmJpdGRlcHRoLCBbOCwgMTAsIDEyXSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYml0ZGVwdGggIT09IDggJiYgdGhpcy5jb25zdHJ1Y3Rvci52ZXJzaW9ucy5oZWlmKSB7XG4gICAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdiaXRkZXB0aCB3aGVuIHVzaW5nIHByZWJ1aWx0IGJpbmFyaWVzJywgOCwgb3B0aW9ucy5iaXRkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLmhlaWZCaXRkZXB0aCA9IG9wdGlvbnMuYml0ZGVwdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2JpdGRlcHRoJywgJzgsIDEwIG9yIDEyJywgb3B0aW9ucy5iaXRkZXB0aCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fdXBkYXRlRm9ybWF0T3V0KCdoZWlmJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXNlIHRoZXNlIEpQRUctWEwgKEpYTCkgb3B0aW9ucyBmb3Igb3V0cHV0IGltYWdlLlxuICpcbiAqIFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWwsIHBsZWFzZSBkbyBub3QgdXNlIGluIHByb2R1Y3Rpb24gc3lzdGVtcy5cbiAqXG4gKiBSZXF1aXJlcyBsaWJ2aXBzIGNvbXBpbGVkIHdpdGggc3VwcG9ydCBmb3IgbGlianhsLlxuICogVGhlIHByZWJ1aWx0IGJpbmFyaWVzIGRvIG5vdCBpbmNsdWRlIHRoaXMgLSBzZWVcbiAqIHtAbGluayBodHRwczovL3NoYXJwLnBpeGVscGx1bWJpbmcuY29tL2luc3RhbGwjY3VzdG9tLWxpYnZpcHMgaW5zdGFsbGluZyBhIGN1c3RvbSBsaWJ2aXBzfS5cbiAqXG4gKiBAc2luY2UgMC4zMS4zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG91dHB1dCBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGlzdGFuY2U9MS4wXSAtIG1heGltdW0gZW5jb2RpbmcgZXJyb3IsIGJldHdlZW4gMCAoaGlnaGVzdCBxdWFsaXR5KSBhbmQgMTUgKGxvd2VzdCBxdWFsaXR5KVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnF1YWxpdHldIC0gY2FsY3VsYXRlIGBkaXN0YW5jZWAgYmFzZWQgb24gSlBFRy1saWtlIHF1YWxpdHksIGJldHdlZW4gMSBhbmQgMTAwLCBvdmVycmlkZXMgZGlzdGFuY2UgaWYgc3BlY2lmaWVkXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVjb2RpbmdUaWVyPTBdIC0gdGFyZ2V0IGRlY29kZSBzcGVlZCB0aWVyLCBiZXR3ZWVuIDAgKGhpZ2hlc3QgcXVhbGl0eSkgYW5kIDQgKGxvd2VzdCBxdWFsaXR5KVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sb3NzbGVzcz1mYWxzZV0gLSB1c2UgbG9zc2xlc3MgY29tcHJlc3Npb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5lZmZvcnQ9N10gLSBDUFUgZWZmb3J0LCBiZXR3ZWVuIDEgKGZhc3Rlc3QpIGFuZCA5IChzbG93ZXN0KVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3A9MF0gLSBudW1iZXIgb2YgYW5pbWF0aW9uIGl0ZXJhdGlvbnMsIHVzZSAwIGZvciBpbmZpbml0ZSBhbmltYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbb3B0aW9ucy5kZWxheV0gLSBkZWxheShzKSBiZXR3ZWVuIGFuaW1hdGlvbiBmcmFtZXMgKGluIG1pbGxpc2Vjb25kcylcbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24ganhsIChvcHRpb25zKSB7XG4gIGlmIChpcy5vYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLnF1YWxpdHkpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLnF1YWxpdHkpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5xdWFsaXR5LCAxLCAxMDApKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJqeGwvbGlianhsL2Jsb2IvMGFlZWE3ZjE4MGJhZmQ2ODkzYzFkYjgwNzJkY2I2N2QyYWE1YjAzZC90b29scy9janhsX21haW4uY2MjTDY0MC1MNjQ0XG4gICAgICAgIHRoaXMub3B0aW9ucy5qeGxEaXN0YW5jZSA9IG9wdGlvbnMucXVhbGl0eSA+PSAzMFxuICAgICAgICAgID8gMC4xICsgKDEwMCAtIG9wdGlvbnMucXVhbGl0eSkgKiAwLjA5XG4gICAgICAgICAgOiA1MyAvIDMwMDAgKiBvcHRpb25zLnF1YWxpdHkgKiBvcHRpb25zLnF1YWxpdHkgLSAyMyAvIDIwICogb3B0aW9ucy5xdWFsaXR5ICsgMjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3F1YWxpdHknLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDEwMCcsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuZGlzdGFuY2UpKSB7XG4gICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMuZGlzdGFuY2UpICYmIGlzLmluUmFuZ2Uob3B0aW9ucy5kaXN0YW5jZSwgMCwgMTUpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5qeGxEaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2Rpc3RhbmNlJywgJ251bWJlciBiZXR3ZWVuIDAuMCBhbmQgMTUuMCcsIG9wdGlvbnMuZGlzdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmRlY29kaW5nVGllcikpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuZGVjb2RpbmdUaWVyKSAmJiBpcy5pblJhbmdlKG9wdGlvbnMuZGVjb2RpbmdUaWVyLCAwLCA0KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuanhsRGVjb2RpbmdUaWVyID0gb3B0aW9ucy5kZWNvZGluZ1RpZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2RlY29kaW5nVGllcicsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNCcsIG9wdGlvbnMuZGVjb2RpbmdUaWVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5sb3NzbGVzcykpIHtcbiAgICAgIGlmIChpcy5ib29sKG9wdGlvbnMubG9zc2xlc3MpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5qeGxMb3NzbGVzcyA9IG9wdGlvbnMubG9zc2xlc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2xvc3NsZXNzJywgJ2Jvb2xlYW4nLCBvcHRpb25zLmxvc3NsZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5lZmZvcnQpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLmVmZm9ydCkgJiYgaXMuaW5SYW5nZShvcHRpb25zLmVmZm9ydCwgMSwgOSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmp4bEVmZm9ydCA9IG9wdGlvbnMuZWZmb3J0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdlZmZvcnQnLCAnaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDknLCBvcHRpb25zLmVmZm9ydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRyeVNldEFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZvcm1hdE91dCgnanhsJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogRm9yY2Ugb3V0cHV0IHRvIGJlIHJhdywgdW5jb21wcmVzc2VkIHBpeGVsIGRhdGEuXG4gKiBQaXhlbCBvcmRlcmluZyBpcyBsZWZ0LXRvLXJpZ2h0LCB0b3AtdG8tYm90dG9tLCB3aXRob3V0IHBhZGRpbmcuXG4gKiBDaGFubmVsIG9yZGVyaW5nIHdpbGwgYmUgUkdCIG9yIFJHQkEgZm9yIG5vbi1ncmV5c2NhbGUgY29sb3Vyc3BhY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFeHRyYWN0IHJhdywgdW5zaWduZWQgOC1iaXQgUkdCIHBpeGVsIGRhdGEgZnJvbSBKUEVHIGlucHV0XG4gKiBjb25zdCB7IGRhdGEsIGluZm8gfSA9IGF3YWl0IHNoYXJwKCdpbnB1dC5qcGcnKVxuICogICAucmF3KClcbiAqICAgLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4dHJhY3QgYWxwaGEgY2hhbm5lbCBhcyByYXcsIHVuc2lnbmVkIDE2LWJpdCBwaXhlbCBkYXRhIGZyb20gUE5HIGlucHV0XG4gKiBjb25zdCBkYXRhID0gYXdhaXQgc2hhcnAoJ2lucHV0LnBuZycpXG4gKiAgIC5lbnN1cmVBbHBoYSgpXG4gKiAgIC5leHRyYWN0Q2hhbm5lbCgzKVxuICogICAudG9Db2xvdXJzcGFjZSgnYi13JylcbiAqICAgLnJhdyh7IGRlcHRoOiAndXNob3J0JyB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3V0cHV0IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXB0aD0ndWNoYXInXSAtIGJpdCBkZXB0aCwgb25lIG9mOiBjaGFyLCB1Y2hhciAoZGVmYXVsdCksIHNob3J0LCB1c2hvcnQsIGludCwgdWludCwgZmxvYXQsIGNvbXBsZXgsIGRvdWJsZSwgZHBjb21wbGV4XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHJhdyAob3B0aW9ucykge1xuICBpZiAoaXMub2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5kZXB0aCkpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5kZXB0aCkgJiYgaXMuaW5BcnJheShvcHRpb25zLmRlcHRoLFxuICAgICAgICBbJ2NoYXInLCAndWNoYXInLCAnc2hvcnQnLCAndXNob3J0JywgJ2ludCcsICd1aW50JywgJ2Zsb2F0JywgJ2NvbXBsZXgnLCAnZG91YmxlJywgJ2RwY29tcGxleCddXG4gICAgICApKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yYXdEZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2RlcHRoJywgJ29uZSBvZjogY2hhciwgdWNoYXIsIHNob3J0LCB1c2hvcnQsIGludCwgdWludCwgZmxvYXQsIGNvbXBsZXgsIGRvdWJsZSwgZHBjb21wbGV4Jywgb3B0aW9ucy5kZXB0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLl91cGRhdGVGb3JtYXRPdXQoJ3JhdycpO1xufVxuXG4vKipcbiAqIFVzZSB0aWxlLWJhc2VkIGRlZXAgem9vbSAoaW1hZ2UgcHlyYW1pZCkgb3V0cHV0LlxuICpcbiAqIFNldCB0aGUgZm9ybWF0IGFuZCBvcHRpb25zIGZvciB0aWxlIGltYWdlcyB2aWEgdGhlIGB0b0Zvcm1hdGAsIGBqcGVnYCwgYHBuZ2Agb3IgYHdlYnBgIGZ1bmN0aW9ucy5cbiAqIFVzZSBhIGAuemlwYCBvciBgLnN6aWAgZmlsZSBleHRlbnNpb24gd2l0aCBgdG9GaWxlYCB0byB3cml0ZSB0byBhIGNvbXByZXNzZWQgYXJjaGl2ZSBmaWxlIGZvcm1hdC5cbiAqXG4gKiBUaGUgY29udGFpbmVyIHdpbGwgYmUgc2V0IHRvIGB6aXBgIHdoZW4gdGhlIG91dHB1dCBpcyBhIEJ1ZmZlciBvciBTdHJlYW0sIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gYGZzYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIHNoYXJwKCdpbnB1dC50aWZmJylcbiAqICAgLnBuZygpXG4gKiAgIC50aWxlKHtcbiAqICAgICBzaXplOiA1MTJcbiAqICAgfSlcbiAqICAgLnRvRmlsZSgnb3V0cHV0LmR6JywgZnVuY3Rpb24oZXJyLCBpbmZvKSB7XG4gKiAgICAgLy8gb3V0cHV0LmR6aSBpcyB0aGUgRGVlcCBab29tIFhNTCBkZWZpbml0aW9uXG4gKiAgICAgLy8gb3V0cHV0X2ZpbGVzIGNvbnRhaW5zIDUxMng1MTIgdGlsZXMgZ3JvdXBlZCBieSB6b29tIGxldmVsXG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB6aXBGaWxlV2l0aFRpbGVzID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC50aWxlKHsgYmFzZW5hbWU6IFwidGlsZXNcIiB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgaWlpZmlmaWVyID0gc2hhcnAoKS50aWxlKHsgbGF5b3V0OiBcImlpaWZcIiB9KTtcbiAqIHJlYWRhYmxlU3RyZWFtXG4gKiAgIC5waXBlKGlpaWZpZmllcilcbiAqICAgLnBpcGUod3JpdGVhYmxlU3RyZWFtKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2l6ZT0yNTZdIHRpbGUgc2l6ZSBpbiBwaXhlbHMsIGEgdmFsdWUgYmV0d2VlbiAxIGFuZCA4MTkyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm92ZXJsYXA9MF0gdGlsZSBvdmVybGFwIGluIHBpeGVscywgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDgxOTIuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYW5nbGU9MF0gdGlsZSBhbmdsZSBvZiByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwLlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbb3B0aW9ucy5iYWNrZ3JvdW5kPXtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhbHBoYTogMX1dIC0gYmFja2dyb3VuZCBjb2xvdXIsIHBhcnNlZCBieSB0aGUgW2NvbG9yXShodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9jb2xvcikgbW9kdWxlLCBkZWZhdWx0cyB0byB3aGl0ZSB3aXRob3V0IHRyYW5zcGFyZW5jeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXB0aF0gaG93IGRlZXAgdG8gbWFrZSB0aGUgcHlyYW1pZCwgcG9zc2libGUgdmFsdWVzIGFyZSBgb25lcGl4ZWxgLCBgb25ldGlsZWAgb3IgYG9uZWAsIGRlZmF1bHQgYmFzZWQgb24gbGF5b3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNraXBCbGFua3M9LTFdIFRocmVzaG9sZCB0byBza2lwIHRpbGUgZ2VuZXJhdGlvbi4gUmFuZ2UgaXMgMC0yNTUgZm9yIDgtYml0IGltYWdlcywgMC02NTUzNSBmb3IgMTYtYml0IGltYWdlcy4gRGVmYXVsdCBpcyA1IGZvciBgZ29vZ2xlYCBsYXlvdXQsIC0xIChubyBza2lwKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29udGFpbmVyPSdmcyddIHRpbGUgY29udGFpbmVyLCB3aXRoIHZhbHVlIGBmc2AgKGZpbGVzeXN0ZW0pIG9yIGB6aXBgIChjb21wcmVzc2VkIGZpbGUpLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxheW91dD0nZHonXSBmaWxlc3lzdGVtIGxheW91dCwgcG9zc2libGUgdmFsdWVzIGFyZSBgZHpgLCBgaWlpZmAsIGBpaWlmM2AsIGB6b29taWZ5YCBvciBgZ29vZ2xlYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2VudHJlPWZhbHNlXSBjZW50cmUgaW1hZ2UgaW4gdGlsZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2VudGVyPWZhbHNlXSBhbHRlcm5hdGl2ZSBzcGVsbGluZyBvZiBjZW50cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J2h0dHBzOi8vZXhhbXBsZS5jb20vaWlpZiddIHdoZW4gYGxheW91dGAgaXMgYGlpaWZgL2BpaWlmM2AsIHNldHMgdGhlIGBAaWRgL2BpZGAgYXR0cmlidXRlIG9mIGBpbmZvLmpzb25gXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmFzZW5hbWVdIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3Rvcnkgd2l0aGluIHRoZSB6aXAgZmlsZSB3aGVuIGNvbnRhaW5lciBpcyBgemlwYC5cbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJbnZhbGlkIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gdGlsZSAob3B0aW9ucykge1xuICBpZiAoaXMub2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgLy8gU2l6ZSBvZiBzcXVhcmUgdGlsZXMsIGluIHBpeGVsc1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuc2l6ZSkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuc2l6ZSkgJiYgaXMuaW5SYW5nZShvcHRpb25zLnNpemUsIDEsIDgxOTIpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignc2l6ZScsICdpbnRlZ2VyIGJldHdlZW4gMSBhbmQgODE5MicsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE92ZXJsYXAgb2YgdGlsZXMsIGluIHBpeGVsc1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMub3ZlcmxhcCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMub3ZlcmxhcCkgJiYgaXMuaW5SYW5nZShvcHRpb25zLm92ZXJsYXAsIDAsIDgxOTIpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJsYXAgPiB0aGlzLm9wdGlvbnMudGlsZVNpemUpIHtcbiAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ292ZXJsYXAnLCBgPD0gc2l6ZSAoJHt0aGlzLm9wdGlvbnMudGlsZVNpemV9KWAsIG9wdGlvbnMub3ZlcmxhcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnRpbGVPdmVybGFwID0gb3B0aW9ucy5vdmVybGFwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvdmVybGFwJywgJ2ludGVnZXIgYmV0d2VlbiAwIGFuZCA4MTkyJywgb3B0aW9ucy5vdmVybGFwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGFpbmVyXG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5jb250YWluZXIpKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKG9wdGlvbnMuY29udGFpbmVyKSAmJiBpcy5pbkFycmF5KG9wdGlvbnMuY29udGFpbmVyLCBbJ2ZzJywgJ3ppcCddKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGlsZUNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdjb250YWluZXInLCAnb25lIG9mOiBmcywgemlwJywgb3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBMYXlvdXRcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmxheW91dCkpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5sYXlvdXQpICYmIGlzLmluQXJyYXkob3B0aW9ucy5sYXlvdXQsIFsnZHonLCAnZ29vZ2xlJywgJ2lpaWYnLCAnaWlpZjMnLCAnem9vbWlmeSddKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGlsZUxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdsYXlvdXQnLCAnb25lIG9mOiBkeiwgZ29vZ2xlLCBpaWlmLCBpaWlmMywgem9vbWlmeScsIG9wdGlvbnMubGF5b3V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQW5nbGUgb2Ygcm90YXRpb24sXG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5hbmdsZSkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuYW5nbGUpICYmICEob3B0aW9ucy5hbmdsZSAlIDkwKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGlsZUFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignYW5nbGUnLCAncG9zaXRpdmUvbmVnYXRpdmUgbXVsdGlwbGUgb2YgOTAnLCBvcHRpb25zLmFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFja2dyb3VuZCBjb2xvdXJcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3VyT3B0aW9uKCd0aWxlQmFja2dyb3VuZCcsIG9wdGlvbnMuYmFja2dyb3VuZCk7XG4gICAgLy8gRGVwdGggb2YgdGlsZXNcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmRlcHRoKSkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLmRlcHRoKSAmJiBpcy5pbkFycmF5KG9wdGlvbnMuZGVwdGgsIFsnb25lcGl4ZWwnLCAnb25ldGlsZScsICdvbmUnXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpbGVEZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2RlcHRoJywgJ29uZSBvZjogb25lcGl4ZWwsIG9uZXRpbGUsIG9uZScsIG9wdGlvbnMuZGVwdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaHJlc2hvbGQgdG8gc2tpcCBibGFuayB0aWxlc1xuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuc2tpcEJsYW5rcykpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuc2tpcEJsYW5rcykgJiYgaXMuaW5SYW5nZShvcHRpb25zLnNraXBCbGFua3MsIC0xLCA2NTUzNSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpbGVTa2lwQmxhbmtzID0gb3B0aW9ucy5za2lwQmxhbmtzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdza2lwQmxhbmtzJywgJ2ludGVnZXIgYmV0d2VlbiAtMSBhbmQgMjU1LzY1NTM1Jywgb3B0aW9ucy5za2lwQmxhbmtzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5sYXlvdXQpICYmIG9wdGlvbnMubGF5b3V0ID09PSAnZ29vZ2xlJykge1xuICAgICAgdGhpcy5vcHRpb25zLnRpbGVTa2lwQmxhbmtzID0gNTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIGltYWdlIGluIHRpbGVcbiAgICBjb25zdCBjZW50cmUgPSBpcy5ib29sKG9wdGlvbnMuY2VudGVyKSA/IG9wdGlvbnMuY2VudGVyIDogb3B0aW9ucy5jZW50cmU7XG4gICAgaWYgKGlzLmRlZmluZWQoY2VudHJlKSkge1xuICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbigndGlsZUNlbnRyZScsIGNlbnRyZSk7XG4gICAgfVxuICAgIC8vIEBpZCBhdHRyaWJ1dGUgZm9yIElJSUYgbGF5b3V0XG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5pZCkpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5pZCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpbGVJZCA9IG9wdGlvbnMuaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2lkJywgJ3N0cmluZycsIG9wdGlvbnMuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBCYXNlbmFtZSBmb3IgemlwIGNvbnRhaW5lclxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuYmFzZW5hbWUpKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKG9wdGlvbnMuYmFzZW5hbWUpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aWxlQmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdiYXNlbmFtZScsICdzdHJpbmcnLCBvcHRpb25zLmJhc2VuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRm9ybWF0XG4gIGlmIChpcy5pbkFycmF5KHRoaXMub3B0aW9ucy5mb3JtYXRPdXQsIFsnanBlZycsICdwbmcnLCAnd2VicCddKSkge1xuICAgIHRoaXMub3B0aW9ucy50aWxlRm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdE91dDtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0T3V0ICE9PSAnaW5wdXQnKSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdmb3JtYXQnLCAnb25lIG9mOiBqcGVnLCBwbmcsIHdlYnAnLCB0aGlzLm9wdGlvbnMuZm9ybWF0T3V0KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fdXBkYXRlRm9ybWF0T3V0KCdkeicpO1xufVxuXG4vKipcbiAqIFNldCBhIHRpbWVvdXQgZm9yIHByb2Nlc3NpbmcsIGluIHNlY29uZHMuXG4gKiBVc2UgYSB2YWx1ZSBvZiB6ZXJvIHRvIGNvbnRpbnVlIHByb2Nlc3NpbmcgaW5kZWZpbml0ZWx5LCB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuXG4gKlxuICogVGhlIGNsb2NrIHN0YXJ0cyB3aGVuIGxpYnZpcHMgb3BlbnMgYW4gaW5wdXQgaW1hZ2UgZm9yIHByb2Nlc3NpbmcuXG4gKiBUaW1lIHNwZW50IHdhaXRpbmcgZm9yIGEgbGlidXYgdGhyZWFkIHRvIGJlY29tZSBhdmFpbGFibGUgaXMgbm90IGluY2x1ZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFbnN1cmUgcHJvY2Vzc2luZyB0YWtlcyBubyBsb25nZXIgdGhhbiAzIHNlY29uZHNcbiAqIHRyeSB7XG4gKiAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgICAuYmx1cigxMDAwKVxuICogICAgIC50aW1lb3V0KHsgc2Vjb25kczogMyB9KVxuICogICAgIC50b0J1ZmZlcigpO1xuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcygndGltZW91dCcpKSB7IC4uLiB9XG4gKiB9XG4gKlxuICogQHNpbmNlIDAuMjkuMlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggcHJvY2Vzc2luZyB3aWxsIGJlIHN0b3BwZWRcbiAqIEByZXR1cm5zIHtTaGFycH1cbiAqL1xuZnVuY3Rpb24gdGltZW91dCAob3B0aW9ucykge1xuICBpZiAoIWlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdvcHRpb25zJywgJ29iamVjdCcsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpcy5pbnRlZ2VyKG9wdGlvbnMuc2Vjb25kcykgJiYgaXMuaW5SYW5nZShvcHRpb25zLnNlY29uZHMsIDAsIDM2MDApKSB7XG4gICAgdGhpcy5vcHRpb25zLnRpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy5zZWNvbmRzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignc2Vjb25kcycsICdpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMzYwMCcsIG9wdGlvbnMuc2Vjb25kcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBvdXRwdXQgZm9ybWF0IHVubGVzcyBvcHRpb25zLmZvcmNlIGlzIGZhbHNlLFxuICogaW4gd2hpY2ggY2FzZSByZXZlcnQgdG8gaW5wdXQgZm9ybWF0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXRPdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2U9dHJ1ZV0gLSBmb3JjZSBvdXRwdXQgZm9ybWF0LCBvdGhlcndpc2UgYXR0ZW1wdCB0byB1c2UgaW5wdXQgZm9ybWF0XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVGb3JtYXRPdXQgKGZvcm1hdE91dCwgb3B0aW9ucykge1xuICBpZiAoIShpcy5vYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucy5mb3JjZSA9PT0gZmFsc2UpKSB7XG4gICAgdGhpcy5vcHRpb25zLmZvcm1hdE91dCA9IGZvcm1hdE91dDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvZiB0aGUgdGhpcy5vcHRpb25zIE9iamVjdC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQga2V5XG4gKi9cbmZ1bmN0aW9uIF9zZXRCb29sZWFuT3B0aW9uIChrZXksIHZhbCkge1xuICBpZiAoaXMuYm9vbCh2YWwpKSB7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKGtleSwgJ2Jvb2xlYW4nLCB2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbGVkIGJ5IGEgV3JpdGVhYmxlU3RyZWFtIHRvIG5vdGlmeSB1cyBpdCBpcyByZWFkeSBmb3IgZGF0YS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZWFkICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyZWFtT3V0KSB7XG4gICAgdGhpcy5vcHRpb25zLnN0cmVhbU91dCA9IHRydWU7XG4gICAgY29uc3Qgc3RhY2sgPSBFcnJvcigpO1xuICAgIHRoaXMuX3BpcGVsaW5lKHVuZGVmaW5lZCwgc3RhY2spO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlIHRoZSBDKysgaW1hZ2UgcHJvY2Vzc2luZyBwaXBlbGluZVxuICogU3VwcG9ydHMgY2FsbGJhY2ssIHN0cmVhbSBhbmQgcHJvbWlzZSB2YXJpYW50c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3BpcGVsaW5lIChjYWxsYmFjaywgc3RhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIG91dHB1dD1maWxlL2J1ZmZlclxuICAgIGlmICh0aGlzLl9pc1N0cmVhbUlucHV0KCkpIHtcbiAgICAgIC8vIG91dHB1dD1maWxlL2J1ZmZlciwgaW5wdXQ9c3RyZWFtXG4gICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5CdWZmZXJJbigpO1xuICAgICAgICBzaGFycC5waXBlbGluZSh0aGlzLm9wdGlvbnMsIChlcnIsIGRhdGEsIGluZm8pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhpcy5uYXRpdmVFcnJvcihlcnIsIHN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEsIGluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3V0cHV0PWZpbGUvYnVmZmVyLCBpbnB1dD1maWxlL2J1ZmZlclxuICAgICAgc2hhcnAucGlwZWxpbmUodGhpcy5vcHRpb25zLCAoZXJyLCBkYXRhLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhpcy5uYXRpdmVFcnJvcihlcnIsIHN0YWNrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3RyZWFtT3V0KSB7XG4gICAgLy8gb3V0cHV0PXN0cmVhbVxuICAgIGlmICh0aGlzLl9pc1N0cmVhbUlucHV0KCkpIHtcbiAgICAgIC8vIG91dHB1dD1zdHJlYW0sIGlucHV0PXN0cmVhbVxuICAgICAgdGhpcy5vbmNlKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5CdWZmZXJJbigpO1xuICAgICAgICBzaGFycC5waXBlbGluZSh0aGlzLm9wdGlvbnMsIChlcnIsIGRhdGEsIGluZm8pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2luZm8nLCBpbmZvKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHRoaXMuZW1pdCgnY2xvc2UnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zdHJlYW1JbkZpbmlzaGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG91dHB1dD1zdHJlYW0sIGlucHV0PWZpbGUvYnVmZmVyXG4gICAgICBzaGFycC5waXBlbGluZSh0aGlzLm9wdGlvbnMsIChlcnIsIGRhdGEsIGluZm8pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBpcy5uYXRpdmVFcnJvcihlcnIsIHN0YWNrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdpbmZvJywgaW5mbyk7XG4gICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdXRwdXQ9cHJvbWlzZVxuICAgIGlmICh0aGlzLl9pc1N0cmVhbUlucHV0KCkpIHtcbiAgICAgIC8vIG91dHB1dD1wcm9taXNlLCBpbnB1dD1zdHJlYW1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMub25jZSgnZmluaXNoJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2ZsYXR0ZW5CdWZmZXJJbigpO1xuICAgICAgICAgIHNoYXJwLnBpcGVsaW5lKHRoaXMub3B0aW9ucywgKGVyciwgZGF0YSwgaW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNvbHZlV2l0aE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkYXRhLCBpbmZvIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3V0cHV0PXByb21pc2UsIGlucHV0PWZpbGUvYnVmZmVyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzaGFycC5waXBlbGluZSh0aGlzLm9wdGlvbnMsIChlcnIsIGRhdGEsIGluZm8pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoaXMubmF0aXZlRXJyb3IoZXJyLCBzdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc29sdmVXaXRoT2JqZWN0KSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoeyBkYXRhLCBpbmZvIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVjb3JhdGUgdGhlIFNoYXJwIHByb3RvdHlwZSB3aXRoIG91dHB1dC1yZWxhdGVkIGZ1bmN0aW9ucy5cbiAqIEBtb2R1bGUgU2hhcnBcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNoYXJwKSB7XG4gIE9iamVjdC5hc3NpZ24oU2hhcnAucHJvdG90eXBlLCB7XG4gICAgLy8gUHVibGljXG4gICAgdG9GaWxlLFxuICAgIHRvQnVmZmVyLFxuICAgIGtlZXBFeGlmLFxuICAgIHdpdGhFeGlmLFxuICAgIHdpdGhFeGlmTWVyZ2UsXG4gICAga2VlcEljY1Byb2ZpbGUsXG4gICAgd2l0aEljY1Byb2ZpbGUsXG4gICAga2VlcFhtcCxcbiAgICB3aXRoWG1wLFxuICAgIGtlZXBNZXRhZGF0YSxcbiAgICB3aXRoTWV0YWRhdGEsXG4gICAgdG9Gb3JtYXQsXG4gICAganBlZyxcbiAgICBqcDIsXG4gICAgcG5nLFxuICAgIHdlYnAsXG4gICAgdGlmZixcbiAgICBhdmlmLFxuICAgIGhlaWYsXG4gICAganhsLFxuICAgIGdpZixcbiAgICByYXcsXG4gICAgdGlsZSxcbiAgICB0aW1lb3V0LFxuICAgIC8vIFByaXZhdGVcbiAgICBfdXBkYXRlRm9ybWF0T3V0LFxuICAgIF9zZXRCb29sZWFuT3B0aW9uLFxuICAgIF9yZWFkLFxuICAgIF9waXBlbGluZVxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/output.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/resize.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/resize.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\n\n/**\n * Weighting to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst gravity = {\n  center: 0,\n  centre: 0,\n  north: 1,\n  east: 2,\n  south: 3,\n  west: 4,\n  northeast: 5,\n  southeast: 6,\n  southwest: 7,\n  northwest: 8\n};\n\n/**\n * Position to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst position = {\n  top: 1,\n  right: 2,\n  bottom: 3,\n  left: 4,\n  'right top': 5,\n  'right bottom': 6,\n  'left bottom': 7,\n  'left top': 8\n};\n\n/**\n * How to extend the image.\n * @member\n * @private\n */\nconst extendWith = {\n  background: 'background',\n  copy: 'copy',\n  repeat: 'repeat',\n  mirror: 'mirror'\n};\n\n/**\n * Strategies for automagic cover behaviour.\n * @member\n * @private\n */\nconst strategy = {\n  entropy: 16,\n  attention: 17\n};\n\n/**\n * Reduction kernels.\n * @member\n * @private\n */\nconst kernel = {\n  nearest: 'nearest',\n  linear: 'linear',\n  cubic: 'cubic',\n  mitchell: 'mitchell',\n  lanczos2: 'lanczos2',\n  lanczos3: 'lanczos3',\n  mks2013: 'mks2013',\n  mks2021: 'mks2021'\n};\n\n/**\n * Methods by which an image can be resized to fit the provided dimensions.\n * @member\n * @private\n */\nconst fit = {\n  contain: 'contain',\n  cover: 'cover',\n  fill: 'fill',\n  inside: 'inside',\n  outside: 'outside'\n};\n\n/**\n * Map external fit property to internal canvas property.\n * @member\n * @private\n */\nconst mapFitToCanvas = {\n  contain: 'embed',\n  cover: 'crop',\n  fill: 'ignore_aspect',\n  inside: 'max',\n  outside: 'min'\n};\n\n/**\n * @private\n */\nfunction isRotationExpected (options) {\n  return (options.angle % 360) !== 0 || options.rotationAngle !== 0;\n}\n\n/**\n * @private\n */\nfunction isResizeExpected (options) {\n  return options.width !== -1 || options.height !== -1;\n}\n\n/**\n * Resize image to `width`, `height` or `width x height`.\n *\n * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:\n * - `cover`: (default) Preserving aspect ratio, attempt to ensure the image covers both provided dimensions by cropping/clipping to fit.\n * - `contain`: Preserving aspect ratio, contain within both provided dimensions using \"letterboxing\" where necessary.\n * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.\n * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.\n * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.\n *\n * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.\n *\n * <img alt=\"Examples of various values for the fit property when resizing\" width=\"100%\" style=\"aspect-ratio: 998/243\" src=\"/api-resize-fit.svg\">\n *\n * When using a **fit** of `cover` or `contain`, the default **position** is `centre`. Other options are:\n * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.\n * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.\n * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.\n *\n * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.\n *\n * The strategy-based approach initially resizes so one dimension is at its target length\n * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.\n * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).\n * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.\n *\n * Possible downsizing kernels are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `linear`: Use a [triangle filter](https://en.wikipedia.org/wiki/Triangular_function).\n * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).\n * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).\n * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.\n * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).\n * - `mks2013`: Use a [Magic Kernel Sharp](https://johncostella.com/magic/mks.pdf) 2013 kernel, as adopted by Facebook.\n * - `mks2021`: Use a Magic Kernel Sharp 2021 kernel, with more accurate (reduced) sharpening than the 2013 version.\n *\n * When upsampling, these kernels map to `nearest`, `linear` and `cubic` interpolators.\n * Downsampling kernels without a matching upsampling interpolator map to `cubic`.\n *\n * Only one resize can occur per pipeline.\n * Previous calls to `resize` in the same pipeline will be ignored.\n *\n * @example\n * sharp(input)\n *   .resize({ width: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels wide, auto-scaled height\n *   });\n *\n * @example\n * sharp(input)\n *   .resize({ height: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels high, auto-scaled width\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 300, {\n *     kernel: sharp.kernel.nearest,\n *     fit: 'contain',\n *     position: 'right top',\n *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }\n *   })\n *   .toFile('output.png')\n *   .then(() => {\n *     // output.png is a 200 pixels wide and 300 pixels high image\n *     // containing a nearest-neighbour scaled version\n *     // contained within the north-east corner of a semi-transparent white canvas\n *   });\n *\n * @example\n * const transformer = sharp()\n *   .resize({\n *     width: 200,\n *     height: 200,\n *     fit: sharp.fit.cover,\n *     position: sharp.strategy.entropy\n *   });\n * // Read image data from readableStream\n * // Write 200px square auto-cropped image data to writableStream\n * readableStream\n *   .pipe(transformer)\n *   .pipe(writableStream);\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.inside,\n *     withoutEnlargement: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // no wider and no higher than 200 pixels\n *     // and no larger than the input image\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.outside,\n *     withoutReduction: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // of at least 200 pixels wide and 200 pixels high while maintaining aspect ratio\n *     // and no smaller than the input image\n *   });\n *\n * @example\n * const scaleByHalf = await sharp(input)\n *   .metadata()\n *   .then(({ width }) => sharp(input)\n *     .resize(Math.round(width * 0.5))\n *     .toBuffer()\n *   );\n *\n * @param {number} [width] - How many pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.\n * @param {number} [height] - How many pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.\n * @param {Object} [options]\n * @param {number} [options.width] - An alternative means of specifying `width`. If both are present this takes priority.\n * @param {number} [options.height] - An alternative means of specifying `height`. If both are present this takes priority.\n * @param {String} [options.fit='cover'] - How the image should be resized/cropped to fit the target dimension(s), one of `cover`, `contain`, `fill`, `inside` or `outside`.\n * @param {String} [options.position='centre'] - A position, gravity or strategy to use when `fit` is `cover` or `contain`.\n * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when `fit` is `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @param {String} [options.kernel='lanczos3'] - The kernel to use for image reduction and the inferred interpolator to use for upsampling. Use the `fastShrinkOnLoad` option to control kernel vs shrink-on-load.\n * @param {Boolean} [options.withoutEnlargement=false] - Do not scale up if the width *or* height are already less than the target dimensions, equivalent to GraphicsMagick's `>` geometry option. This may result in output dimensions smaller than the target dimensions.\n * @param {Boolean} [options.withoutReduction=false] - Do not scale down if the width *or* height are already greater than the target dimensions, equivalent to GraphicsMagick's `<` geometry option. This may still result in a crop to reach the target dimensions.\n * @param {Boolean} [options.fastShrinkOnLoad=true] - Take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moiré pattern or round-down of an auto-scaled dimension.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction resize (widthOrOptions, height, options) {\n  if (isResizeExpected(this.options)) {\n    this.options.debuglog('ignoring previous resize options');\n  }\n  if (this.options.widthPost !== -1) {\n    this.options.debuglog('operation order will be: extract, resize, extract');\n  }\n  if (is.defined(widthOrOptions)) {\n    if (is.object(widthOrOptions) && !is.defined(options)) {\n      options = widthOrOptions;\n    } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {\n      this.options.width = widthOrOptions;\n    } else {\n      throw is.invalidParameterError('width', 'positive integer', widthOrOptions);\n    }\n  } else {\n    this.options.width = -1;\n  }\n  if (is.defined(height)) {\n    if (is.integer(height) && height > 0) {\n      this.options.height = height;\n    } else {\n      throw is.invalidParameterError('height', 'positive integer', height);\n    }\n  } else {\n    this.options.height = -1;\n  }\n  if (is.object(options)) {\n    // Width\n    if (is.defined(options.width)) {\n      if (is.integer(options.width) && options.width > 0) {\n        this.options.width = options.width;\n      } else {\n        throw is.invalidParameterError('width', 'positive integer', options.width);\n      }\n    }\n    // Height\n    if (is.defined(options.height)) {\n      if (is.integer(options.height) && options.height > 0) {\n        this.options.height = options.height;\n      } else {\n        throw is.invalidParameterError('height', 'positive integer', options.height);\n      }\n    }\n    // Fit\n    if (is.defined(options.fit)) {\n      const canvas = mapFitToCanvas[options.fit];\n      if (is.string(canvas)) {\n        this.options.canvas = canvas;\n      } else {\n        throw is.invalidParameterError('fit', 'valid fit', options.fit);\n      }\n    }\n    // Position\n    if (is.defined(options.position)) {\n      const pos = is.integer(options.position)\n        ? options.position\n        : strategy[options.position] || position[options.position] || gravity[options.position];\n      if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {\n        this.options.position = pos;\n      } else {\n        throw is.invalidParameterError('position', 'valid position/gravity/strategy', options.position);\n      }\n    }\n    // Background\n    this._setBackgroundColourOption('resizeBackground', options.background);\n    // Kernel\n    if (is.defined(options.kernel)) {\n      if (is.string(kernel[options.kernel])) {\n        this.options.kernel = kernel[options.kernel];\n      } else {\n        throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);\n      }\n    }\n    // Without enlargement\n    if (is.defined(options.withoutEnlargement)) {\n      this._setBooleanOption('withoutEnlargement', options.withoutEnlargement);\n    }\n    // Without reduction\n    if (is.defined(options.withoutReduction)) {\n      this._setBooleanOption('withoutReduction', options.withoutReduction);\n    }\n    // Shrink on load\n    if (is.defined(options.fastShrinkOnLoad)) {\n      this._setBooleanOption('fastShrinkOnLoad', options.fastShrinkOnLoad);\n    }\n  }\n  if (isRotationExpected(this.options) && isResizeExpected(this.options)) {\n    this.options.rotateBefore = true;\n  }\n  return this;\n}\n\n/**\n * Extend / pad / extrude one or more edges of the image with either\n * the provided background colour or pixels derived from the image.\n * This operation will always occur after resizing and extraction, if any.\n *\n * @example\n * // Resize to 140 pixels wide, then add 10 transparent pixels\n * // to the top, left and right edges and 20 to the bottom edge\n * sharp(input)\n *   .resize(140)\n *   .extend({\n *     top: 10,\n *     bottom: 20,\n *     left: 10,\n *     right: 10,\n *     background: { r: 0, g: 0, b: 0, alpha: 0 }\n *   })\n *   ...\n *\n* @example\n * // Add a row of 10 red pixels to the bottom\n * sharp(input)\n *   .extend({\n *     bottom: 10,\n *     background: 'red'\n *   })\n *   ...\n *\n * @example\n * // Extrude image by 8 pixels to the right, mirroring existing right hand edge\n * sharp(input)\n *   .extend({\n *     right: 8,\n *     background: 'mirror'\n *   })\n *   ...\n *\n * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts\n * @param {number} [extend.top=0]\n * @param {number} [extend.left=0]\n * @param {number} [extend.bottom=0]\n * @param {number} [extend.right=0]\n * @param {String} [extend.extendWith='background'] - populate new pixels using this method, one of: background, copy, repeat, mirror.\n * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n*/\nfunction extend (extend) {\n  if (is.integer(extend) && extend > 0) {\n    this.options.extendTop = extend;\n    this.options.extendBottom = extend;\n    this.options.extendLeft = extend;\n    this.options.extendRight = extend;\n  } else if (is.object(extend)) {\n    if (is.defined(extend.top)) {\n      if (is.integer(extend.top) && extend.top >= 0) {\n        this.options.extendTop = extend.top;\n      } else {\n        throw is.invalidParameterError('top', 'positive integer', extend.top);\n      }\n    }\n    if (is.defined(extend.bottom)) {\n      if (is.integer(extend.bottom) && extend.bottom >= 0) {\n        this.options.extendBottom = extend.bottom;\n      } else {\n        throw is.invalidParameterError('bottom', 'positive integer', extend.bottom);\n      }\n    }\n    if (is.defined(extend.left)) {\n      if (is.integer(extend.left) && extend.left >= 0) {\n        this.options.extendLeft = extend.left;\n      } else {\n        throw is.invalidParameterError('left', 'positive integer', extend.left);\n      }\n    }\n    if (is.defined(extend.right)) {\n      if (is.integer(extend.right) && extend.right >= 0) {\n        this.options.extendRight = extend.right;\n      } else {\n        throw is.invalidParameterError('right', 'positive integer', extend.right);\n      }\n    }\n    this._setBackgroundColourOption('extendBackground', extend.background);\n    if (is.defined(extend.extendWith)) {\n      if (is.string(extendWith[extend.extendWith])) {\n        this.options.extendWith = extendWith[extend.extendWith];\n      } else {\n        throw is.invalidParameterError('extendWith', 'one of: background, copy, repeat, mirror', extend.extendWith);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('extend', 'integer or object', extend);\n  }\n  return this;\n}\n\n/**\n * Extract/crop a region of the image.\n *\n * - Use `extract` before `resize` for pre-resize extraction.\n * - Use `extract` after `resize` for post-resize extraction.\n * - Use `extract` twice and `resize` once for extract-then-resize-then-extract in a fixed operation order.\n *\n * @example\n * sharp(input)\n *   .extract({ left: left, top: top, width: width, height: height })\n *   .toFile(output, function(err) {\n *     // Extract a region of the input image, saving in the same format.\n *   });\n * @example\n * sharp(input)\n *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })\n *   .resize(width, height)\n *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })\n *   .toFile(output, function(err) {\n *     // Extract a region, resize, then extract from the resized image\n *   });\n *\n * @param {Object} options - describes the region to extract using integral pixel values\n * @param {number} options.left - zero-indexed offset from left edge\n * @param {number} options.top - zero-indexed offset from top edge\n * @param {number} options.width - width of region to extract\n * @param {number} options.height - height of region to extract\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction extract (options) {\n  const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? 'Post' : 'Pre';\n  if (this.options[`width${suffix}`] !== -1) {\n    this.options.debuglog('ignoring previous extract options');\n  }\n  ['left', 'top', 'width', 'height'].forEach(function (name) {\n    const value = options[name];\n    if (is.integer(value) && value >= 0) {\n      this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;\n    } else {\n      throw is.invalidParameterError(name, 'integer', value);\n    }\n  }, this);\n  // Ensure existing rotation occurs before pre-resize extraction\n  if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {\n    if (this.options.widthPre === -1 || this.options.widthPost === -1) {\n      this.options.rotateBefore = true;\n    }\n  }\n  if (this.options.input.autoOrient) {\n    this.options.orientBefore = true;\n  }\n  return this;\n}\n\n/**\n * Trim pixels from all edges that contain values similar to the given background colour, which defaults to that of the top-left pixel.\n *\n * Images with an alpha channel will use the combined bounding box of alpha and non-alpha channels.\n *\n * If the result of this operation would trim an image to nothing then no change is made.\n *\n * The `info` response Object will contain `trimOffsetLeft` and `trimOffsetTop` properties.\n *\n * @example\n * // Trim pixels with a colour similar to that of the top-left pixel.\n * await sharp(input)\n *   .trim()\n *   .toFile(output);\n *\n * @example\n * // Trim pixels with the exact same colour as that of the top-left pixel.\n * await sharp(input)\n *   .trim({\n *     threshold: 0\n *   })\n *   .toFile(output);\n *\n * @example\n * // Assume input is line art and trim only pixels with a similar colour to red.\n * const output = await sharp(input)\n *   .trim({\n *     background: \"#FF0000\",\n *     lineArt: true\n *   })\n *   .toBuffer();\n *\n * @example\n * // Trim all \"yellow-ish\" pixels, being more lenient with the higher threshold.\n * const output = await sharp(input)\n *   .trim({\n *     background: \"yellow\",\n *     threshold: 42,\n *   })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {string|Object} [options.background='top-left pixel'] - Background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to that of the top-left pixel.\n * @param {number} [options.threshold=10] - Allowed difference from the above colour, a positive number.\n * @param {boolean} [options.lineArt=false] - Does the input more closely resemble line art (e.g. vector) rather than being photographic?\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction trim (options) {\n  this.options.trimThreshold = 10;\n  if (is.defined(options)) {\n    if (is.object(options)) {\n      if (is.defined(options.background)) {\n        this._setBackgroundColourOption('trimBackground', options.background);\n      }\n      if (is.defined(options.threshold)) {\n        if (is.number(options.threshold) && options.threshold >= 0) {\n          this.options.trimThreshold = options.threshold;\n        } else {\n          throw is.invalidParameterError('threshold', 'positive number', options.threshold);\n        }\n      }\n      if (is.defined(options.lineArt)) {\n        this._setBooleanOption('trimLineArt', options.lineArt);\n      }\n    } else {\n      throw is.invalidParameterError('trim', 'object', options);\n    }\n  }\n  if (isRotationExpected(this.options)) {\n    this.options.rotateBefore = true;\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with resize-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    resize,\n    extend,\n    extract,\n    trim\n  });\n  // Class attributes\n  Sharp.gravity = gravity;\n  Sharp.strategy = strategy;\n  Sharp.kernel = kernel;\n  Sharp.fit = fit;\n  Sharp.position = position;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvcmVzaXplLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGtGQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbnJvdXRlci1sYW5nZ3JhcGgvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvcmVzaXplLmpzPzc4NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMgTG92ZWxsIEZ1bGxlciBhbmQgb3RoZXJzLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuLyoqXG4gKiBXZWlnaHRpbmcgdG8gYXBwbHkgd2hlbiB1c2luZyBjb250YWluL2NvdmVyIGZpdC5cbiAqIEBtZW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdyYXZpdHkgPSB7XG4gIGNlbnRlcjogMCxcbiAgY2VudHJlOiAwLFxuICBub3J0aDogMSxcbiAgZWFzdDogMixcbiAgc291dGg6IDMsXG4gIHdlc3Q6IDQsXG4gIG5vcnRoZWFzdDogNSxcbiAgc291dGhlYXN0OiA2LFxuICBzb3V0aHdlc3Q6IDcsXG4gIG5vcnRod2VzdDogOFxufTtcblxuLyoqXG4gKiBQb3NpdGlvbiB0byBhcHBseSB3aGVuIHVzaW5nIGNvbnRhaW4vY292ZXIgZml0LlxuICogQG1lbWJlclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcG9zaXRpb24gPSB7XG4gIHRvcDogMSxcbiAgcmlnaHQ6IDIsXG4gIGJvdHRvbTogMyxcbiAgbGVmdDogNCxcbiAgJ3JpZ2h0IHRvcCc6IDUsXG4gICdyaWdodCBib3R0b20nOiA2LFxuICAnbGVmdCBib3R0b20nOiA3LFxuICAnbGVmdCB0b3AnOiA4XG59O1xuXG4vKipcbiAqIEhvdyB0byBleHRlbmQgdGhlIGltYWdlLlxuICogQG1lbWJlclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZXh0ZW5kV2l0aCA9IHtcbiAgYmFja2dyb3VuZDogJ2JhY2tncm91bmQnLFxuICBjb3B5OiAnY29weScsXG4gIHJlcGVhdDogJ3JlcGVhdCcsXG4gIG1pcnJvcjogJ21pcnJvcidcbn07XG5cbi8qKlxuICogU3RyYXRlZ2llcyBmb3IgYXV0b21hZ2ljIGNvdmVyIGJlaGF2aW91ci5cbiAqIEBtZW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHN0cmF0ZWd5ID0ge1xuICBlbnRyb3B5OiAxNixcbiAgYXR0ZW50aW9uOiAxN1xufTtcblxuLyoqXG4gKiBSZWR1Y3Rpb24ga2VybmVscy5cbiAqIEBtZW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGtlcm5lbCA9IHtcbiAgbmVhcmVzdDogJ25lYXJlc3QnLFxuICBsaW5lYXI6ICdsaW5lYXInLFxuICBjdWJpYzogJ2N1YmljJyxcbiAgbWl0Y2hlbGw6ICdtaXRjaGVsbCcsXG4gIGxhbmN6b3MyOiAnbGFuY3pvczInLFxuICBsYW5jem9zMzogJ2xhbmN6b3MzJyxcbiAgbWtzMjAxMzogJ21rczIwMTMnLFxuICBta3MyMDIxOiAnbWtzMjAyMSdcbn07XG5cbi8qKlxuICogTWV0aG9kcyBieSB3aGljaCBhbiBpbWFnZSBjYW4gYmUgcmVzaXplZCB0byBmaXQgdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMuXG4gKiBAbWVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBmaXQgPSB7XG4gIGNvbnRhaW46ICdjb250YWluJyxcbiAgY292ZXI6ICdjb3ZlcicsXG4gIGZpbGw6ICdmaWxsJyxcbiAgaW5zaWRlOiAnaW5zaWRlJyxcbiAgb3V0c2lkZTogJ291dHNpZGUnXG59O1xuXG4vKipcbiAqIE1hcCBleHRlcm5hbCBmaXQgcHJvcGVydHkgdG8gaW50ZXJuYWwgY2FudmFzIHByb3BlcnR5LlxuICogQG1lbWJlclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbWFwRml0VG9DYW52YXMgPSB7XG4gIGNvbnRhaW46ICdlbWJlZCcsXG4gIGNvdmVyOiAnY3JvcCcsXG4gIGZpbGw6ICdpZ25vcmVfYXNwZWN0JyxcbiAgaW5zaWRlOiAnbWF4JyxcbiAgb3V0c2lkZTogJ21pbidcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNSb3RhdGlvbkV4cGVjdGVkIChvcHRpb25zKSB7XG4gIHJldHVybiAob3B0aW9ucy5hbmdsZSAlIDM2MCkgIT09IDAgfHwgb3B0aW9ucy5yb3RhdGlvbkFuZ2xlICE9PSAwO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzUmVzaXplRXhwZWN0ZWQgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMud2lkdGggIT09IC0xIHx8IG9wdGlvbnMuaGVpZ2h0ICE9PSAtMTtcbn1cblxuLyoqXG4gKiBSZXNpemUgaW1hZ2UgdG8gYHdpZHRoYCwgYGhlaWdodGAgb3IgYHdpZHRoIHggaGVpZ2h0YC5cbiAqXG4gKiBXaGVuIGJvdGggYSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBhcmUgcHJvdmlkZWQsIHRoZSBwb3NzaWJsZSBtZXRob2RzIGJ5IHdoaWNoIHRoZSBpbWFnZSBzaG91bGQgKipmaXQqKiB0aGVzZSBhcmU6XG4gKiAtIGBjb3ZlcmA6IChkZWZhdWx0KSBQcmVzZXJ2aW5nIGFzcGVjdCByYXRpbywgYXR0ZW1wdCB0byBlbnN1cmUgdGhlIGltYWdlIGNvdmVycyBib3RoIHByb3ZpZGVkIGRpbWVuc2lvbnMgYnkgY3JvcHBpbmcvY2xpcHBpbmcgdG8gZml0LlxuICogLSBgY29udGFpbmA6IFByZXNlcnZpbmcgYXNwZWN0IHJhdGlvLCBjb250YWluIHdpdGhpbiBib3RoIHByb3ZpZGVkIGRpbWVuc2lvbnMgdXNpbmcgXCJsZXR0ZXJib3hpbmdcIiB3aGVyZSBuZWNlc3NhcnkuXG4gKiAtIGBmaWxsYDogSWdub3JlIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGlucHV0IGFuZCBzdHJldGNoIHRvIGJvdGggcHJvdmlkZWQgZGltZW5zaW9ucy5cbiAqIC0gYGluc2lkZWA6IFByZXNlcnZpbmcgYXNwZWN0IHJhdGlvLCByZXNpemUgdGhlIGltYWdlIHRvIGJlIGFzIGxhcmdlIGFzIHBvc3NpYmxlIHdoaWxlIGVuc3VyaW5nIGl0cyBkaW1lbnNpb25zIGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYm90aCB0aG9zZSBzcGVjaWZpZWQuXG4gKiAtIGBvdXRzaWRlYDogUHJlc2VydmluZyBhc3BlY3QgcmF0aW8sIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gYmUgYXMgc21hbGwgYXMgcG9zc2libGUgd2hpbGUgZW5zdXJpbmcgaXRzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBib3RoIHRob3NlIHNwZWNpZmllZC5cbiAqXG4gKiBTb21lIG9mIHRoZXNlIHZhbHVlcyBhcmUgYmFzZWQgb24gdGhlIFtvYmplY3QtZml0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdCkgQ1NTIHByb3BlcnR5LlxuICpcbiAqIDxpbWcgYWx0PVwiRXhhbXBsZXMgb2YgdmFyaW91cyB2YWx1ZXMgZm9yIHRoZSBmaXQgcHJvcGVydHkgd2hlbiByZXNpemluZ1wiIHdpZHRoPVwiMTAwJVwiIHN0eWxlPVwiYXNwZWN0LXJhdGlvOiA5OTgvMjQzXCIgc3JjPVwiL2FwaS1yZXNpemUtZml0LnN2Z1wiPlxuICpcbiAqIFdoZW4gdXNpbmcgYSAqKmZpdCoqIG9mIGBjb3ZlcmAgb3IgYGNvbnRhaW5gLCB0aGUgZGVmYXVsdCAqKnBvc2l0aW9uKiogaXMgYGNlbnRyZWAuIE90aGVyIG9wdGlvbnMgYXJlOlxuICogLSBgc2hhcnAucG9zaXRpb25gOiBgdG9wYCwgYHJpZ2h0IHRvcGAsIGByaWdodGAsIGByaWdodCBib3R0b21gLCBgYm90dG9tYCwgYGxlZnQgYm90dG9tYCwgYGxlZnRgLCBgbGVmdCB0b3BgLlxuICogLSBgc2hhcnAuZ3Jhdml0eWA6IGBub3J0aGAsIGBub3J0aGVhc3RgLCBgZWFzdGAsIGBzb3V0aGVhc3RgLCBgc291dGhgLCBgc291dGh3ZXN0YCwgYHdlc3RgLCBgbm9ydGh3ZXN0YCwgYGNlbnRlcmAgb3IgYGNlbnRyZWAuXG4gKiAtIGBzaGFycC5zdHJhdGVneWA6IGBjb3ZlcmAgb25seSwgZHluYW1pY2FsbHkgY3JvcCB1c2luZyBlaXRoZXIgdGhlIGBlbnRyb3B5YCBvciBgYXR0ZW50aW9uYCBzdHJhdGVneS5cbiAqXG4gKiBTb21lIG9mIHRoZXNlIHZhbHVlcyBhcmUgYmFzZWQgb24gdGhlIFtvYmplY3QtcG9zaXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtcG9zaXRpb24pIENTUyBwcm9wZXJ0eS5cbiAqXG4gKiBUaGUgc3RyYXRlZ3ktYmFzZWQgYXBwcm9hY2ggaW5pdGlhbGx5IHJlc2l6ZXMgc28gb25lIGRpbWVuc2lvbiBpcyBhdCBpdHMgdGFyZ2V0IGxlbmd0aFxuICogdGhlbiByZXBlYXRlZGx5IHJhbmtzIGVkZ2UgcmVnaW9ucywgZGlzY2FyZGluZyB0aGUgZWRnZSB3aXRoIHRoZSBsb3dlc3Qgc2NvcmUgYmFzZWQgb24gdGhlIHNlbGVjdGVkIHN0cmF0ZWd5LlxuICogLSBgZW50cm9weWA6IGZvY3VzIG9uIHRoZSByZWdpb24gd2l0aCB0aGUgaGlnaGVzdCBbU2hhbm5vbiBlbnRyb3B5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbnRyb3B5XyUyOGluZm9ybWF0aW9uX3RoZW9yeSUyOSkuXG4gKiAtIGBhdHRlbnRpb25gOiBmb2N1cyBvbiB0aGUgcmVnaW9uIHdpdGggdGhlIGhpZ2hlc3QgbHVtaW5hbmNlIGZyZXF1ZW5jeSwgY29sb3VyIHNhdHVyYXRpb24gYW5kIHByZXNlbmNlIG9mIHNraW4gdG9uZXMuXG4gKlxuICogUG9zc2libGUgZG93bnNpemluZyBrZXJuZWxzIGFyZTpcbiAqIC0gYG5lYXJlc3RgOiBVc2UgW25lYXJlc3QgbmVpZ2hib3VyIGludGVycG9sYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmVhcmVzdC1uZWlnaGJvcl9pbnRlcnBvbGF0aW9uKS5cbiAqIC0gYGxpbmVhcmA6IFVzZSBhIFt0cmlhbmdsZSBmaWx0ZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyaWFuZ3VsYXJfZnVuY3Rpb24pLlxuICogLSBgY3ViaWNgOiBVc2UgYSBbQ2F0bXVsbC1Sb20gc3BsaW5lXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmlwZXRhbF9DYXRtdWxsJUUyJTgwJTkzUm9tX3NwbGluZSkuXG4gKiAtIGBtaXRjaGVsbGA6IFVzZSBhIFtNaXRjaGVsbC1OZXRyYXZhbGkgc3BsaW5lXShodHRwczovL3d3dy5jcy51dGV4YXMuZWR1L35mdXNzZWxsL2NvdXJzZXMvY3MzODRnLWZhbGwyMDEzL2xlY3R1cmVzL21pdGNoZWxsL01pdGNoZWxsLnBkZikuXG4gKiAtIGBsYW5jem9zMmA6IFVzZSBhIFtMYW5jem9zIGtlcm5lbF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuY3pvc19yZXNhbXBsaW5nI0xhbmN6b3Nfa2VybmVsKSB3aXRoIGBhPTJgLlxuICogLSBgbGFuY3pvczNgOiBVc2UgYSBMYW5jem9zIGtlcm5lbCB3aXRoIGBhPTNgICh0aGUgZGVmYXVsdCkuXG4gKiAtIGBta3MyMDEzYDogVXNlIGEgW01hZ2ljIEtlcm5lbCBTaGFycF0oaHR0cHM6Ly9qb2huY29zdGVsbGEuY29tL21hZ2ljL21rcy5wZGYpIDIwMTMga2VybmVsLCBhcyBhZG9wdGVkIGJ5IEZhY2Vib29rLlxuICogLSBgbWtzMjAyMWA6IFVzZSBhIE1hZ2ljIEtlcm5lbCBTaGFycCAyMDIxIGtlcm5lbCwgd2l0aCBtb3JlIGFjY3VyYXRlIChyZWR1Y2VkKSBzaGFycGVuaW5nIHRoYW4gdGhlIDIwMTMgdmVyc2lvbi5cbiAqXG4gKiBXaGVuIHVwc2FtcGxpbmcsIHRoZXNlIGtlcm5lbHMgbWFwIHRvIGBuZWFyZXN0YCwgYGxpbmVhcmAgYW5kIGBjdWJpY2AgaW50ZXJwb2xhdG9ycy5cbiAqIERvd25zYW1wbGluZyBrZXJuZWxzIHdpdGhvdXQgYSBtYXRjaGluZyB1cHNhbXBsaW5nIGludGVycG9sYXRvciBtYXAgdG8gYGN1YmljYC5cbiAqXG4gKiBPbmx5IG9uZSByZXNpemUgY2FuIG9jY3VyIHBlciBwaXBlbGluZS5cbiAqIFByZXZpb3VzIGNhbGxzIHRvIGByZXNpemVgIGluIHRoZSBzYW1lIHBpcGVsaW5lIHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2hhcnAoaW5wdXQpXG4gKiAgIC5yZXNpemUoeyB3aWR0aDogMTAwIH0pXG4gKiAgIC50b0J1ZmZlcigpXG4gKiAgIC50aGVuKGRhdGEgPT4ge1xuICogICAgIC8vIDEwMCBwaXhlbHMgd2lkZSwgYXV0by1zY2FsZWQgaGVpZ2h0XG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBzaGFycChpbnB1dClcbiAqICAgLnJlc2l6ZSh7IGhlaWdodDogMTAwIH0pXG4gKiAgIC50b0J1ZmZlcigpXG4gKiAgIC50aGVuKGRhdGEgPT4ge1xuICogICAgIC8vIDEwMCBwaXhlbHMgaGlnaCwgYXV0by1zY2FsZWQgd2lkdGhcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAucmVzaXplKDIwMCwgMzAwLCB7XG4gKiAgICAga2VybmVsOiBzaGFycC5rZXJuZWwubmVhcmVzdCxcbiAqICAgICBmaXQ6ICdjb250YWluJyxcbiAqICAgICBwb3NpdGlvbjogJ3JpZ2h0IHRvcCcsXG4gKiAgICAgYmFja2dyb3VuZDogeyByOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhbHBoYTogMC41IH1cbiAqICAgfSlcbiAqICAgLnRvRmlsZSgnb3V0cHV0LnBuZycpXG4gKiAgIC50aGVuKCgpID0+IHtcbiAqICAgICAvLyBvdXRwdXQucG5nIGlzIGEgMjAwIHBpeGVscyB3aWRlIGFuZCAzMDAgcGl4ZWxzIGhpZ2ggaW1hZ2VcbiAqICAgICAvLyBjb250YWluaW5nIGEgbmVhcmVzdC1uZWlnaGJvdXIgc2NhbGVkIHZlcnNpb25cbiAqICAgICAvLyBjb250YWluZWQgd2l0aGluIHRoZSBub3J0aC1lYXN0IGNvcm5lciBvZiBhIHNlbWktdHJhbnNwYXJlbnQgd2hpdGUgY2FudmFzXG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0cmFuc2Zvcm1lciA9IHNoYXJwKClcbiAqICAgLnJlc2l6ZSh7XG4gKiAgICAgd2lkdGg6IDIwMCxcbiAqICAgICBoZWlnaHQ6IDIwMCxcbiAqICAgICBmaXQ6IHNoYXJwLmZpdC5jb3ZlcixcbiAqICAgICBwb3NpdGlvbjogc2hhcnAuc3RyYXRlZ3kuZW50cm9weVxuICogICB9KTtcbiAqIC8vIFJlYWQgaW1hZ2UgZGF0YSBmcm9tIHJlYWRhYmxlU3RyZWFtXG4gKiAvLyBXcml0ZSAyMDBweCBzcXVhcmUgYXV0by1jcm9wcGVkIGltYWdlIGRhdGEgdG8gd3JpdGFibGVTdHJlYW1cbiAqIHJlYWRhYmxlU3RyZWFtXG4gKiAgIC5waXBlKHRyYW5zZm9ybWVyKVxuICogICAucGlwZSh3cml0YWJsZVN0cmVhbSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAucmVzaXplKDIwMCwgMjAwLCB7XG4gKiAgICAgZml0OiBzaGFycC5maXQuaW5zaWRlLFxuICogICAgIHdpdGhvdXRFbmxhcmdlbWVudDogdHJ1ZVxuICogICB9KVxuICogICAudG9Gb3JtYXQoJ2pwZWcnKVxuICogICAudG9CdWZmZXIoKVxuICogICAudGhlbihmdW5jdGlvbihvdXRwdXRCdWZmZXIpIHtcbiAqICAgICAvLyBvdXRwdXRCdWZmZXIgY29udGFpbnMgSlBFRyBpbWFnZSBkYXRhXG4gKiAgICAgLy8gbm8gd2lkZXIgYW5kIG5vIGhpZ2hlciB0aGFuIDIwMCBwaXhlbHNcbiAqICAgICAvLyBhbmQgbm8gbGFyZ2VyIHRoYW4gdGhlIGlucHV0IGltYWdlXG4gKiAgIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBzaGFycChpbnB1dClcbiAqICAgLnJlc2l6ZSgyMDAsIDIwMCwge1xuICogICAgIGZpdDogc2hhcnAuZml0Lm91dHNpZGUsXG4gKiAgICAgd2l0aG91dFJlZHVjdGlvbjogdHJ1ZVxuICogICB9KVxuICogICAudG9Gb3JtYXQoJ2pwZWcnKVxuICogICAudG9CdWZmZXIoKVxuICogICAudGhlbihmdW5jdGlvbihvdXRwdXRCdWZmZXIpIHtcbiAqICAgICAvLyBvdXRwdXRCdWZmZXIgY29udGFpbnMgSlBFRyBpbWFnZSBkYXRhXG4gKiAgICAgLy8gb2YgYXQgbGVhc3QgMjAwIHBpeGVscyB3aWRlIGFuZCAyMDAgcGl4ZWxzIGhpZ2ggd2hpbGUgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvXG4gKiAgICAgLy8gYW5kIG5vIHNtYWxsZXIgdGhhbiB0aGUgaW5wdXQgaW1hZ2VcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNjYWxlQnlIYWxmID0gYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC5tZXRhZGF0YSgpXG4gKiAgIC50aGVuKCh7IHdpZHRoIH0pID0+IHNoYXJwKGlucHV0KVxuICogICAgIC5yZXNpemUoTWF0aC5yb3VuZCh3aWR0aCAqIDAuNSkpXG4gKiAgICAgLnRvQnVmZmVyKClcbiAqICAgKTtcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIEhvdyBtYW55IHBpeGVscyB3aWRlIHRoZSByZXN1bHRhbnQgaW1hZ2Ugc2hvdWxkIGJlLiBVc2UgYG51bGxgIG9yIGB1bmRlZmluZWRgIHRvIGF1dG8tc2NhbGUgdGhlIHdpZHRoIHRvIG1hdGNoIHRoZSBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBIb3cgbWFueSBwaXhlbHMgaGlnaCB0aGUgcmVzdWx0YW50IGltYWdlIHNob3VsZCBiZS4gVXNlIGBudWxsYCBvciBgdW5kZWZpbmVkYCB0byBhdXRvLXNjYWxlIHRoZSBoZWlnaHQgdG8gbWF0Y2ggdGhlIHdpZHRoLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoXSAtIEFuIGFsdGVybmF0aXZlIG1lYW5zIG9mIHNwZWNpZnlpbmcgYHdpZHRoYC4gSWYgYm90aCBhcmUgcHJlc2VudCB0aGlzIHRha2VzIHByaW9yaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBBbiBhbHRlcm5hdGl2ZSBtZWFucyBvZiBzcGVjaWZ5aW5nIGBoZWlnaHRgLiBJZiBib3RoIGFyZSBwcmVzZW50IHRoaXMgdGFrZXMgcHJpb3JpdHkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZml0PSdjb3ZlciddIC0gSG93IHRoZSBpbWFnZSBzaG91bGQgYmUgcmVzaXplZC9jcm9wcGVkIHRvIGZpdCB0aGUgdGFyZ2V0IGRpbWVuc2lvbihzKSwgb25lIG9mIGBjb3ZlcmAsIGBjb250YWluYCwgYGZpbGxgLCBgaW5zaWRlYCBvciBgb3V0c2lkZWAuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb249J2NlbnRyZSddIC0gQSBwb3NpdGlvbiwgZ3Jhdml0eSBvciBzdHJhdGVneSB0byB1c2Ugd2hlbiBgZml0YCBpcyBgY292ZXJgIG9yIGBjb250YWluYC5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW29wdGlvbnMuYmFja2dyb3VuZD17cjogMCwgZzogMCwgYjogMCwgYWxwaGE6IDF9XSAtIGJhY2tncm91bmQgY29sb3VyIHdoZW4gYGZpdGAgaXMgYGNvbnRhaW5gLCBwYXJzZWQgYnkgdGhlIFtjb2xvcl0oaHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvY29sb3IpIG1vZHVsZSwgZGVmYXVsdHMgdG8gYmxhY2sgd2l0aG91dCB0cmFuc3BhcmVuY3kuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMua2VybmVsPSdsYW5jem9zMyddIC0gVGhlIGtlcm5lbCB0byB1c2UgZm9yIGltYWdlIHJlZHVjdGlvbiBhbmQgdGhlIGluZmVycmVkIGludGVycG9sYXRvciB0byB1c2UgZm9yIHVwc2FtcGxpbmcuIFVzZSB0aGUgYGZhc3RTaHJpbmtPbkxvYWRgIG9wdGlvbiB0byBjb250cm9sIGtlcm5lbCB2cyBzaHJpbmstb24tbG9hZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dEVubGFyZ2VtZW50PWZhbHNlXSAtIERvIG5vdCBzY2FsZSB1cCBpZiB0aGUgd2lkdGggKm9yKiBoZWlnaHQgYXJlIGFscmVhZHkgbGVzcyB0aGFuIHRoZSB0YXJnZXQgZGltZW5zaW9ucywgZXF1aXZhbGVudCB0byBHcmFwaGljc01hZ2ljaydzIGA+YCBnZW9tZXRyeSBvcHRpb24uIFRoaXMgbWF5IHJlc3VsdCBpbiBvdXRwdXQgZGltZW5zaW9ucyBzbWFsbGVyIHRoYW4gdGhlIHRhcmdldCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0UmVkdWN0aW9uPWZhbHNlXSAtIERvIG5vdCBzY2FsZSBkb3duIGlmIHRoZSB3aWR0aCAqb3IqIGhlaWdodCBhcmUgYWxyZWFkeSBncmVhdGVyIHRoYW4gdGhlIHRhcmdldCBkaW1lbnNpb25zLCBlcXVpdmFsZW50IHRvIEdyYXBoaWNzTWFnaWNrJ3MgYDxgIGdlb21ldHJ5IG9wdGlvbi4gVGhpcyBtYXkgc3RpbGwgcmVzdWx0IGluIGEgY3JvcCB0byByZWFjaCB0aGUgdGFyZ2V0IGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZhc3RTaHJpbmtPbkxvYWQ9dHJ1ZV0gLSBUYWtlIGdyZWF0ZXIgYWR2YW50YWdlIG9mIHRoZSBKUEVHIGFuZCBXZWJQIHNocmluay1vbi1sb2FkIGZlYXR1cmUsIHdoaWNoIGNhbiBsZWFkIHRvIGEgc2xpZ2h0IG1vaXLDqSBwYXR0ZXJuIG9yIHJvdW5kLWRvd24gb2YgYW4gYXV0by1zY2FsZWQgZGltZW5zaW9uLlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiByZXNpemUgKHdpZHRoT3JPcHRpb25zLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzUmVzaXplRXhwZWN0ZWQodGhpcy5vcHRpb25zKSkge1xuICAgIHRoaXMub3B0aW9ucy5kZWJ1Z2xvZygnaWdub3JpbmcgcHJldmlvdXMgcmVzaXplIG9wdGlvbnMnKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLndpZHRoUG9zdCAhPT0gLTEpIHtcbiAgICB0aGlzLm9wdGlvbnMuZGVidWdsb2coJ29wZXJhdGlvbiBvcmRlciB3aWxsIGJlOiBleHRyYWN0LCByZXNpemUsIGV4dHJhY3QnKTtcbiAgfVxuICBpZiAoaXMuZGVmaW5lZCh3aWR0aE9yT3B0aW9ucykpIHtcbiAgICBpZiAoaXMub2JqZWN0KHdpZHRoT3JPcHRpb25zKSAmJiAhaXMuZGVmaW5lZChvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHdpZHRoT3JPcHRpb25zO1xuICAgIH0gZWxzZSBpZiAoaXMuaW50ZWdlcih3aWR0aE9yT3B0aW9ucykgJiYgd2lkdGhPck9wdGlvbnMgPiAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB3aWR0aE9yT3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd3aWR0aCcsICdwb3NpdGl2ZSBpbnRlZ2VyJywgd2lkdGhPck9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMud2lkdGggPSAtMTtcbiAgfVxuICBpZiAoaXMuZGVmaW5lZChoZWlnaHQpKSB7XG4gICAgaWYgKGlzLmludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPiAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2hlaWdodCcsICdwb3NpdGl2ZSBpbnRlZ2VyJywgaGVpZ2h0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IC0xO1xuICB9XG4gIGlmIChpcy5vYmplY3Qob3B0aW9ucykpIHtcbiAgICAvLyBXaWR0aFxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMud2lkdGgpKSB7XG4gICAgICBpZiAoaXMuaW50ZWdlcihvcHRpb25zLndpZHRoKSAmJiBvcHRpb25zLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd3aWR0aCcsICdwb3NpdGl2ZSBpbnRlZ2VyJywgb3B0aW9ucy53aWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEhlaWdodFxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMuaGVpZ2h0KSkge1xuICAgICAgaWYgKGlzLmludGVnZXIob3B0aW9ucy5oZWlnaHQpICYmIG9wdGlvbnMuaGVpZ2h0ID4gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2hlaWdodCcsICdwb3NpdGl2ZSBpbnRlZ2VyJywgb3B0aW9ucy5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXRcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmZpdCkpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG1hcEZpdFRvQ2FudmFzW29wdGlvbnMuZml0XTtcbiAgICAgIGlmIChpcy5zdHJpbmcoY2FudmFzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2FudmFzID0gY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdmaXQnLCAndmFsaWQgZml0Jywgb3B0aW9ucy5maXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3NpdGlvblxuICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMucG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3MgPSBpcy5pbnRlZ2VyKG9wdGlvbnMucG9zaXRpb24pXG4gICAgICAgID8gb3B0aW9ucy5wb3NpdGlvblxuICAgICAgICA6IHN0cmF0ZWd5W29wdGlvbnMucG9zaXRpb25dIHx8IHBvc2l0aW9uW29wdGlvbnMucG9zaXRpb25dIHx8IGdyYXZpdHlbb3B0aW9ucy5wb3NpdGlvbl07XG4gICAgICBpZiAoaXMuaW50ZWdlcihwb3MpICYmIChpcy5pblJhbmdlKHBvcywgMCwgOCkgfHwgaXMuaW5SYW5nZShwb3MsIDE2LCAxNykpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcigncG9zaXRpb24nLCAndmFsaWQgcG9zaXRpb24vZ3Jhdml0eS9zdHJhdGVneScsIG9wdGlvbnMucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBCYWNrZ3JvdW5kXG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG91ck9wdGlvbigncmVzaXplQmFja2dyb3VuZCcsIG9wdGlvbnMuYmFja2dyb3VuZCk7XG4gICAgLy8gS2VybmVsXG4gICAgaWYgKGlzLmRlZmluZWQob3B0aW9ucy5rZXJuZWwpKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKGtlcm5lbFtvcHRpb25zLmtlcm5lbF0pKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5rZXJuZWwgPSBrZXJuZWxbb3B0aW9ucy5rZXJuZWxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdrZXJuZWwnLCAndmFsaWQga2VybmVsIG5hbWUnLCBvcHRpb25zLmtlcm5lbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdpdGhvdXQgZW5sYXJnZW1lbnRcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLndpdGhvdXRFbmxhcmdlbWVudCkpIHtcbiAgICAgIHRoaXMuX3NldEJvb2xlYW5PcHRpb24oJ3dpdGhvdXRFbmxhcmdlbWVudCcsIG9wdGlvbnMud2l0aG91dEVubGFyZ2VtZW50KTtcbiAgICB9XG4gICAgLy8gV2l0aG91dCByZWR1Y3Rpb25cbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLndpdGhvdXRSZWR1Y3Rpb24pKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCd3aXRob3V0UmVkdWN0aW9uJywgb3B0aW9ucy53aXRob3V0UmVkdWN0aW9uKTtcbiAgICB9XG4gICAgLy8gU2hyaW5rIG9uIGxvYWRcbiAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmZhc3RTaHJpbmtPbkxvYWQpKSB7XG4gICAgICB0aGlzLl9zZXRCb29sZWFuT3B0aW9uKCdmYXN0U2hyaW5rT25Mb2FkJywgb3B0aW9ucy5mYXN0U2hyaW5rT25Mb2FkKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUm90YXRpb25FeHBlY3RlZCh0aGlzLm9wdGlvbnMpICYmIGlzUmVzaXplRXhwZWN0ZWQodGhpcy5vcHRpb25zKSkge1xuICAgIHRoaXMub3B0aW9ucy5yb3RhdGVCZWZvcmUgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEV4dGVuZCAvIHBhZCAvIGV4dHJ1ZGUgb25lIG9yIG1vcmUgZWRnZXMgb2YgdGhlIGltYWdlIHdpdGggZWl0aGVyXG4gKiB0aGUgcHJvdmlkZWQgYmFja2dyb3VuZCBjb2xvdXIgb3IgcGl4ZWxzIGRlcml2ZWQgZnJvbSB0aGUgaW1hZ2UuXG4gKiBUaGlzIG9wZXJhdGlvbiB3aWxsIGFsd2F5cyBvY2N1ciBhZnRlciByZXNpemluZyBhbmQgZXh0cmFjdGlvbiwgaWYgYW55LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXNpemUgdG8gMTQwIHBpeGVscyB3aWRlLCB0aGVuIGFkZCAxMCB0cmFuc3BhcmVudCBwaXhlbHNcbiAqIC8vIHRvIHRoZSB0b3AsIGxlZnQgYW5kIHJpZ2h0IGVkZ2VzIGFuZCAyMCB0byB0aGUgYm90dG9tIGVkZ2VcbiAqIHNoYXJwKGlucHV0KVxuICogICAucmVzaXplKDE0MClcbiAqICAgLmV4dGVuZCh7XG4gKiAgICAgdG9wOiAxMCxcbiAqICAgICBib3R0b206IDIwLFxuICogICAgIGxlZnQ6IDEwLFxuICogICAgIHJpZ2h0OiAxMCxcbiAqICAgICBiYWNrZ3JvdW5kOiB7IHI6IDAsIGc6IDAsIGI6IDAsIGFscGhhOiAwIH1cbiAqICAgfSlcbiAqICAgLi4uXG4gKlxuKiBAZXhhbXBsZVxuICogLy8gQWRkIGEgcm93IG9mIDEwIHJlZCBwaXhlbHMgdG8gdGhlIGJvdHRvbVxuICogc2hhcnAoaW5wdXQpXG4gKiAgIC5leHRlbmQoe1xuICogICAgIGJvdHRvbTogMTAsXG4gKiAgICAgYmFja2dyb3VuZDogJ3JlZCdcbiAqICAgfSlcbiAqICAgLi4uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4dHJ1ZGUgaW1hZ2UgYnkgOCBwaXhlbHMgdG8gdGhlIHJpZ2h0LCBtaXJyb3JpbmcgZXhpc3RpbmcgcmlnaHQgaGFuZCBlZGdlXG4gKiBzaGFycChpbnB1dClcbiAqICAgLmV4dGVuZCh7XG4gKiAgICAgcmlnaHQ6IDgsXG4gKiAgICAgYmFja2dyb3VuZDogJ21pcnJvcidcbiAqICAgfSlcbiAqICAgLi4uXG4gKlxuICogQHBhcmFtIHsobnVtYmVyfE9iamVjdCl9IGV4dGVuZCAtIHNpbmdsZSBwaXhlbCBjb3VudCB0byBhZGQgdG8gYWxsIGVkZ2VzIG9yIGFuIE9iamVjdCB3aXRoIHBlci1lZGdlIGNvdW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtleHRlbmQudG9wPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW2V4dGVuZC5sZWZ0PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW2V4dGVuZC5ib3R0b209MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZXh0ZW5kLnJpZ2h0PTBdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2V4dGVuZC5leHRlbmRXaXRoPSdiYWNrZ3JvdW5kJ10gLSBwb3B1bGF0ZSBuZXcgcGl4ZWxzIHVzaW5nIHRoaXMgbWV0aG9kLCBvbmUgb2Y6IGJhY2tncm91bmQsIGNvcHksIHJlcGVhdCwgbWlycm9yLlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbZXh0ZW5kLmJhY2tncm91bmQ9e3I6IDAsIGc6IDAsIGI6IDAsIGFscGhhOiAxfV0gLSBiYWNrZ3JvdW5kIGNvbG91ciwgcGFyc2VkIGJ5IHRoZSBbY29sb3JdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL2NvbG9yKSBtb2R1bGUsIGRlZmF1bHRzIHRvIGJsYWNrIHdpdGhvdXQgdHJhbnNwYXJlbmN5LlxuICogQHJldHVybnMge1NoYXJwfVxuICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuKi9cbmZ1bmN0aW9uIGV4dGVuZCAoZXh0ZW5kKSB7XG4gIGlmIChpcy5pbnRlZ2VyKGV4dGVuZCkgJiYgZXh0ZW5kID4gMCkge1xuICAgIHRoaXMub3B0aW9ucy5leHRlbmRUb3AgPSBleHRlbmQ7XG4gICAgdGhpcy5vcHRpb25zLmV4dGVuZEJvdHRvbSA9IGV4dGVuZDtcbiAgICB0aGlzLm9wdGlvbnMuZXh0ZW5kTGVmdCA9IGV4dGVuZDtcbiAgICB0aGlzLm9wdGlvbnMuZXh0ZW5kUmlnaHQgPSBleHRlbmQ7XG4gIH0gZWxzZSBpZiAoaXMub2JqZWN0KGV4dGVuZCkpIHtcbiAgICBpZiAoaXMuZGVmaW5lZChleHRlbmQudG9wKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoZXh0ZW5kLnRvcCkgJiYgZXh0ZW5kLnRvcCA+PSAwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5leHRlbmRUb3AgPSBleHRlbmQudG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCd0b3AnLCAncG9zaXRpdmUgaW50ZWdlcicsIGV4dGVuZC50b3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChleHRlbmQuYm90dG9tKSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoZXh0ZW5kLmJvdHRvbSkgJiYgZXh0ZW5kLmJvdHRvbSA+PSAwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5leHRlbmRCb3R0b20gPSBleHRlbmQuYm90dG9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgaXMuaW52YWxpZFBhcmFtZXRlckVycm9yKCdib3R0b20nLCAncG9zaXRpdmUgaW50ZWdlcicsIGV4dGVuZC5ib3R0b20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXMuZGVmaW5lZChleHRlbmQubGVmdCkpIHtcbiAgICAgIGlmIChpcy5pbnRlZ2VyKGV4dGVuZC5sZWZ0KSAmJiBleHRlbmQubGVmdCA+PSAwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5leHRlbmRMZWZ0ID0gZXh0ZW5kLmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2xlZnQnLCAncG9zaXRpdmUgaW50ZWdlcicsIGV4dGVuZC5sZWZ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzLmRlZmluZWQoZXh0ZW5kLnJpZ2h0KSkge1xuICAgICAgaWYgKGlzLmludGVnZXIoZXh0ZW5kLnJpZ2h0KSAmJiBleHRlbmQucmlnaHQgPj0gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5kUmlnaHQgPSBleHRlbmQucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3JpZ2h0JywgJ3Bvc2l0aXZlIGludGVnZXInLCBleHRlbmQucmlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3VyT3B0aW9uKCdleHRlbmRCYWNrZ3JvdW5kJywgZXh0ZW5kLmJhY2tncm91bmQpO1xuICAgIGlmIChpcy5kZWZpbmVkKGV4dGVuZC5leHRlbmRXaXRoKSkge1xuICAgICAgaWYgKGlzLnN0cmluZyhleHRlbmRXaXRoW2V4dGVuZC5leHRlbmRXaXRoXSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuZFdpdGggPSBleHRlbmRXaXRoW2V4dGVuZC5leHRlbmRXaXRoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignZXh0ZW5kV2l0aCcsICdvbmUgb2Y6IGJhY2tncm91bmQsIGNvcHksIHJlcGVhdCwgbWlycm9yJywgZXh0ZW5kLmV4dGVuZFdpdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2V4dGVuZCcsICdpbnRlZ2VyIG9yIG9iamVjdCcsIGV4dGVuZCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogRXh0cmFjdC9jcm9wIGEgcmVnaW9uIG9mIHRoZSBpbWFnZS5cbiAqXG4gKiAtIFVzZSBgZXh0cmFjdGAgYmVmb3JlIGByZXNpemVgIGZvciBwcmUtcmVzaXplIGV4dHJhY3Rpb24uXG4gKiAtIFVzZSBgZXh0cmFjdGAgYWZ0ZXIgYHJlc2l6ZWAgZm9yIHBvc3QtcmVzaXplIGV4dHJhY3Rpb24uXG4gKiAtIFVzZSBgZXh0cmFjdGAgdHdpY2UgYW5kIGByZXNpemVgIG9uY2UgZm9yIGV4dHJhY3QtdGhlbi1yZXNpemUtdGhlbi1leHRyYWN0IGluIGEgZml4ZWQgb3BlcmF0aW9uIG9yZGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBzaGFycChpbnB1dClcbiAqICAgLmV4dHJhY3QoeyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KVxuICogICAudG9GaWxlKG91dHB1dCwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgLy8gRXh0cmFjdCBhIHJlZ2lvbiBvZiB0aGUgaW5wdXQgaW1hZ2UsIHNhdmluZyBpbiB0aGUgc2FtZSBmb3JtYXQuXG4gKiAgIH0pO1xuICogQGV4YW1wbGVcbiAqIHNoYXJwKGlucHV0KVxuICogICAuZXh0cmFjdCh7IGxlZnQ6IGxlZnRPZmZzZXRQcmUsIHRvcDogdG9wT2Zmc2V0UHJlLCB3aWR0aDogd2lkdGhQcmUsIGhlaWdodDogaGVpZ2h0UHJlIH0pXG4gKiAgIC5yZXNpemUod2lkdGgsIGhlaWdodClcbiAqICAgLmV4dHJhY3QoeyBsZWZ0OiBsZWZ0T2Zmc2V0UG9zdCwgdG9wOiB0b3BPZmZzZXRQb3N0LCB3aWR0aDogd2lkdGhQb3N0LCBoZWlnaHQ6IGhlaWdodFBvc3QgfSlcbiAqICAgLnRvRmlsZShvdXRwdXQsIGZ1bmN0aW9uKGVycikge1xuICogICAgIC8vIEV4dHJhY3QgYSByZWdpb24sIHJlc2l6ZSwgdGhlbiBleHRyYWN0IGZyb20gdGhlIHJlc2l6ZWQgaW1hZ2VcbiAqICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBkZXNjcmliZXMgdGhlIHJlZ2lvbiB0byBleHRyYWN0IHVzaW5nIGludGVncmFsIHBpeGVsIHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVmdCAtIHplcm8taW5kZXhlZCBvZmZzZXQgZnJvbSBsZWZ0IGVkZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvcCAtIHplcm8taW5kZXhlZCBvZmZzZXQgZnJvbSB0b3AgZWRnZVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSB3aWR0aCBvZiByZWdpb24gdG8gZXh0cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gaGVpZ2h0IG9mIHJlZ2lvbiB0byBleHRyYWN0XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3QgKG9wdGlvbnMpIHtcbiAgY29uc3Qgc3VmZml4ID0gaXNSZXNpemVFeHBlY3RlZCh0aGlzLm9wdGlvbnMpIHx8IHRoaXMub3B0aW9ucy53aWR0aFByZSAhPT0gLTEgPyAnUG9zdCcgOiAnUHJlJztcbiAgaWYgKHRoaXMub3B0aW9uc1tgd2lkdGgke3N1ZmZpeH1gXSAhPT0gLTEpIHtcbiAgICB0aGlzLm9wdGlvbnMuZGVidWdsb2coJ2lnbm9yaW5nIHByZXZpb3VzIGV4dHJhY3Qgb3B0aW9ucycpO1xuICB9XG4gIFsnbGVmdCcsICd0b3AnLCAnd2lkdGgnLCAnaGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tuYW1lXTtcbiAgICBpZiAoaXMuaW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMCkge1xuICAgICAgdGhpcy5vcHRpb25zW25hbWUgKyAobmFtZSA9PT0gJ2xlZnQnIHx8IG5hbWUgPT09ICd0b3AnID8gJ09mZnNldCcgOiAnJykgKyBzdWZmaXhdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcihuYW1lLCAnaW50ZWdlcicsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuICAvLyBFbnN1cmUgZXhpc3Rpbmcgcm90YXRpb24gb2NjdXJzIGJlZm9yZSBwcmUtcmVzaXplIGV4dHJhY3Rpb25cbiAgaWYgKGlzUm90YXRpb25FeHBlY3RlZCh0aGlzLm9wdGlvbnMpICYmICFpc1Jlc2l6ZUV4cGVjdGVkKHRoaXMub3B0aW9ucykpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLndpZHRoUHJlID09PSAtMSB8fCB0aGlzLm9wdGlvbnMud2lkdGhQb3N0ID09PSAtMSkge1xuICAgICAgdGhpcy5vcHRpb25zLnJvdGF0ZUJlZm9yZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuaW5wdXQuYXV0b09yaWVudCkge1xuICAgIHRoaXMub3B0aW9ucy5vcmllbnRCZWZvcmUgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFRyaW0gcGl4ZWxzIGZyb20gYWxsIGVkZ2VzIHRoYXQgY29udGFpbiB2YWx1ZXMgc2ltaWxhciB0byB0aGUgZ2l2ZW4gYmFja2dyb3VuZCBjb2xvdXIsIHdoaWNoIGRlZmF1bHRzIHRvIHRoYXQgb2YgdGhlIHRvcC1sZWZ0IHBpeGVsLlxuICpcbiAqIEltYWdlcyB3aXRoIGFuIGFscGhhIGNoYW5uZWwgd2lsbCB1c2UgdGhlIGNvbWJpbmVkIGJvdW5kaW5nIGJveCBvZiBhbHBoYSBhbmQgbm9uLWFscGhhIGNoYW5uZWxzLlxuICpcbiAqIElmIHRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb24gd291bGQgdHJpbSBhbiBpbWFnZSB0byBub3RoaW5nIHRoZW4gbm8gY2hhbmdlIGlzIG1hZGUuXG4gKlxuICogVGhlIGBpbmZvYCByZXNwb25zZSBPYmplY3Qgd2lsbCBjb250YWluIGB0cmltT2Zmc2V0TGVmdGAgYW5kIGB0cmltT2Zmc2V0VG9wYCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUcmltIHBpeGVscyB3aXRoIGEgY29sb3VyIHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgdG9wLWxlZnQgcGl4ZWwuXG4gKiBhd2FpdCBzaGFycChpbnB1dClcbiAqICAgLnRyaW0oKVxuICogICAudG9GaWxlKG91dHB1dCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRyaW0gcGl4ZWxzIHdpdGggdGhlIGV4YWN0IHNhbWUgY29sb3VyIGFzIHRoYXQgb2YgdGhlIHRvcC1sZWZ0IHBpeGVsLlxuICogYXdhaXQgc2hhcnAoaW5wdXQpXG4gKiAgIC50cmltKHtcbiAqICAgICB0aHJlc2hvbGQ6IDBcbiAqICAgfSlcbiAqICAgLnRvRmlsZShvdXRwdXQpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBc3N1bWUgaW5wdXQgaXMgbGluZSBhcnQgYW5kIHRyaW0gb25seSBwaXhlbHMgd2l0aCBhIHNpbWlsYXIgY29sb3VyIHRvIHJlZC5cbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAudHJpbSh7XG4gKiAgICAgYmFja2dyb3VuZDogXCIjRkYwMDAwXCIsXG4gKiAgICAgbGluZUFydDogdHJ1ZVxuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVHJpbSBhbGwgXCJ5ZWxsb3ctaXNoXCIgcGl4ZWxzLCBiZWluZyBtb3JlIGxlbmllbnQgd2l0aCB0aGUgaGlnaGVyIHRocmVzaG9sZC5cbiAqIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNoYXJwKGlucHV0KVxuICogICAudHJpbSh7XG4gKiAgICAgYmFja2dyb3VuZDogXCJ5ZWxsb3dcIixcbiAqICAgICB0aHJlc2hvbGQ6IDQyLFxuICogICB9KVxuICogICAudG9CdWZmZXIoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtvcHRpb25zLmJhY2tncm91bmQ9J3RvcC1sZWZ0IHBpeGVsJ10gLSBCYWNrZ3JvdW5kIGNvbG91ciwgcGFyc2VkIGJ5IHRoZSBbY29sb3JdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL2NvbG9yKSBtb2R1bGUsIGRlZmF1bHRzIHRvIHRoYXQgb2YgdGhlIHRvcC1sZWZ0IHBpeGVsLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMF0gLSBBbGxvd2VkIGRpZmZlcmVuY2UgZnJvbSB0aGUgYWJvdmUgY29sb3VyLCBhIHBvc2l0aXZlIG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGluZUFydD1mYWxzZV0gLSBEb2VzIHRoZSBpbnB1dCBtb3JlIGNsb3NlbHkgcmVzZW1ibGUgbGluZSBhcnQgKGUuZy4gdmVjdG9yKSByYXRoZXIgdGhhbiBiZWluZyBwaG90b2dyYXBoaWM/XG4gKiBAcmV0dXJucyB7U2hhcnB9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIHRyaW0gKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zLnRyaW1UaHJlc2hvbGQgPSAxMDtcbiAgaWYgKGlzLmRlZmluZWQob3B0aW9ucykpIHtcbiAgICBpZiAoaXMub2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICBpZiAoaXMuZGVmaW5lZChvcHRpb25zLmJhY2tncm91bmQpKSB7XG4gICAgICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvdXJPcHRpb24oJ3RyaW1CYWNrZ3JvdW5kJywgb3B0aW9ucy5iYWNrZ3JvdW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMudGhyZXNob2xkKSkge1xuICAgICAgICBpZiAoaXMubnVtYmVyKG9wdGlvbnMudGhyZXNob2xkKSAmJiBvcHRpb25zLnRocmVzaG9sZCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnRyaW1UaHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RocmVzaG9sZCcsICdwb3NpdGl2ZSBudW1iZXInLCBvcHRpb25zLnRocmVzaG9sZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpcy5kZWZpbmVkKG9wdGlvbnMubGluZUFydCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm9vbGVhbk9wdGlvbigndHJpbUxpbmVBcnQnLCBvcHRpb25zLmxpbmVBcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ3RyaW0nLCAnb2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1JvdGF0aW9uRXhwZWN0ZWQodGhpcy5vcHRpb25zKSkge1xuICAgIHRoaXMub3B0aW9ucy5yb3RhdGVCZWZvcmUgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIERlY29yYXRlIHRoZSBTaGFycCBwcm90b3R5cGUgd2l0aCByZXNpemUtcmVsYXRlZCBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlIFNoYXJwXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTaGFycCkge1xuICBPYmplY3QuYXNzaWduKFNoYXJwLnByb3RvdHlwZSwge1xuICAgIHJlc2l6ZSxcbiAgICBleHRlbmQsXG4gICAgZXh0cmFjdCxcbiAgICB0cmltXG4gIH0pO1xuICAvLyBDbGFzcyBhdHRyaWJ1dGVzXG4gIFNoYXJwLmdyYXZpdHkgPSBncmF2aXR5O1xuICBTaGFycC5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBTaGFycC5rZXJuZWwgPSBrZXJuZWw7XG4gIFNoYXJwLmZpdCA9IGZpdDtcbiAgU2hhcnAucG9zaXRpb24gPSBwb3NpdGlvbjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/resize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\n// Inspects the runtime environment and exports the relevant sharp.node binary\n\nconst { familySync, versionSync } = __webpack_require__(/*! detect-libc */ \"(rsc)/./node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/detect-libc.js\");\n\nconst { runtimePlatformArch, isUnsupportedNodeRuntime, prebuiltPlatforms, minimumLibvipsVersion } = __webpack_require__(/*! ./libvips */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/libvips.js\");\nconst runtimePlatform = runtimePlatformArch();\n\nconst paths = [\n  `../src/build/Release/sharp-${runtimePlatform}.node`,\n  '../src/build/Release/sharp-wasm32.node',\n  `@img/sharp-${runtimePlatform}/sharp.node`,\n  '@img/sharp-wasm32/sharp.node'\n];\n\nlet path, sharp;\nconst errors = [];\nfor (path of paths) {\n  try {\n    sharp = __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib sync recursive\")(path);\n    break;\n  } catch (err) {\n    /* istanbul ignore next */\n    errors.push(err);\n  }\n}\n\n/* istanbul ignore next */\nif (sharp && path.startsWith('@img/sharp-linux-x64') && !sharp._isUsingX64V2()) {\n  const err = new Error('Prebuilt binaries for linux-x64 require v2 microarchitecture');\n  err.code = 'Unsupported CPU';\n  errors.push(err);\n  sharp = null;\n}\n\n/* istanbul ignore next */\nif (sharp) {\n  module.exports = sharp;\n} else {\n  const [isLinux, isMacOs, isWindows] = ['linux', 'darwin', 'win32'].map(os => runtimePlatform.startsWith(os));\n\n  const help = [`Could not load the \"sharp\" module using the ${runtimePlatform} runtime`];\n  errors.forEach(err => {\n    if (err.code !== 'MODULE_NOT_FOUND') {\n      help.push(`${err.code}: ${err.message}`);\n    }\n  });\n  const messages = errors.map(err => err.message).join(' ');\n  help.push('Possible solutions:');\n  // Common error messages\n  if (isUnsupportedNodeRuntime()) {\n    const { found, expected } = isUnsupportedNodeRuntime();\n    help.push(\n      '- Please upgrade Node.js:',\n      `    Found ${found}`,\n      `    Requires ${expected}`\n    );\n  } else if (prebuiltPlatforms.includes(runtimePlatform)) {\n    const [os, cpu] = runtimePlatform.split('-');\n    const libc = os.endsWith('musl') ? ' --libc=musl' : '';\n    help.push(\n      '- Ensure optional dependencies can be installed:',\n      '    npm install --include=optional sharp',\n      '- Ensure your package manager supports multi-platform installation:',\n      '    See https://sharp.pixelplumbing.com/install#cross-platform',\n      '- Add platform-specific dependencies:',\n      `    npm install --os=${os.replace('musl', '')}${libc} --cpu=${cpu} sharp`\n    );\n  } else {\n    help.push(\n      `- Manually install libvips >= ${minimumLibvipsVersion}`,\n      '- Add experimental WebAssembly-based dependencies:',\n      '    npm install --cpu=wasm32 sharp',\n      '    npm install @img/sharp-wasm32'\n    );\n  }\n  if (isLinux && /(symbol not found|CXXABI_)/i.test(messages)) {\n    try {\n      const { config } = __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img sync recursive ^\\\\.\\\\/sharp\\\\-libvips\\\\-.*\\\\/package$\")(`./sharp-libvips-${runtimePlatform}/package`);\n      const libcFound = `${familySync()} ${versionSync()}`;\n      const libcRequires = `${config.musl ? 'musl' : 'glibc'} ${config.musl || config.glibc}`;\n      help.push(\n        '- Update your OS:',\n        `    Found ${libcFound}`,\n        `    Requires ${libcRequires}`\n      );\n    } catch (errEngines) {}\n  }\n  if (isLinux && /\\/snap\\/core[0-9]{2}/.test(messages)) {\n    help.push(\n      '- Remove the Node.js Snap, which does not support native modules',\n      '    snap remove node'\n    );\n  }\n  if (isMacOs && /Incompatible library version/.test(messages)) {\n    help.push(\n      '- Update Homebrew:',\n      '    brew update && brew upgrade vips'\n    );\n  }\n  if (errors.some(err => err.code === 'ERR_DLOPEN_DISABLED')) {\n    help.push('- Run Node.js without using the --no-addons flag');\n  }\n  // Link to installation docs\n  if (isWindows && /The specified procedure could not be found/.test(messages)) {\n    help.push(\n      '- Using the canvas package on Windows?',\n      '    See https://sharp.pixelplumbing.com/install#canvas-and-windows',\n      '- Check for outdated versions of sharp in the dependency tree:',\n      '    npm ls sharp'\n    );\n  }\n  help.push(\n    '- Consult the installation documentation:',\n    '    See https://sharp.pixelplumbing.com/install'\n  );\n  throw new Error(help.join('\\n'));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvc2hhcnAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsNkdBQWE7O0FBRXpELFFBQVEsMEZBQTBGLEVBQUUsbUJBQU8sQ0FBQyw0RkFBVztBQUN2SDs7QUFFQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFHQUFRLElBQUksQ0FBQztBQUN6QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsSUFBSSxZQUFZO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCLEVBQUUsTUFBTSxRQUFRLEtBQUs7QUFDMUU7QUFDQSxJQUFJO0FBQ0o7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEVBQUUsdVZBQVEsaUJBQW9CLEVBQUUsZ0JBQWdCLFNBQVMsQ0FBQztBQUNqRiwyQkFBMkIsY0FBYyxFQUFFLGNBQWM7QUFDekQsOEJBQThCLGdDQUFnQyxFQUFFLDRCQUE0QjtBQUM1RjtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0Isd0JBQXdCLGFBQWE7QUFDckM7QUFDQSxNQUFNO0FBQ047QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbnJvdXRlci1sYW5nZ3JhcGgvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvc2hhcnAuanM/NmFmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMyBMb3ZlbGwgRnVsbGVyIGFuZCBvdGhlcnMuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIEluc3BlY3RzIHRoZSBydW50aW1lIGVudmlyb25tZW50IGFuZCBleHBvcnRzIHRoZSByZWxldmFudCBzaGFycC5ub2RlIGJpbmFyeVxuXG5jb25zdCB7IGZhbWlseVN5bmMsIHZlcnNpb25TeW5jIH0gPSByZXF1aXJlKCdkZXRlY3QtbGliYycpO1xuXG5jb25zdCB7IHJ1bnRpbWVQbGF0Zm9ybUFyY2gsIGlzVW5zdXBwb3J0ZWROb2RlUnVudGltZSwgcHJlYnVpbHRQbGF0Zm9ybXMsIG1pbmltdW1MaWJ2aXBzVmVyc2lvbiB9ID0gcmVxdWlyZSgnLi9saWJ2aXBzJyk7XG5jb25zdCBydW50aW1lUGxhdGZvcm0gPSBydW50aW1lUGxhdGZvcm1BcmNoKCk7XG5cbmNvbnN0IHBhdGhzID0gW1xuICBgLi4vc3JjL2J1aWxkL1JlbGVhc2Uvc2hhcnAtJHtydW50aW1lUGxhdGZvcm19Lm5vZGVgLFxuICAnLi4vc3JjL2J1aWxkL1JlbGVhc2Uvc2hhcnAtd2FzbTMyLm5vZGUnLFxuICBgQGltZy9zaGFycC0ke3J1bnRpbWVQbGF0Zm9ybX0vc2hhcnAubm9kZWAsXG4gICdAaW1nL3NoYXJwLXdhc20zMi9zaGFycC5ub2RlJ1xuXTtcblxubGV0IHBhdGgsIHNoYXJwO1xuY29uc3QgZXJyb3JzID0gW107XG5mb3IgKHBhdGggb2YgcGF0aHMpIHtcbiAgdHJ5IHtcbiAgICBzaGFycCA9IHJlcXVpcmUocGF0aCk7XG4gICAgYnJlYWs7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgfVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHNoYXJwICYmIHBhdGguc3RhcnRzV2l0aCgnQGltZy9zaGFycC1saW51eC14NjQnKSAmJiAhc2hhcnAuX2lzVXNpbmdYNjRWMigpKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcignUHJlYnVpbHQgYmluYXJpZXMgZm9yIGxpbnV4LXg2NCByZXF1aXJlIHYyIG1pY3JvYXJjaGl0ZWN0dXJlJyk7XG4gIGVyci5jb2RlID0gJ1Vuc3VwcG9ydGVkIENQVSc7XG4gIGVycm9ycy5wdXNoKGVycik7XG4gIHNoYXJwID0gbnVsbDtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChzaGFycCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNoYXJwO1xufSBlbHNlIHtcbiAgY29uc3QgW2lzTGludXgsIGlzTWFjT3MsIGlzV2luZG93c10gPSBbJ2xpbnV4JywgJ2RhcndpbicsICd3aW4zMiddLm1hcChvcyA9PiBydW50aW1lUGxhdGZvcm0uc3RhcnRzV2l0aChvcykpO1xuXG4gIGNvbnN0IGhlbHAgPSBbYENvdWxkIG5vdCBsb2FkIHRoZSBcInNoYXJwXCIgbW9kdWxlIHVzaW5nIHRoZSAke3J1bnRpbWVQbGF0Zm9ybX0gcnVudGltZWBdO1xuICBlcnJvcnMuZm9yRWFjaChlcnIgPT4ge1xuICAgIGlmIChlcnIuY29kZSAhPT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICBoZWxwLnB1c2goYCR7ZXJyLmNvZGV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gZXJyb3JzLm1hcChlcnIgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oJyAnKTtcbiAgaGVscC5wdXNoKCdQb3NzaWJsZSBzb2x1dGlvbnM6Jyk7XG4gIC8vIENvbW1vbiBlcnJvciBtZXNzYWdlc1xuICBpZiAoaXNVbnN1cHBvcnRlZE5vZGVSdW50aW1lKCkpIHtcbiAgICBjb25zdCB7IGZvdW5kLCBleHBlY3RlZCB9ID0gaXNVbnN1cHBvcnRlZE5vZGVSdW50aW1lKCk7XG4gICAgaGVscC5wdXNoKFxuICAgICAgJy0gUGxlYXNlIHVwZ3JhZGUgTm9kZS5qczonLFxuICAgICAgYCAgICBGb3VuZCAke2ZvdW5kfWAsXG4gICAgICBgICAgIFJlcXVpcmVzICR7ZXhwZWN0ZWR9YFxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJlYnVpbHRQbGF0Zm9ybXMuaW5jbHVkZXMocnVudGltZVBsYXRmb3JtKSkge1xuICAgIGNvbnN0IFtvcywgY3B1XSA9IHJ1bnRpbWVQbGF0Zm9ybS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxpYmMgPSBvcy5lbmRzV2l0aCgnbXVzbCcpID8gJyAtLWxpYmM9bXVzbCcgOiAnJztcbiAgICBoZWxwLnB1c2goXG4gICAgICAnLSBFbnN1cmUgb3B0aW9uYWwgZGVwZW5kZW5jaWVzIGNhbiBiZSBpbnN0YWxsZWQ6JyxcbiAgICAgICcgICAgbnBtIGluc3RhbGwgLS1pbmNsdWRlPW9wdGlvbmFsIHNoYXJwJyxcbiAgICAgICctIEVuc3VyZSB5b3VyIHBhY2thZ2UgbWFuYWdlciBzdXBwb3J0cyBtdWx0aS1wbGF0Zm9ybSBpbnN0YWxsYXRpb246JyxcbiAgICAgICcgICAgU2VlIGh0dHBzOi8vc2hhcnAucGl4ZWxwbHVtYmluZy5jb20vaW5zdGFsbCNjcm9zcy1wbGF0Zm9ybScsXG4gICAgICAnLSBBZGQgcGxhdGZvcm0tc3BlY2lmaWMgZGVwZW5kZW5jaWVzOicsXG4gICAgICBgICAgIG5wbSBpbnN0YWxsIC0tb3M9JHtvcy5yZXBsYWNlKCdtdXNsJywgJycpfSR7bGliY30gLS1jcHU9JHtjcHV9IHNoYXJwYFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaGVscC5wdXNoKFxuICAgICAgYC0gTWFudWFsbHkgaW5zdGFsbCBsaWJ2aXBzID49ICR7bWluaW11bUxpYnZpcHNWZXJzaW9ufWAsXG4gICAgICAnLSBBZGQgZXhwZXJpbWVudGFsIFdlYkFzc2VtYmx5LWJhc2VkIGRlcGVuZGVuY2llczonLFxuICAgICAgJyAgICBucG0gaW5zdGFsbCAtLWNwdT13YXNtMzIgc2hhcnAnLFxuICAgICAgJyAgICBucG0gaW5zdGFsbCBAaW1nL3NoYXJwLXdhc20zMidcbiAgICApO1xuICB9XG4gIGlmIChpc0xpbnV4ICYmIC8oc3ltYm9sIG5vdCBmb3VuZHxDWFhBQklfKS9pLnRlc3QobWVzc2FnZXMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY29uZmlnIH0gPSByZXF1aXJlKGBAaW1nL3NoYXJwLWxpYnZpcHMtJHtydW50aW1lUGxhdGZvcm19L3BhY2thZ2VgKTtcbiAgICAgIGNvbnN0IGxpYmNGb3VuZCA9IGAke2ZhbWlseVN5bmMoKX0gJHt2ZXJzaW9uU3luYygpfWA7XG4gICAgICBjb25zdCBsaWJjUmVxdWlyZXMgPSBgJHtjb25maWcubXVzbCA/ICdtdXNsJyA6ICdnbGliYyd9ICR7Y29uZmlnLm11c2wgfHwgY29uZmlnLmdsaWJjfWA7XG4gICAgICBoZWxwLnB1c2goXG4gICAgICAgICctIFVwZGF0ZSB5b3VyIE9TOicsXG4gICAgICAgIGAgICAgRm91bmQgJHtsaWJjRm91bmR9YCxcbiAgICAgICAgYCAgICBSZXF1aXJlcyAke2xpYmNSZXF1aXJlc31gXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVyckVuZ2luZXMpIHt9XG4gIH1cbiAgaWYgKGlzTGludXggJiYgL1xcL3NuYXBcXC9jb3JlWzAtOV17Mn0vLnRlc3QobWVzc2FnZXMpKSB7XG4gICAgaGVscC5wdXNoKFxuICAgICAgJy0gUmVtb3ZlIHRoZSBOb2RlLmpzIFNuYXAsIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgbmF0aXZlIG1vZHVsZXMnLFxuICAgICAgJyAgICBzbmFwIHJlbW92ZSBub2RlJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzTWFjT3MgJiYgL0luY29tcGF0aWJsZSBsaWJyYXJ5IHZlcnNpb24vLnRlc3QobWVzc2FnZXMpKSB7XG4gICAgaGVscC5wdXNoKFxuICAgICAgJy0gVXBkYXRlIEhvbWVicmV3OicsXG4gICAgICAnICAgIGJyZXcgdXBkYXRlICYmIGJyZXcgdXBncmFkZSB2aXBzJ1xuICAgICk7XG4gIH1cbiAgaWYgKGVycm9ycy5zb21lKGVyciA9PiBlcnIuY29kZSA9PT0gJ0VSUl9ETE9QRU5fRElTQUJMRUQnKSkge1xuICAgIGhlbHAucHVzaCgnLSBSdW4gTm9kZS5qcyB3aXRob3V0IHVzaW5nIHRoZSAtLW5vLWFkZG9ucyBmbGFnJyk7XG4gIH1cbiAgLy8gTGluayB0byBpbnN0YWxsYXRpb24gZG9jc1xuICBpZiAoaXNXaW5kb3dzICYmIC9UaGUgc3BlY2lmaWVkIHByb2NlZHVyZSBjb3VsZCBub3QgYmUgZm91bmQvLnRlc3QobWVzc2FnZXMpKSB7XG4gICAgaGVscC5wdXNoKFxuICAgICAgJy0gVXNpbmcgdGhlIGNhbnZhcyBwYWNrYWdlIG9uIFdpbmRvd3M/JyxcbiAgICAgICcgICAgU2VlIGh0dHBzOi8vc2hhcnAucGl4ZWxwbHVtYmluZy5jb20vaW5zdGFsbCNjYW52YXMtYW5kLXdpbmRvd3MnLFxuICAgICAgJy0gQ2hlY2sgZm9yIG91dGRhdGVkIHZlcnNpb25zIG9mIHNoYXJwIGluIHRoZSBkZXBlbmRlbmN5IHRyZWU6JyxcbiAgICAgICcgICAgbnBtIGxzIHNoYXJwJ1xuICAgICk7XG4gIH1cbiAgaGVscC5wdXNoKFxuICAgICctIENvbnN1bHQgdGhlIGluc3RhbGxhdGlvbiBkb2N1bWVudGF0aW9uOicsXG4gICAgJyAgICBTZWUgaHR0cHM6Ly9zaGFycC5waXhlbHBsdW1iaW5nLmNvbS9pbnN0YWxsJ1xuICApO1xuICB0aHJvdyBuZXcgRXJyb3IoaGVscC5qb2luKCdcXG4nKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/utility.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/utility.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n\n\nconst events = __webpack_require__(/*! node:events */ \"node:events\");\nconst detectLibc = __webpack_require__(/*! detect-libc */ \"(rsc)/./node_modules/.pnpm/detect-libc@2.1.2/node_modules/detect-libc/lib/detect-libc.js\");\n\nconst is = __webpack_require__(/*! ./is */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/is.js\");\nconst { runtimePlatformArch } = __webpack_require__(/*! ./libvips */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/libvips.js\");\nconst sharp = __webpack_require__(/*! ./sharp */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/sharp.js\");\n\nconst runtimePlatform = runtimePlatformArch();\nconst libvipsVersion = sharp.libvipsVersion();\n\n/**\n * An Object containing nested boolean values representing the available input and output formats/methods.\n * @member\n * @example\n * console.log(sharp.format);\n * @returns {Object}\n */\nconst format = sharp.format();\nformat.heif.output.alias = ['avif', 'heic'];\nformat.jpeg.output.alias = ['jpe', 'jpg'];\nformat.tiff.output.alias = ['tif'];\nformat.jp2k.output.alias = ['j2c', 'j2k', 'jp2', 'jpx'];\n\n/**\n * An Object containing the available interpolators and their proper values\n * @readonly\n * @enum {string}\n */\nconst interpolators = {\n  /** [Nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation). Suitable for image enlargement only. */\n  nearest: 'nearest',\n  /** [Bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation). Faster than bicubic but with less smooth results. */\n  bilinear: 'bilinear',\n  /** [Bicubic interpolation](http://en.wikipedia.org/wiki/Bicubic_interpolation) (the default). */\n  bicubic: 'bicubic',\n  /** [LBB interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/lbb.cpp#L100). Prevents some \"[acutance](http://en.wikipedia.org/wiki/Acutance)\" but typically reduces performance by a factor of 2. */\n  locallyBoundedBicubic: 'lbb',\n  /** [Nohalo interpolation](http://eprints.soton.ac.uk/268086/). Prevents acutance but typically reduces performance by a factor of 3. */\n  nohalo: 'nohalo',\n  /** [VSQBS interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/vsqbs.cpp#L48). Prevents \"staircasing\" when enlarging. */\n  vertexSplitQuadraticBasisSpline: 'vsqbs'\n};\n\n/**\n * An Object containing the version numbers of sharp, libvips\n * and (when using prebuilt binaries) its dependencies.\n *\n * @member\n * @example\n * console.log(sharp.versions);\n */\nlet versions = {\n  vips: libvipsVersion.semver\n};\n/* istanbul ignore next */\nif (!libvipsVersion.isGlobal) {\n  if (!libvipsVersion.isWasm) {\n    try {\n      versions = __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img sync recursive ^\\\\.\\\\/sharp\\\\-.*\\\\/versions$\")(`./sharp-${runtimePlatform}/versions`);\n    } catch (_) {\n      try {\n        versions = __webpack_require__(\"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/sharp@0.34.4/node_modules/@img ./node_modules/.pnpm/node_modules/@img ./node_modules/.pnpm/node_modules/@img sync recursive ^\\\\.\\\\/sharp\\\\-libvips\\\\-.*\\\\/versions$\")(`./sharp-libvips-${runtimePlatform}/versions`);\n      } catch (_) {}\n    }\n  } else {\n    try {\n      versions = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '@img/sharp-wasm32/versions'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    } catch (_) {}\n  }\n}\nversions.sharp = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/package.json\").version);\n\n/* istanbul ignore next */\nif (versions.heif && format.heif) {\n  // Prebuilt binaries provide AV1\n  format.heif.input.fileSuffix = ['.avif'];\n  format.heif.output.alias = ['avif'];\n}\n\n/**\n * Gets or, when options are provided, sets the limits of _libvips'_ operation cache.\n * Existing entries in the cache will be trimmed after any change in limits.\n * This method always returns cache statistics,\n * useful for determining how much working memory is required for a particular task.\n *\n * @example\n * const stats = sharp.cache();\n * @example\n * sharp.cache( { items: 200 } );\n * sharp.cache( { files: 0 } );\n * sharp.cache(false);\n *\n * @param {Object|boolean} [options=true] - Object with the following attributes, or boolean where true uses default cache settings and false removes all caching\n * @param {number} [options.memory=50] - is the maximum memory in MB to use for this cache\n * @param {number} [options.files=20] - is the maximum number of files to hold open\n * @param {number} [options.items=100] - is the maximum number of operations to cache\n * @returns {Object}\n */\nfunction cache (options) {\n  if (is.bool(options)) {\n    if (options) {\n      // Default cache settings of 50MB, 20 files, 100 items\n      return sharp.cache(50, 20, 100);\n    } else {\n      return sharp.cache(0, 0, 0);\n    }\n  } else if (is.object(options)) {\n    return sharp.cache(options.memory, options.files, options.items);\n  } else {\n    return sharp.cache();\n  }\n}\ncache(true);\n\n/**\n * Gets or, when a concurrency is provided, sets\n * the maximum number of threads _libvips_ should use to process _each image_.\n * These are from a thread pool managed by glib,\n * which helps avoid the overhead of creating new threads.\n *\n * This method always returns the current concurrency.\n *\n * The default value is the number of CPU cores,\n * except when using glibc-based Linux without jemalloc,\n * where the default is `1` to help reduce memory fragmentation.\n *\n * A value of `0` will reset this to the number of CPU cores.\n *\n * Some image format libraries spawn additional threads,\n * e.g. libaom manages its own 4 threads when encoding AVIF images,\n * and these are independent of the value set here.\n *\n * :::note\n * Further {@link /performance|control over performance} is available.\n * :::\n *\n * @example\n * const threads = sharp.concurrency(); // 4\n * sharp.concurrency(2); // 2\n * sharp.concurrency(0); // 4\n *\n * @param {number} [concurrency]\n * @returns {number} concurrency\n */\nfunction concurrency (concurrency) {\n  return sharp.concurrency(is.integer(concurrency) ? concurrency : null);\n}\n/* istanbul ignore next */\nif (detectLibc.familySync() === detectLibc.GLIBC && !sharp._isUsingJemalloc()) {\n  // Reduce default concurrency to 1 when using glibc memory allocator\n  sharp.concurrency(1);\n} else if (detectLibc.familySync() === detectLibc.MUSL && sharp.concurrency() === 1024) {\n  // Reduce default concurrency when musl thread over-subscription detected\n  sharp.concurrency((__webpack_require__(/*! node:os */ \"node:os\").availableParallelism)());\n}\n\n/**\n * An EventEmitter that emits a `change` event when a task is either:\n * - queued, waiting for _libuv_ to provide a worker thread\n * - complete\n * @member\n * @example\n * sharp.queue.on('change', function(queueLength) {\n *   console.log('Queue contains ' + queueLength + ' task(s)');\n * });\n */\nconst queue = new events.EventEmitter();\n\n/**\n * Provides access to internal task counters.\n * - queue is the number of tasks this module has queued waiting for _libuv_ to provide a worker thread from its pool.\n * - process is the number of resize tasks currently being processed.\n *\n * @example\n * const counters = sharp.counters(); // { queue: 2, process: 4 }\n *\n * @returns {Object}\n */\nfunction counters () {\n  return sharp.counters();\n}\n\n/**\n * Get and set use of SIMD vector unit instructions.\n * Requires libvips to have been compiled with highway support.\n *\n * Improves the performance of `resize`, `blur` and `sharpen` operations\n * by taking advantage of the SIMD vector unit of the CPU, e.g. Intel SSE and ARM NEON.\n *\n * @example\n * const simd = sharp.simd();\n * // simd is `true` if the runtime use of highway is currently enabled\n * @example\n * const simd = sharp.simd(false);\n * // prevent libvips from using highway at runtime\n *\n * @param {boolean} [simd=true]\n * @returns {boolean}\n */\nfunction simd (simd) {\n  return sharp.simd(is.bool(simd) ? simd : null);\n}\n\n/**\n * Block libvips operations at runtime.\n *\n * This is in addition to the `VIPS_BLOCK_UNTRUSTED` environment variable,\n * which when set will block all \"untrusted\" operations.\n *\n * @since 0.32.4\n *\n * @example <caption>Block all TIFF input.</caption>\n * sharp.block({\n *   operation: ['VipsForeignLoadTiff']\n * });\n *\n * @param {Object} options\n * @param {Array<string>} options.operation - List of libvips low-level operation names to block.\n */\nfunction block (options) {\n  if (is.object(options)) {\n    if (Array.isArray(options.operation) && options.operation.every(is.string)) {\n      sharp.block(options.operation, true);\n    } else {\n      throw is.invalidParameterError('operation', 'Array<string>', options.operation);\n    }\n  } else {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n}\n\n/**\n * Unblock libvips operations at runtime.\n *\n * This is useful for defining a list of allowed operations.\n *\n * @since 0.32.4\n *\n * @example <caption>Block all input except WebP from the filesystem.</caption>\n * sharp.block({\n *   operation: ['VipsForeignLoad']\n * });\n * sharp.unblock({\n *   operation: ['VipsForeignLoadWebpFile']\n * });\n *\n * @example <caption>Block all input except JPEG and PNG from a Buffer or Stream.</caption>\n * sharp.block({\n *   operation: ['VipsForeignLoad']\n * });\n * sharp.unblock({\n *   operation: ['VipsForeignLoadJpegBuffer', 'VipsForeignLoadPngBuffer']\n * });\n *\n * @param {Object} options\n * @param {Array<string>} options.operation - List of libvips low-level operation names to unblock.\n */\nfunction unblock (options) {\n  if (is.object(options)) {\n    if (Array.isArray(options.operation) && options.operation.every(is.string)) {\n      sharp.block(options.operation, false);\n    } else {\n      throw is.invalidParameterError('operation', 'Array<string>', options.operation);\n    }\n  } else {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n}\n\n/**\n * Decorate the Sharp class with utility-related functions.\n * @module Sharp\n * @private\n */\nmodule.exports = function (Sharp) {\n  Sharp.cache = cache;\n  Sharp.concurrency = concurrency;\n  Sharp.counters = counters;\n  Sharp.simd = simd;\n  Sharp.format = format;\n  Sharp.interpolators = interpolators;\n  Sharp.versions = versions;\n  Sharp.queue = queue;\n  Sharp.block = block;\n  Sharp.unblock = unblock;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2hhcnBAMC4zNC40L25vZGVfbW9kdWxlcy9zaGFycC9saWIvdXRpbGl0eS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyw2R0FBYTs7QUFFeEMsV0FBVyxtQkFBTyxDQUFDLGtGQUFNO0FBQ3pCLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyw0RkFBVztBQUNuRCxjQUFjLG1CQUFPLENBQUMsd0ZBQVM7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOFVBQVEsU0FBWSxFQUFFLGdCQUFnQixVQUFVLENBQUM7QUFDbEUsTUFBTTtBQUNOO0FBQ0EsbUJBQW1CLHdWQUFRLGlCQUFvQixFQUFFLGdCQUFnQixVQUFVLENBQUM7QUFDNUUsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMseUpBQTRCO0FBQ3JELE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCLCtIQUFrQzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLG9CQUFvQixvRUFBdUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVucm91dGVyLWxhbmdncmFwaC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGFycEAwLjM0LjQvbm9kZV9tb2R1bGVzL3NoYXJwL2xpYi91dGlsaXR5LmpzP2FjMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMgTG92ZWxsIEZ1bGxlciBhbmQgb3RoZXJzLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBldmVudHMgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpO1xuY29uc3QgZGV0ZWN0TGliYyA9IHJlcXVpcmUoJ2RldGVjdC1saWJjJyk7XG5cbmNvbnN0IGlzID0gcmVxdWlyZSgnLi9pcycpO1xuY29uc3QgeyBydW50aW1lUGxhdGZvcm1BcmNoIH0gPSByZXF1aXJlKCcuL2xpYnZpcHMnKTtcbmNvbnN0IHNoYXJwID0gcmVxdWlyZSgnLi9zaGFycCcpO1xuXG5jb25zdCBydW50aW1lUGxhdGZvcm0gPSBydW50aW1lUGxhdGZvcm1BcmNoKCk7XG5jb25zdCBsaWJ2aXBzVmVyc2lvbiA9IHNoYXJwLmxpYnZpcHNWZXJzaW9uKCk7XG5cbi8qKlxuICogQW4gT2JqZWN0IGNvbnRhaW5pbmcgbmVzdGVkIGJvb2xlYW4gdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgZm9ybWF0cy9tZXRob2RzLlxuICogQG1lbWJlclxuICogQGV4YW1wbGVcbiAqIGNvbnNvbGUubG9nKHNoYXJwLmZvcm1hdCk7XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCBmb3JtYXQgPSBzaGFycC5mb3JtYXQoKTtcbmZvcm1hdC5oZWlmLm91dHB1dC5hbGlhcyA9IFsnYXZpZicsICdoZWljJ107XG5mb3JtYXQuanBlZy5vdXRwdXQuYWxpYXMgPSBbJ2pwZScsICdqcGcnXTtcbmZvcm1hdC50aWZmLm91dHB1dC5hbGlhcyA9IFsndGlmJ107XG5mb3JtYXQuanAyay5vdXRwdXQuYWxpYXMgPSBbJ2oyYycsICdqMmsnLCAnanAyJywgJ2pweCddO1xuXG4vKipcbiAqIEFuIE9iamVjdCBjb250YWluaW5nIHRoZSBhdmFpbGFibGUgaW50ZXJwb2xhdG9ycyBhbmQgdGhlaXIgcHJvcGVyIHZhbHVlc1xuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICAvKiogW05lYXJlc3QgbmVpZ2hib3VyIGludGVycG9sYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmVhcmVzdC1uZWlnaGJvcl9pbnRlcnBvbGF0aW9uKS4gU3VpdGFibGUgZm9yIGltYWdlIGVubGFyZ2VtZW50IG9ubHkuICovXG4gIG5lYXJlc3Q6ICduZWFyZXN0JyxcbiAgLyoqIFtCaWxpbmVhciBpbnRlcnBvbGF0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JpbGluZWFyX2ludGVycG9sYXRpb24pLiBGYXN0ZXIgdGhhbiBiaWN1YmljIGJ1dCB3aXRoIGxlc3Mgc21vb3RoIHJlc3VsdHMuICovXG4gIGJpbGluZWFyOiAnYmlsaW5lYXInLFxuICAvKiogW0JpY3ViaWMgaW50ZXJwb2xhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaWN1YmljX2ludGVycG9sYXRpb24pICh0aGUgZGVmYXVsdCkuICovXG4gIGJpY3ViaWM6ICdiaWN1YmljJyxcbiAgLyoqIFtMQkIgaW50ZXJwb2xhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2xpYnZpcHMvbGlidmlwcy9ibG9iL21hc3Rlci9saWJ2aXBzL3Jlc2FtcGxlL2xiYi5jcHAjTDEwMCkuIFByZXZlbnRzIHNvbWUgXCJbYWN1dGFuY2VdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWN1dGFuY2UpXCIgYnV0IHR5cGljYWxseSByZWR1Y2VzIHBlcmZvcm1hbmNlIGJ5IGEgZmFjdG9yIG9mIDIuICovXG4gIGxvY2FsbHlCb3VuZGVkQmljdWJpYzogJ2xiYicsXG4gIC8qKiBbTm9oYWxvIGludGVycG9sYXRpb25dKGh0dHA6Ly9lcHJpbnRzLnNvdG9uLmFjLnVrLzI2ODA4Ni8pLiBQcmV2ZW50cyBhY3V0YW5jZSBidXQgdHlwaWNhbGx5IHJlZHVjZXMgcGVyZm9ybWFuY2UgYnkgYSBmYWN0b3Igb2YgMy4gKi9cbiAgbm9oYWxvOiAnbm9oYWxvJyxcbiAgLyoqIFtWU1FCUyBpbnRlcnBvbGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbGlidmlwcy9saWJ2aXBzL2Jsb2IvbWFzdGVyL2xpYnZpcHMvcmVzYW1wbGUvdnNxYnMuY3BwI0w0OCkuIFByZXZlbnRzIFwic3RhaXJjYXNpbmdcIiB3aGVuIGVubGFyZ2luZy4gKi9cbiAgdmVydGV4U3BsaXRRdWFkcmF0aWNCYXNpc1NwbGluZTogJ3ZzcWJzJ1xufTtcblxuLyoqXG4gKiBBbiBPYmplY3QgY29udGFpbmluZyB0aGUgdmVyc2lvbiBudW1iZXJzIG9mIHNoYXJwLCBsaWJ2aXBzXG4gKiBhbmQgKHdoZW4gdXNpbmcgcHJlYnVpbHQgYmluYXJpZXMpIGl0cyBkZXBlbmRlbmNpZXMuXG4gKlxuICogQG1lbWJlclxuICogQGV4YW1wbGVcbiAqIGNvbnNvbGUubG9nKHNoYXJwLnZlcnNpb25zKTtcbiAqL1xubGV0IHZlcnNpb25zID0ge1xuICB2aXBzOiBsaWJ2aXBzVmVyc2lvbi5zZW12ZXJcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKCFsaWJ2aXBzVmVyc2lvbi5pc0dsb2JhbCkge1xuICBpZiAoIWxpYnZpcHNWZXJzaW9uLmlzV2FzbSkge1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9ucyA9IHJlcXVpcmUoYEBpbWcvc2hhcnAtJHtydW50aW1lUGxhdGZvcm19L3ZlcnNpb25zYCk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbnMgPSByZXF1aXJlKGBAaW1nL3NoYXJwLWxpYnZpcHMtJHtydW50aW1lUGxhdGZvcm19L3ZlcnNpb25zYCk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbnMgPSByZXF1aXJlKCdAaW1nL3NoYXJwLXdhc20zMi92ZXJzaW9ucycpO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH1cbn1cbnZlcnNpb25zLnNoYXJwID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICh2ZXJzaW9ucy5oZWlmICYmIGZvcm1hdC5oZWlmKSB7XG4gIC8vIFByZWJ1aWx0IGJpbmFyaWVzIHByb3ZpZGUgQVYxXG4gIGZvcm1hdC5oZWlmLmlucHV0LmZpbGVTdWZmaXggPSBbJy5hdmlmJ107XG4gIGZvcm1hdC5oZWlmLm91dHB1dC5hbGlhcyA9IFsnYXZpZiddO1xufVxuXG4vKipcbiAqIEdldHMgb3IsIHdoZW4gb3B0aW9ucyBhcmUgcHJvdmlkZWQsIHNldHMgdGhlIGxpbWl0cyBvZiBfbGlidmlwcydfIG9wZXJhdGlvbiBjYWNoZS5cbiAqIEV4aXN0aW5nIGVudHJpZXMgaW4gdGhlIGNhY2hlIHdpbGwgYmUgdHJpbW1lZCBhZnRlciBhbnkgY2hhbmdlIGluIGxpbWl0cy5cbiAqIFRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGNhY2hlIHN0YXRpc3RpY3MsXG4gKiB1c2VmdWwgZm9yIGRldGVybWluaW5nIGhvdyBtdWNoIHdvcmtpbmcgbWVtb3J5IGlzIHJlcXVpcmVkIGZvciBhIHBhcnRpY3VsYXIgdGFzay5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc3RhdHMgPSBzaGFycC5jYWNoZSgpO1xuICogQGV4YW1wbGVcbiAqIHNoYXJwLmNhY2hlKCB7IGl0ZW1zOiAyMDAgfSApO1xuICogc2hhcnAuY2FjaGUoIHsgZmlsZXM6IDAgfSApO1xuICogc2hhcnAuY2FjaGUoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRpb25zPXRydWVdIC0gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzLCBvciBib29sZWFuIHdoZXJlIHRydWUgdXNlcyBkZWZhdWx0IGNhY2hlIHNldHRpbmdzIGFuZCBmYWxzZSByZW1vdmVzIGFsbCBjYWNoaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWVtb3J5PTUwXSAtIGlzIHRoZSBtYXhpbXVtIG1lbW9yeSBpbiBNQiB0byB1c2UgZm9yIHRoaXMgY2FjaGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5maWxlcz0yMF0gLSBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZmlsZXMgdG8gaG9sZCBvcGVuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaXRlbXM9MTAwXSAtIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBvcGVyYXRpb25zIHRvIGNhY2hlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjYWNoZSAob3B0aW9ucykge1xuICBpZiAoaXMuYm9vbChvcHRpb25zKSkge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBEZWZhdWx0IGNhY2hlIHNldHRpbmdzIG9mIDUwTUIsIDIwIGZpbGVzLCAxMDAgaXRlbXNcbiAgICAgIHJldHVybiBzaGFycC5jYWNoZSg1MCwgMjAsIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaGFycC5jYWNoZSgwLCAwLCAwKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXMub2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHNoYXJwLmNhY2hlKG9wdGlvbnMubWVtb3J5LCBvcHRpb25zLmZpbGVzLCBvcHRpb25zLml0ZW1zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2hhcnAuY2FjaGUoKTtcbiAgfVxufVxuY2FjaGUodHJ1ZSk7XG5cbi8qKlxuICogR2V0cyBvciwgd2hlbiBhIGNvbmN1cnJlbmN5IGlzIHByb3ZpZGVkLCBzZXRzXG4gKiB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGhyZWFkcyBfbGlidmlwc18gc2hvdWxkIHVzZSB0byBwcm9jZXNzIF9lYWNoIGltYWdlXy5cbiAqIFRoZXNlIGFyZSBmcm9tIGEgdGhyZWFkIHBvb2wgbWFuYWdlZCBieSBnbGliLFxuICogd2hpY2ggaGVscHMgYXZvaWQgdGhlIG92ZXJoZWFkIG9mIGNyZWF0aW5nIG5ldyB0aHJlYWRzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm5zIHRoZSBjdXJyZW50IGNvbmN1cnJlbmN5LlxuICpcbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBudW1iZXIgb2YgQ1BVIGNvcmVzLFxuICogZXhjZXB0IHdoZW4gdXNpbmcgZ2xpYmMtYmFzZWQgTGludXggd2l0aG91dCBqZW1hbGxvYyxcbiAqIHdoZXJlIHRoZSBkZWZhdWx0IGlzIGAxYCB0byBoZWxwIHJlZHVjZSBtZW1vcnkgZnJhZ21lbnRhdGlvbi5cbiAqXG4gKiBBIHZhbHVlIG9mIGAwYCB3aWxsIHJlc2V0IHRoaXMgdG8gdGhlIG51bWJlciBvZiBDUFUgY29yZXMuXG4gKlxuICogU29tZSBpbWFnZSBmb3JtYXQgbGlicmFyaWVzIHNwYXduIGFkZGl0aW9uYWwgdGhyZWFkcyxcbiAqIGUuZy4gbGliYW9tIG1hbmFnZXMgaXRzIG93biA0IHRocmVhZHMgd2hlbiBlbmNvZGluZyBBVklGIGltYWdlcyxcbiAqIGFuZCB0aGVzZSBhcmUgaW5kZXBlbmRlbnQgb2YgdGhlIHZhbHVlIHNldCBoZXJlLlxuICpcbiAqIDo6Om5vdGVcbiAqIEZ1cnRoZXIge0BsaW5rIC9wZXJmb3JtYW5jZXxjb250cm9sIG92ZXIgcGVyZm9ybWFuY2V9IGlzIGF2YWlsYWJsZS5cbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0aHJlYWRzID0gc2hhcnAuY29uY3VycmVuY3koKTsgLy8gNFxuICogc2hhcnAuY29uY3VycmVuY3koMik7IC8vIDJcbiAqIHNoYXJwLmNvbmN1cnJlbmN5KDApOyAvLyA0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeV1cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbmN1cnJlbmN5XG4gKi9cbmZ1bmN0aW9uIGNvbmN1cnJlbmN5IChjb25jdXJyZW5jeSkge1xuICByZXR1cm4gc2hhcnAuY29uY3VycmVuY3koaXMuaW50ZWdlcihjb25jdXJyZW5jeSkgPyBjb25jdXJyZW5jeSA6IG51bGwpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChkZXRlY3RMaWJjLmZhbWlseVN5bmMoKSA9PT0gZGV0ZWN0TGliYy5HTElCQyAmJiAhc2hhcnAuX2lzVXNpbmdKZW1hbGxvYygpKSB7XG4gIC8vIFJlZHVjZSBkZWZhdWx0IGNvbmN1cnJlbmN5IHRvIDEgd2hlbiB1c2luZyBnbGliYyBtZW1vcnkgYWxsb2NhdG9yXG4gIHNoYXJwLmNvbmN1cnJlbmN5KDEpO1xufSBlbHNlIGlmIChkZXRlY3RMaWJjLmZhbWlseVN5bmMoKSA9PT0gZGV0ZWN0TGliYy5NVVNMICYmIHNoYXJwLmNvbmN1cnJlbmN5KCkgPT09IDEwMjQpIHtcbiAgLy8gUmVkdWNlIGRlZmF1bHQgY29uY3VycmVuY3kgd2hlbiBtdXNsIHRocmVhZCBvdmVyLXN1YnNjcmlwdGlvbiBkZXRlY3RlZFxuICBzaGFycC5jb25jdXJyZW5jeShyZXF1aXJlKCdub2RlOm9zJykuYXZhaWxhYmxlUGFyYWxsZWxpc20oKSk7XG59XG5cbi8qKlxuICogQW4gRXZlbnRFbWl0dGVyIHRoYXQgZW1pdHMgYSBgY2hhbmdlYCBldmVudCB3aGVuIGEgdGFzayBpcyBlaXRoZXI6XG4gKiAtIHF1ZXVlZCwgd2FpdGluZyBmb3IgX2xpYnV2XyB0byBwcm92aWRlIGEgd29ya2VyIHRocmVhZFxuICogLSBjb21wbGV0ZVxuICogQG1lbWJlclxuICogQGV4YW1wbGVcbiAqIHNoYXJwLnF1ZXVlLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihxdWV1ZUxlbmd0aCkge1xuICogICBjb25zb2xlLmxvZygnUXVldWUgY29udGFpbnMgJyArIHF1ZXVlTGVuZ3RoICsgJyB0YXNrKHMpJyk7XG4gKiB9KTtcbiAqL1xuY29uc3QgcXVldWUgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBpbnRlcm5hbCB0YXNrIGNvdW50ZXJzLlxuICogLSBxdWV1ZSBpcyB0aGUgbnVtYmVyIG9mIHRhc2tzIHRoaXMgbW9kdWxlIGhhcyBxdWV1ZWQgd2FpdGluZyBmb3IgX2xpYnV2XyB0byBwcm92aWRlIGEgd29ya2VyIHRocmVhZCBmcm9tIGl0cyBwb29sLlxuICogLSBwcm9jZXNzIGlzIHRoZSBudW1iZXIgb2YgcmVzaXplIHRhc2tzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNvdW50ZXJzID0gc2hhcnAuY291bnRlcnMoKTsgLy8geyBxdWV1ZTogMiwgcHJvY2VzczogNCB9XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY291bnRlcnMgKCkge1xuICByZXR1cm4gc2hhcnAuY291bnRlcnMoKTtcbn1cblxuLyoqXG4gKiBHZXQgYW5kIHNldCB1c2Ugb2YgU0lNRCB2ZWN0b3IgdW5pdCBpbnN0cnVjdGlvbnMuXG4gKiBSZXF1aXJlcyBsaWJ2aXBzIHRvIGhhdmUgYmVlbiBjb21waWxlZCB3aXRoIGhpZ2h3YXkgc3VwcG9ydC5cbiAqXG4gKiBJbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2Ugb2YgYHJlc2l6ZWAsIGBibHVyYCBhbmQgYHNoYXJwZW5gIG9wZXJhdGlvbnNcbiAqIGJ5IHRha2luZyBhZHZhbnRhZ2Ugb2YgdGhlIFNJTUQgdmVjdG9yIHVuaXQgb2YgdGhlIENQVSwgZS5nLiBJbnRlbCBTU0UgYW5kIEFSTSBORU9OLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzaW1kID0gc2hhcnAuc2ltZCgpO1xuICogLy8gc2ltZCBpcyBgdHJ1ZWAgaWYgdGhlIHJ1bnRpbWUgdXNlIG9mIGhpZ2h3YXkgaXMgY3VycmVudGx5IGVuYWJsZWRcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzaW1kID0gc2hhcnAuc2ltZChmYWxzZSk7XG4gKiAvLyBwcmV2ZW50IGxpYnZpcHMgZnJvbSB1c2luZyBoaWdod2F5IGF0IHJ1bnRpbWVcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaW1kPXRydWVdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2ltZCAoc2ltZCkge1xuICByZXR1cm4gc2hhcnAuc2ltZChpcy5ib29sKHNpbWQpID8gc2ltZCA6IG51bGwpO1xufVxuXG4vKipcbiAqIEJsb2NrIGxpYnZpcHMgb3BlcmF0aW9ucyBhdCBydW50aW1lLlxuICpcbiAqIFRoaXMgaXMgaW4gYWRkaXRpb24gdG8gdGhlIGBWSVBTX0JMT0NLX1VOVFJVU1RFRGAgZW52aXJvbm1lbnQgdmFyaWFibGUsXG4gKiB3aGljaCB3aGVuIHNldCB3aWxsIGJsb2NrIGFsbCBcInVudHJ1c3RlZFwiIG9wZXJhdGlvbnMuXG4gKlxuICogQHNpbmNlIDAuMzIuNFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkJsb2NrIGFsbCBUSUZGIGlucHV0LjwvY2FwdGlvbj5cbiAqIHNoYXJwLmJsb2NrKHtcbiAqICAgb3BlcmF0aW9uOiBbJ1ZpcHNGb3JlaWduTG9hZFRpZmYnXVxuICogfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gb3B0aW9ucy5vcGVyYXRpb24gLSBMaXN0IG9mIGxpYnZpcHMgbG93LWxldmVsIG9wZXJhdGlvbiBuYW1lcyB0byBibG9jay5cbiAqL1xuZnVuY3Rpb24gYmxvY2sgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3BlcmF0aW9uKSAmJiBvcHRpb25zLm9wZXJhdGlvbi5ldmVyeShpcy5zdHJpbmcpKSB7XG4gICAgICBzaGFycC5ibG9jayhvcHRpb25zLm9wZXJhdGlvbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3BlcmF0aW9uJywgJ0FycmF5PHN0cmluZz4nLCBvcHRpb25zLm9wZXJhdGlvbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IGlzLmludmFsaWRQYXJhbWV0ZXJFcnJvcignb3B0aW9ucycsICdvYmplY3QnLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFVuYmxvY2sgbGlidmlwcyBvcGVyYXRpb25zIGF0IHJ1bnRpbWUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGRlZmluaW5nIGEgbGlzdCBvZiBhbGxvd2VkIG9wZXJhdGlvbnMuXG4gKlxuICogQHNpbmNlIDAuMzIuNFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkJsb2NrIGFsbCBpbnB1dCBleGNlcHQgV2ViUCBmcm9tIHRoZSBmaWxlc3lzdGVtLjwvY2FwdGlvbj5cbiAqIHNoYXJwLmJsb2NrKHtcbiAqICAgb3BlcmF0aW9uOiBbJ1ZpcHNGb3JlaWduTG9hZCddXG4gKiB9KTtcbiAqIHNoYXJwLnVuYmxvY2soe1xuICogICBvcGVyYXRpb246IFsnVmlwc0ZvcmVpZ25Mb2FkV2VicEZpbGUnXVxuICogfSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QmxvY2sgYWxsIGlucHV0IGV4Y2VwdCBKUEVHIGFuZCBQTkcgZnJvbSBhIEJ1ZmZlciBvciBTdHJlYW0uPC9jYXB0aW9uPlxuICogc2hhcnAuYmxvY2soe1xuICogICBvcGVyYXRpb246IFsnVmlwc0ZvcmVpZ25Mb2FkJ11cbiAqIH0pO1xuICogc2hhcnAudW5ibG9jayh7XG4gKiAgIG9wZXJhdGlvbjogWydWaXBzRm9yZWlnbkxvYWRKcGVnQnVmZmVyJywgJ1ZpcHNGb3JlaWduTG9hZFBuZ0J1ZmZlciddXG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBvcHRpb25zLm9wZXJhdGlvbiAtIExpc3Qgb2YgbGlidmlwcyBsb3ctbGV2ZWwgb3BlcmF0aW9uIG5hbWVzIHRvIHVuYmxvY2suXG4gKi9cbmZ1bmN0aW9uIHVuYmxvY2sgKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3BlcmF0aW9uKSAmJiBvcHRpb25zLm9wZXJhdGlvbi5ldmVyeShpcy5zdHJpbmcpKSB7XG4gICAgICBzaGFycC5ibG9jayhvcHRpb25zLm9wZXJhdGlvbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wZXJhdGlvbicsICdBcnJheTxzdHJpbmc+Jywgb3B0aW9ucy5vcGVyYXRpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBpcy5pbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ29wdGlvbnMnLCAnb2JqZWN0Jywgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvcmF0ZSB0aGUgU2hhcnAgY2xhc3Mgd2l0aCB1dGlsaXR5LXJlbGF0ZWQgZnVuY3Rpb25zLlxuICogQG1vZHVsZSBTaGFycFxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU2hhcnApIHtcbiAgU2hhcnAuY2FjaGUgPSBjYWNoZTtcbiAgU2hhcnAuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeTtcbiAgU2hhcnAuY291bnRlcnMgPSBjb3VudGVycztcbiAgU2hhcnAuc2ltZCA9IHNpbWQ7XG4gIFNoYXJwLmZvcm1hdCA9IGZvcm1hdDtcbiAgU2hhcnAuaW50ZXJwb2xhdG9ycyA9IGludGVycG9sYXRvcnM7XG4gIFNoYXJwLnZlcnNpb25zID0gdmVyc2lvbnM7XG4gIFNoYXJwLnF1ZXVlID0gcXVldWU7XG4gIFNoYXJwLmJsb2NrID0gYmxvY2s7XG4gIFNoYXJwLnVuYmxvY2sgPSB1bmJsb2NrO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/lib/utility.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/package.json":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/sharp@0.34.4/node_modules/sharp/package.json ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"sharp","description":"High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images","version":"0.34.4","author":"Lovell Fuller <npm@lovell.info>","homepage":"https://sharp.pixelplumbing.com","contributors":["Pierre Inglebert <pierre.inglebert@gmail.com>","Jonathan Ong <jonathanrichardong@gmail.com>","Chanon Sajjamanochai <chanon.s@gmail.com>","Juliano Julio <julianojulio@gmail.com>","Daniel Gasienica <daniel@gasienica.ch>","Julian Walker <julian@fiftythree.com>","Amit Pitaru <pitaru.amit@gmail.com>","Brandon Aaron <hello.brandon@aaron.sh>","Andreas Lind <andreas@one.com>","Maurus Cuelenaere <mcuelenaere@gmail.com>","Linus Unnebäck <linus@folkdatorn.se>","Victor Mateevitsi <mvictoras@gmail.com>","Alaric Holloway <alaric.holloway@gmail.com>","Bernhard K. Weisshuhn <bkw@codingforce.com>","Chris Riley <criley@primedia.com>","David Carley <dacarley@gmail.com>","John Tobin <john@limelightmobileinc.com>","Kenton Gray <kentongray@gmail.com>","Felix Bünemann <Felix.Buenemann@gmail.com>","Samy Al Zahrani <samyalzahrany@gmail.com>","Chintan Thakkar <lemnisk8@gmail.com>","F. Orlando Galashan <frulo@gmx.de>","Kleis Auke Wolthuizen <info@kleisauke.nl>","Matt Hirsch <mhirsch@media.mit.edu>","Matthias Thoemmes <thoemmes@gmail.com>","Patrick Paskaris <patrick@paskaris.gr>","Jérémy Lal <kapouer@melix.org>","Rahul Nanwani <r.nanwani@gmail.com>","Alice Monday <alice0meta@gmail.com>","Kristo Jorgenson <kristo.jorgenson@gmail.com>","YvesBos <yves_bos@outlook.com>","Guy Maliar <guy@tailorbrands.com>","Nicolas Coden <nicolas@ncoden.fr>","Matt Parrish <matt.r.parrish@gmail.com>","Marcel Bretschneider <marcel.bretschneider@gmail.com>","Matthew McEachen <matthew+github@mceachen.org>","Jarda Kotěšovec <jarda.kotesovec@gmail.com>","Kenric D\'Souza <kenric.dsouza@gmail.com>","Oleh Aleinyk <oleg.aleynik@gmail.com>","Marcel Bretschneider <marcel.bretschneider@gmail.com>","Andrea Bianco <andrea.bianco@unibas.ch>","Rik Heywood <rik@rik.org>","Thomas Parisot <hi@oncletom.io>","Nathan Graves <nathanrgraves+github@gmail.com>","Tom Lokhorst <tom@lokhorst.eu>","Espen Hovlandsdal <espen@hovlandsdal.com>","Sylvain Dumont <sylvain.dumont35@gmail.com>","Alun Davies <alun.owain.davies@googlemail.com>","Aidan Hoolachan <ajhoolachan21@gmail.com>","Axel Eirola <axel.eirola@iki.fi>","Freezy <freezy@xbmc.org>","Daiz <taneli.vatanen@gmail.com>","Julian Aubourg <j@ubourg.net>","Keith Belovay <keith@picthrive.com>","Michael B. Klein <mbklein@gmail.com>","Jordan Prudhomme <jordan@raboland.fr>","Ilya Ovdin <iovdin@gmail.com>","Andargor <andargor@yahoo.com>","Paul Neave <paul.neave@gmail.com>","Brendan Kennedy <brenwken@gmail.com>","Brychan Bennett-Odlum <git@brychan.io>","Edward Silverton <e.silverton@gmail.com>","Roman Malieiev <aromaleev@gmail.com>","Tomas Szabo <tomas.szabo@deftomat.com>","Robert O\'Rourke <robert@o-rourke.org>","Guillermo Alfonso Varela Chouciño <guillevch@gmail.com>","Christian Flintrup <chr@gigahost.dk>","Manan Jadhav <manan@motionden.com>","Leon Radley <leon@radley.se>","alza54 <alza54@thiocod.in>","Jacob Smith <jacob@frende.me>","Michael Nutt <michael@nutt.im>","Brad Parham <baparham@gmail.com>","Taneli Vatanen <taneli.vatanen@gmail.com>","Joris Dugué <zaruike10@gmail.com>","Chris Banks <christopher.bradley.banks@gmail.com>","Ompal Singh <ompal.hitm09@gmail.com>","Brodan <christopher.hranj@gmail.com>","Ankur Parihar <ankur.github@gmail.com>","Brahim Ait elhaj <brahima@gmail.com>","Mart Jansink <m.jansink@gmail.com>","Lachlan Newman <lachnewman007@gmail.com>","Dennis Beatty <dennis@dcbeatty.com>","Ingvar Stepanyan <me@rreverser.com>","Don Denton <don@happycollision.com>"],"scripts":{"install":"node install/check.js","clean":"rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*","test":"npm run test-lint && npm run test-unit && npm run test-licensing && npm run test-types","test-lint":"semistandard && cpplint","test-unit":"nyc --reporter=lcov --reporter=text --check-coverage --branches=100 mocha","test-licensing":"license-checker --production --summary --onlyAllow=\\"Apache-2.0;BSD;ISC;LGPL-3.0-or-later;MIT\\"","test-leak":"./test/leak/leak.sh","test-types":"tsd","package-from-local-build":"node npm/from-local-build.js","package-release-notes":"node npm/release-notes.js","docs-build":"node docs/build.mjs","docs-serve":"cd docs && npm start","docs-publish":"cd docs && npm run build && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp"},"type":"commonjs","main":"lib/index.js","types":"lib/index.d.ts","files":["install","lib","src/*.{cc,h,gyp}"],"repository":{"type":"git","url":"git://github.com/lovell/sharp.git"},"keywords":["jpeg","png","webp","avif","tiff","gif","svg","jp2","dzi","image","resize","thumbnail","crop","embed","libvips","vips"],"dependencies":{"@img/colour":"^1.0.0","detect-libc":"^2.1.0","semver":"^7.7.2"},"optionalDependencies":{"@img/sharp-darwin-arm64":"0.34.4","@img/sharp-darwin-x64":"0.34.4","@img/sharp-libvips-darwin-arm64":"1.2.3","@img/sharp-libvips-darwin-x64":"1.2.3","@img/sharp-libvips-linux-arm":"1.2.3","@img/sharp-libvips-linux-arm64":"1.2.3","@img/sharp-libvips-linux-ppc64":"1.2.3","@img/sharp-libvips-linux-s390x":"1.2.3","@img/sharp-libvips-linux-x64":"1.2.3","@img/sharp-libvips-linuxmusl-arm64":"1.2.3","@img/sharp-libvips-linuxmusl-x64":"1.2.3","@img/sharp-linux-arm":"0.34.4","@img/sharp-linux-arm64":"0.34.4","@img/sharp-linux-ppc64":"0.34.4","@img/sharp-linux-s390x":"0.34.4","@img/sharp-linux-x64":"0.34.4","@img/sharp-linuxmusl-arm64":"0.34.4","@img/sharp-linuxmusl-x64":"0.34.4","@img/sharp-wasm32":"0.34.4","@img/sharp-win32-arm64":"0.34.4","@img/sharp-win32-ia32":"0.34.4","@img/sharp-win32-x64":"0.34.4"},"devDependencies":{"@emnapi/runtime":"^1.5.0","@img/sharp-libvips-dev":"1.2.3","@img/sharp-libvips-dev-wasm32":"1.2.3","@img/sharp-libvips-win32-arm64":"1.2.3","@img/sharp-libvips-win32-ia32":"1.2.3","@img/sharp-libvips-win32-x64":"1.2.3","@types/node":"*","cc":"^3.0.1","emnapi":"^1.5.0","exif-reader":"^2.0.2","extract-zip":"^2.0.1","icc":"^3.0.0","jsdoc-to-markdown":"^9.1.2","license-checker":"^25.0.1","mocha":"^11.7.2","node-addon-api":"^8.5.0","node-gyp":"^11.4.2","nyc":"^17.1.0","semistandard":"^17.0.0","tar-fs":"^3.1.1","tsd":"^0.33.0"},"license":"Apache-2.0","engines":{"node":"^18.17.0 || ^20.3.0 || >=21.0.0"},"config":{"libvips":">=8.17.2"},"funding":{"url":"https://opencollective.com/libvips"},"semistandard":{"env":["mocha"]},"cc":{"linelength":"120","filter":["build/include"]},"nyc":{"include":["lib"]},"tsd":{"directory":"test/types/"}}');

/***/ })

};
;