"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chromadb@3.0.17";
exports.ids = ["vendor-chunks/chromadb@3.0.17"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chromadb.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chromadb.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdminClient: () => (/* binding */ AdminClient),\n/* harmony export */   AdminCloudClient: () => (/* binding */ AdminCloudClient),\n/* harmony export */   ChromaClient: () => (/* binding */ ChromaClient),\n/* harmony export */   ChromaClientError: () => (/* binding */ ChromaClientError),\n/* harmony export */   ChromaConnectionError: () => (/* binding */ ChromaConnectionError),\n/* harmony export */   ChromaError: () => (/* binding */ ChromaError),\n/* harmony export */   ChromaForbiddenError: () => (/* binding */ ChromaForbiddenError),\n/* harmony export */   ChromaNotFoundError: () => (/* binding */ ChromaNotFoundError),\n/* harmony export */   ChromaQuotaExceededError: () => (/* binding */ ChromaQuotaExceededError),\n/* harmony export */   ChromaRateLimitError: () => (/* binding */ ChromaRateLimitError),\n/* harmony export */   ChromaServerError: () => (/* binding */ ChromaServerError),\n/* harmony export */   ChromaUnauthorizedError: () => (/* binding */ ChromaUnauthorizedError),\n/* harmony export */   ChromaUniqueError: () => (/* binding */ ChromaUniqueError),\n/* harmony export */   ChromaValueError: () => (/* binding */ ChromaValueError),\n/* harmony export */   CloudClient: () => (/* binding */ CloudClient),\n/* harmony export */   GetResult: () => (/* binding */ GetResult),\n/* harmony export */   IncludeEnum: () => (/* binding */ IncludeEnum),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidCollectionError: () => (/* binding */ InvalidCollectionError),\n/* harmony export */   QueryResult: () => (/* binding */ QueryResult),\n/* harmony export */   baseRecordSetFields: () => (/* binding */ baseRecordSetFields),\n/* harmony export */   createErrorByType: () => (/* binding */ createErrorByType),\n/* harmony export */   getDefaultEFConfig: () => (/* binding */ getDefaultEFConfig),\n/* harmony export */   getEmbeddingFunction: () => (/* binding */ getEmbeddingFunction),\n/* harmony export */   knownEmbeddingFunctions: () => (/* binding */ knownEmbeddingFunctions),\n/* harmony export */   processCreateCollectionConfig: () => (/* binding */ processCreateCollectionConfig),\n/* harmony export */   processUpdateCollectionConfig: () => (/* binding */ processUpdateCollectionConfig),\n/* harmony export */   recordSetFields: () => (/* binding */ recordSetFields),\n/* harmony export */   registerEmbeddingFunction: () => (/* binding */ registerEmbeddingFunction),\n/* harmony export */   serializeEmbeddingFunction: () => (/* binding */ serializeEmbeddingFunction),\n/* harmony export */   withChroma: () => (/* binding */ withChroma)\n/* harmony export */ });\n/* harmony import */ var _chunk_NSSMTXJJ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-NSSMTXJJ.mjs */ \"(rsc)/./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:process */ \"node:process\");\n\n\n// src/deno.ts\nif (typeof globalThis.Deno !== \"undefined\") {\n  const OriginalRequest = globalThis.Request;\n  const PatchedRequest = function(input, init) {\n    if (init && typeof init === \"object\") {\n      const cleanInit = { ...init };\n      if (\"client\" in cleanInit) {\n        delete cleanInit.client;\n      }\n      return new OriginalRequest(input, cleanInit);\n    }\n    return new OriginalRequest(input, init);\n  };\n  Object.setPrototypeOf(PatchedRequest, OriginalRequest);\n  Object.defineProperty(PatchedRequest, \"prototype\", {\n    value: OriginalRequest.prototype,\n    writable: false\n  });\n  globalThis.Request = PatchedRequest;\n}\n\n// src/types.ts\nvar baseRecordSetFields = [\n  \"ids\",\n  \"embeddings\",\n  \"metadatas\",\n  \"documents\",\n  \"uris\"\n];\nvar recordSetFields = [...baseRecordSetFields, \"ids\"];\nvar IncludeEnum = /* @__PURE__ */ ((IncludeEnum2) => {\n  IncludeEnum2[\"distances\"] = \"distances\";\n  IncludeEnum2[\"documents\"] = \"documents\";\n  IncludeEnum2[\"embeddings\"] = \"embeddings\";\n  IncludeEnum2[\"metadatas\"] = \"metadatas\";\n  IncludeEnum2[\"uris\"] = \"uris\";\n  return IncludeEnum2;\n})(IncludeEnum || {});\nvar GetResult = class {\n  /**\n   * Creates a new GetResult instance.\n   * @param data - The result data containing all fields\n   */\n  constructor({\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris\n  }) {\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n  /**\n   * Converts the result to a row-based format for easier iteration.\n   * @returns Object containing include fields and array of record objects\n   */\n  rows() {\n    return this.ids.map((id, index) => {\n      return {\n        id,\n        document: this.include.includes(\"documents\") ? this.documents[index] : void 0,\n        embedding: this.include.includes(\"embeddings\") ? this.embeddings[index] : void 0,\n        metadata: this.include.includes(\"metadatas\") ? this.metadatas[index] : void 0,\n        uri: this.include.includes(\"uris\") ? this.uris[index] : void 0\n      };\n    });\n  }\n};\nvar QueryResult = class {\n  /**\n   * Creates a new QueryResult instance.\n   * @param data - The query result data containing all fields\n   */\n  constructor({\n    distances,\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris\n  }) {\n    this.distances = distances;\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n  /**\n   * Converts the query result to a row-based format for easier iteration.\n   * @returns Object containing include fields and structured query results\n   */\n  rows() {\n    const queries = [];\n    for (let q2 = 0; q2 < this.ids.length; q2++) {\n      const records = this.ids[q2].map((id, index) => {\n        return {\n          id,\n          document: this.include.includes(\"documents\") ? this.documents[q2][index] : void 0,\n          embedding: this.include.includes(\"embeddings\") ? this.embeddings[q2][index] : void 0,\n          metadata: this.include.includes(\"metadatas\") ? this.metadatas[q2][index] : void 0,\n          uri: this.include.includes(\"uris\") ? this.uris[q2][index] : void 0,\n          distance: this.include.includes(\"distances\") ? this.distances[q2][index] : void 0\n        };\n      });\n      queries.push(records);\n    }\n    return queries;\n  }\n};\n\n// ../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-fetch/dist/index.js\nvar A = async (t, r) => {\n  let e = typeof r == \"function\" ? await r(t) : r;\n  if (e) return t.scheme === \"bearer\" ? `Bearer ${e}` : t.scheme === \"basic\" ? `Basic ${btoa(e)}` : e;\n};\nvar R = { bodySerializer: (t) => JSON.stringify(t, (r, e) => typeof e == \"bigint\" ? e.toString() : e) };\nvar U = (t) => {\n  switch (t) {\n    case \"label\":\n      return \".\";\n    case \"matrix\":\n      return \";\";\n    case \"simple\":\n      return \",\";\n    default:\n      return \"&\";\n  }\n};\nvar _ = (t) => {\n  switch (t) {\n    case \"form\":\n      return \",\";\n    case \"pipeDelimited\":\n      return \"|\";\n    case \"spaceDelimited\":\n      return \"%20\";\n    default:\n      return \",\";\n  }\n};\nvar D = (t) => {\n  switch (t) {\n    case \"label\":\n      return \".\";\n    case \"matrix\":\n      return \";\";\n    case \"simple\":\n      return \",\";\n    default:\n      return \"&\";\n  }\n};\nvar O = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {\n  if (!r) {\n    let s = (t ? i : i.map((l) => encodeURIComponent(l))).join(_(a));\n    switch (a) {\n      case \"label\":\n        return `.${s}`;\n      case \"matrix\":\n        return `;${e}=${s}`;\n      case \"simple\":\n        return s;\n      default:\n        return `${e}=${s}`;\n    }\n  }\n  let o = U(a), n = i.map((s) => a === \"label\" || a === \"simple\" ? t ? s : encodeURIComponent(s) : y({ allowReserved: t, name: e, value: s })).join(o);\n  return a === \"label\" || a === \"matrix\" ? o + n : n;\n};\nvar y = ({ allowReserved: t, name: r, value: e }) => {\n  if (e == null) return \"\";\n  if (typeof e == \"object\") throw new Error(\"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\");\n  return `${r}=${t ? e : encodeURIComponent(e)}`;\n};\nvar q = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {\n  if (i instanceof Date) return `${e}=${i.toISOString()}`;\n  if (a !== \"deepObject\" && !r) {\n    let s = [];\n    Object.entries(i).forEach(([f, u]) => {\n      s = [...s, f, t ? u : encodeURIComponent(u)];\n    });\n    let l = s.join(\",\");\n    switch (a) {\n      case \"form\":\n        return `${e}=${l}`;\n      case \"label\":\n        return `.${l}`;\n      case \"matrix\":\n        return `;${e}=${l}`;\n      default:\n        return l;\n    }\n  }\n  let o = D(a), n = Object.entries(i).map(([s, l]) => y({ allowReserved: t, name: a === \"deepObject\" ? `${e}[${s}]` : s, value: l })).join(o);\n  return a === \"label\" || a === \"matrix\" ? o + n : n;\n};\nvar H = /\\{[^{}]+\\}/g;\nvar B = ({ path: t, url: r }) => {\n  let e = r, a = r.match(H);\n  if (a) for (let i of a) {\n    let o = false, n = i.substring(1, i.length - 1), s = \"simple\";\n    n.endsWith(\"*\") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(\".\") ? (n = n.substring(1), s = \"label\") : n.startsWith(\";\") && (n = n.substring(1), s = \"matrix\");\n    let l = t[n];\n    if (l == null) continue;\n    if (Array.isArray(l)) {\n      e = e.replace(i, O({ explode: o, name: n, style: s, value: l }));\n      continue;\n    }\n    if (typeof l == \"object\") {\n      e = e.replace(i, q({ explode: o, name: n, style: s, value: l }));\n      continue;\n    }\n    if (s === \"matrix\") {\n      e = e.replace(i, `;${y({ name: n, value: l })}`);\n      continue;\n    }\n    let f = encodeURIComponent(s === \"label\" ? `.${l}` : l);\n    e = e.replace(i, f);\n  }\n  return e;\n};\nvar E = ({ allowReserved: t, array: r, object: e } = {}) => (i) => {\n  let o = [];\n  if (i && typeof i == \"object\") for (let n in i) {\n    let s = i[n];\n    if (s != null) {\n      if (Array.isArray(s)) {\n        o = [...o, O({ allowReserved: t, explode: true, name: n, style: \"form\", value: s, ...r })];\n        continue;\n      }\n      if (typeof s == \"object\") {\n        o = [...o, q({ allowReserved: t, explode: true, name: n, style: \"deepObject\", value: s, ...e })];\n        continue;\n      }\n      o = [...o, y({ allowReserved: t, name: n, value: s })];\n    }\n  }\n  return o.join(\"&\");\n};\nvar P = (t) => {\n  if (!t) return \"stream\";\n  let r = t.split(\";\")[0]?.trim();\n  if (r) {\n    if (r.startsWith(\"application/json\") || r.endsWith(\"+json\")) return \"json\";\n    if (r === \"multipart/form-data\") return \"formData\";\n    if ([\"application/\", \"audio/\", \"image/\", \"video/\"].some((e) => r.startsWith(e))) return \"blob\";\n    if (r.startsWith(\"text/\")) return \"text\";\n  }\n};\nvar I = async ({ security: t, ...r }) => {\n  for (let e of t) {\n    let a = await A(e, r.auth);\n    if (!a) continue;\n    let i = e.name ?? \"Authorization\";\n    switch (e.in) {\n      case \"query\":\n        r.query || (r.query = {}), r.query[i] = a;\n        break;\n      case \"cookie\":\n        r.headers.append(\"Cookie\", `${i}=${a}`);\n        break;\n      case \"header\":\n      default:\n        r.headers.set(i, a);\n        break;\n    }\n    return;\n  }\n};\nvar S = (t) => W({ baseUrl: t.baseUrl, path: t.path, query: t.query, querySerializer: typeof t.querySerializer == \"function\" ? t.querySerializer : E(t.querySerializer), url: t.url });\nvar W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i }) => {\n  let o = i.startsWith(\"/\") ? i : `/${i}`, n = (t ?? \"\") + o;\n  r && (n = B({ path: r, url: n }));\n  let s = e ? a(e) : \"\";\n  return s.startsWith(\"?\") && (s = s.substring(1)), s && (n += `?${s}`), n;\n};\nvar C = (t, r) => {\n  let e = { ...t, ...r };\n  return e.baseUrl?.endsWith(\"/\") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;\n};\nvar x = (...t) => {\n  let r = new Headers();\n  for (let e of t) {\n    if (!e || typeof e != \"object\") continue;\n    let a = e instanceof Headers ? e.entries() : Object.entries(e);\n    for (let [i, o] of a) if (o === null) r.delete(i);\n    else if (Array.isArray(o)) for (let n of o) r.append(i, n);\n    else o !== void 0 && r.set(i, typeof o == \"object\" ? JSON.stringify(o) : o);\n  }\n  return r;\n};\nvar h = class {\n  constructor() {\n    (0,_chunk_NSSMTXJJ_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"_fns\");\n    this._fns = [];\n  }\n  clear() {\n    this._fns = [];\n  }\n  exists(r) {\n    return this._fns.indexOf(r) !== -1;\n  }\n  eject(r) {\n    let e = this._fns.indexOf(r);\n    e !== -1 && (this._fns = [...this._fns.slice(0, e), ...this._fns.slice(e + 1)]);\n  }\n  use(r) {\n    this._fns = [...this._fns, r];\n  }\n};\nvar T = () => ({ error: new h(), request: new h(), response: new h() });\nvar N = E({ allowReserved: false, array: { explode: true, style: \"form\" }, object: { explode: true, style: \"deepObject\" } });\nvar Q = { \"Content-Type\": \"application/json\" };\nvar w = (t = {}) => ({ ...R, headers: Q, parseAs: \"auto\", querySerializer: N, ...t });\nvar J = (t = {}) => {\n  let r = C(w(), t), e = () => ({ ...r }), a = (n) => (r = C(r, n), e()), i = T(), o = async (n) => {\n    let s = { ...r, ...n, fetch: n.fetch ?? r.fetch ?? globalThis.fetch, headers: x(r.headers, n.headers) };\n    s.security && await I({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === \"\") && s.headers.delete(\"Content-Type\");\n    let l = S(s), f = { redirect: \"follow\", ...s }, u = new Request(l, f);\n    for (let p of i.request._fns) u = await p(u, s);\n    let k = s.fetch, c = await k(u);\n    for (let p of i.response._fns) c = await p(c, u, s);\n    let m = { request: u, response: c };\n    if (c.ok) {\n      if (c.status === 204 || c.headers.get(\"Content-Length\") === \"0\") return { data: {}, ...m };\n      let p = (s.parseAs === \"auto\" ? P(c.headers.get(\"Content-Type\")) : s.parseAs) ?? \"json\";\n      if (p === \"stream\") return { data: c.body, ...m };\n      let b = await c[p]();\n      return p === \"json\" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), { data: b, ...m };\n    }\n    let g = await c.text();\n    try {\n      g = JSON.parse(g);\n    } catch {\n    }\n    let d = g;\n    for (let p of i.error._fns) d = await p(g, c, u, s);\n    if (d = d || {}, s.throwOnError) throw d;\n    return { error: d, ...m };\n  };\n  return { buildUrl: S, connect: (n) => o({ ...n, method: \"CONNECT\" }), delete: (n) => o({ ...n, method: \"DELETE\" }), get: (n) => o({ ...n, method: \"GET\" }), getConfig: e, head: (n) => o({ ...n, method: \"HEAD\" }), interceptors: i, options: (n) => o({ ...n, method: \"OPTIONS\" }), patch: (n) => o({ ...n, method: \"PATCH\" }), post: (n) => o({ ...n, method: \"POST\" }), put: (n) => o({ ...n, method: \"PUT\" }), request: o, setConfig: a, trace: (n) => o({ ...n, method: \"TRACE\" }) };\n};\n\n// src/api/client.gen.ts\nvar client = J(w({\n  baseUrl: \"http://localhost:8000\",\n  throwOnError: true\n}));\n\n// src/api/sdk.gen.ts\nvar DefaultService = class {\n  /**\n   * Retrieves the current user's identity, tenant, and databases.\n   */\n  static getUserIdentity(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/auth/identity\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a collection by Chroma Resource Name.\n   */\n  static getCollectionByCrn(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/collections/{crn}\",\n      ...options\n    });\n  }\n  /**\n   * Health check endpoint that returns 200 if the server and executor are ready\n   */\n  static healthcheck(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/healthcheck\",\n      ...options\n    });\n  }\n  /**\n   * Heartbeat endpoint that returns a nanosecond timestamp of the current time.\n   */\n  static heartbeat(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/heartbeat\",\n      ...options\n    });\n  }\n  /**\n   * Pre-flight checks endpoint reporting basic readiness info.\n   */\n  static preFlightChecks(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/pre-flight-checks\",\n      ...options\n    });\n  }\n  /**\n   * Reset endpoint allowing authorized users to reset the database.\n   */\n  static reset(options) {\n    return (options?.client ?? client).post({\n      url: \"/api/v2/reset\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new tenant.\n   */\n  static createTenant(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Returns an existing tenant by name.\n   */\n  static getTenant(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant_name}\",\n      ...options\n    });\n  }\n  /**\n   * Updates an existing tenant by name.\n   */\n  static updateTenant(options) {\n    return (options.client ?? client).patch({\n      url: \"/api/v2/tenants/{tenant_name}\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Lists all databases for a given tenant.\n   */\n  static listDatabases(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new database for a given tenant.\n   */\n  static createDatabase(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Deletes a specific database.\n   */\n  static deleteDatabase(options) {\n    return (options.client ?? client).delete({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a specific database by name.\n   */\n  static getDatabase(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}\",\n      ...options\n    });\n  }\n  /**\n   * Lists all collections in the specified database.\n   */\n  static listCollections(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections\",\n      ...options\n    });\n  }\n  /**\n   * Creates a new collection under the specified database.\n   */\n  static createCollection(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Deletes a collection in a given database.\n   */\n  static deleteCollection(options) {\n    return (options.client ?? client).delete({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options\n    });\n  }\n  /**\n   * Retrieves a collection by ID or name.\n   */\n  static getCollection(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options\n    });\n  }\n  /**\n   * Updates an existing collection's name or metadata.\n   */\n  static updateCollection(options) {\n    return (options.client ?? client).put({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Adds records to a collection.\n   */\n  static collectionAdd(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves the number of records in a collection.\n   */\n  static collectionCount(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count\",\n      ...options\n    });\n  }\n  /**\n   * Deletes records in a collection. Can filter by IDs or metadata.\n   */\n  static collectionDelete(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Forks an existing collection.\n   */\n  static forkCollection(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves records from a collection by ID or metadata filter.\n   */\n  static collectionGet(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search\n   */\n  static collectionQuery(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Search records from a collection with hybrid criterias.\n   */\n  static collectionSearch(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/search\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Updates records in a collection by ID.\n   */\n  static collectionUpdate(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Upserts records in a collection (create if not exists, otherwise update).\n   */\n  static collectionUpsert(options) {\n    return (options.client ?? client).post({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert\",\n      ...options,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options?.headers\n      }\n    });\n  }\n  /**\n   * Retrieves the total number of collections in a given database.\n   */\n  static countCollections(options) {\n    return (options.client ?? client).get({\n      url: \"/api/v2/tenants/{tenant}/databases/{database}/collections_count\",\n      ...options\n    });\n  }\n  /**\n   * Returns the version of the server.\n   */\n  static version(options) {\n    return (options?.client ?? client).get({\n      url: \"/api/v2/version\",\n      ...options\n    });\n  }\n};\n\n// src/errors.ts\nvar ChromaError = class extends Error {\n  constructor(name, message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = name;\n  }\n};\nvar ChromaConnectionError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaConnectionError\";\n  }\n};\nvar ChromaServerError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaServerError\";\n  }\n};\nvar ChromaClientError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaClientError\";\n  }\n};\nvar ChromaUnauthorizedError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaAuthError\";\n  }\n};\nvar ChromaForbiddenError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaForbiddenError\";\n  }\n};\nvar ChromaNotFoundError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaNotFoundError\";\n  }\n};\nvar ChromaValueError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaValueError\";\n  }\n};\nvar InvalidCollectionError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"InvalidCollectionError\";\n  }\n};\nvar InvalidArgumentError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"InvalidArgumentError\";\n  }\n};\nvar ChromaUniqueError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaUniqueError\";\n  }\n};\nvar ChromaQuotaExceededError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaQuotaExceededError\";\n  }\n};\nvar ChromaRateLimitError = class extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = \"ChromaRateLimitError\";\n  }\n};\nfunction createErrorByType(type, message) {\n  switch (type) {\n    case \"InvalidCollection\":\n      return new InvalidCollectionError(message);\n    case \"InvalidArgumentError\":\n      return new InvalidArgumentError(message);\n    default:\n      return void 0;\n  }\n}\n\n// src/utils.ts\nvar DEFAULT_TENANT = \"default_tenant\";\nvar DEFAULT_DATABASE = \"default_database\";\nvar defaultAdminClientArgs = {\n  host: \"localhost\",\n  port: 8e3,\n  ssl: false\n};\nvar defaultChromaClientArgs = {\n  ...defaultAdminClientArgs,\n  tenant: DEFAULT_TENANT,\n  database: DEFAULT_DATABASE\n};\nvar normalizeMethod = (method) => {\n  if (method) {\n    switch (method.toUpperCase()) {\n      case \"GET\":\n        return \"GET\";\n      case \"POST\":\n        return \"POST\";\n      case \"PUT\":\n        return \"PUT\";\n      case \"DELETE\":\n        return \"DELETE\";\n      case \"HEAD\":\n        return \"HEAD\";\n      case \"CONNECT\":\n        return \"CONNECT\";\n      case \"OPTIONS\":\n        return \"OPTIONS\";\n      case \"PATCH\":\n        return \"PATCH\";\n      case \"TRACE\":\n        return \"TRACE\";\n      default:\n        return void 0;\n    }\n  }\n  return void 0;\n};\nvar validateRecordSetLengthConsistency = (recordSet) => {\n  const lengths = Object.entries(recordSet).filter(\n    ([field, value]) => recordSetFields.includes(field) && value !== void 0\n  ).map(([field, value]) => [field, value.length]);\n  if (lengths.length === 0) {\n    throw new ChromaValueError(\n      `At least one of ${recordSetFields.join(\", \")} must be provided`\n    );\n  }\n  const zeroLength = lengths.filter(([_2, length]) => length === 0).map(([field, _2]) => field);\n  if (zeroLength.length > 0) {\n    throw new ChromaValueError(\n      `Non-empty lists are required for ${zeroLength.join(\", \")}`\n    );\n  }\n  if (new Set(lengths.map(([_2, length]) => length)).size > 1) {\n    throw new ChromaValueError(\n      `Unequal lengths for fields ${lengths.map(([field, _2]) => field).join(\", \")}`\n    );\n  }\n};\nvar validateEmbeddings = ({\n  embeddings,\n  fieldName = \"embeddings\"\n}) => {\n  if (!Array.isArray(embeddings)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof embeddings}`\n    );\n  }\n  if (embeddings.length === 0) {\n    throw new ChromaValueError(\n      \"Expected embeddings to be an array with at least one item\"\n    );\n  }\n  if (!embeddings.filter((e) => e.every((n) => typeof n === \"number\"))) {\n    throw new ChromaValueError(\n      \"Expected each embedding to be an array of numbers\"\n    );\n  }\n  embeddings.forEach((embedding, i) => {\n    if (embedding.length === 0) {\n      throw new ChromaValueError(\n        `Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${i}`\n      );\n    }\n  });\n};\nvar validateDocuments = ({\n  documents,\n  nullable = false,\n  fieldName = \"documents\"\n}) => {\n  if (!Array.isArray(documents)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof documents}`\n    );\n  }\n  if (documents.length === 0) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be a non-empty list`\n    );\n  }\n  documents.forEach((document) => {\n    if (!nullable && typeof document !== \"string\" && !document) {\n      throw new ChromaValueError(\n        `Expected each document to be a string, but got ${typeof document}`\n      );\n    }\n  });\n};\nvar validateIDs = (ids) => {\n  if (!Array.isArray(ids)) {\n    throw new ChromaValueError(\n      `Expected 'ids' to be an array, but got ${typeof ids}`\n    );\n  }\n  if (ids.length === 0) {\n    throw new ChromaValueError(\"Expected 'ids' to be a non-empty list\");\n  }\n  const nonStrings = ids.map((id, i) => [id, i]).filter(([id, _2]) => typeof id !== \"string\").map(([_2, i]) => i);\n  if (nonStrings.length > 0) {\n    throw new ChromaValueError(\n      `Found non-string IDs at ${nonStrings.join(\", \")}`\n    );\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const duplicates = ids.filter((id) => {\n    if (seen.has(id)) {\n      return id;\n    }\n    seen.add(id);\n  });\n  let message = \"Expected IDs to be unique, but found duplicates of\";\n  if (duplicates.length > 0 && duplicates.length <= 5) {\n    throw new ChromaValueError(`${message} ${duplicates.join(\", \")}`);\n  }\n  if (duplicates.length > 0) {\n    throw new ChromaValueError(\n      `${message} ${duplicates.slice(0, 5).join(\", \")}, ..., ${duplicates.slice(duplicates.length - 5).join(\", \")}`\n    );\n  }\n};\nvar validateSparseVector = (v) => {\n  return typeof v === \"object\" && v !== null && \"indices\" in v && \"values\" in v && Array.isArray(v.indices) && v.indices.every((e) => typeof e === \"number\") && Array.isArray(v.values) && v.values.every((e) => typeof e === \"number\");\n};\nvar validateMetadata = (metadata) => {\n  if (!metadata) {\n    return;\n  }\n  if (Object.keys(metadata).length === 0) {\n    throw new ChromaValueError(\"Expected metadata to be non-empty\");\n  }\n  if (!Object.values(metadata).every(\n    (v) => v === null || v === void 0 || typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\" || validateSparseVector(v)\n  )) {\n    throw new ChromaValueError(\n      \"Expected metadata to be a string, number, boolean, SparseVector, or nullable\"\n    );\n  }\n};\nvar validateMetadatas = (metadatas) => {\n  if (!Array.isArray(metadatas)) {\n    throw new ChromaValueError(\n      `Expected metadatas to be an array, but got ${typeof metadatas}`\n    );\n  }\n  metadatas.forEach((metadata) => validateMetadata(metadata));\n};\nvar validateBaseRecordSet = ({\n  recordSet,\n  update = false,\n  embeddingsField = \"embeddings\",\n  documentsField = \"documents\"\n}) => {\n  if (!recordSet.embeddings && !recordSet.documents && !update) {\n    throw new ChromaValueError(\n      `At least one of '${embeddingsField}' and '${documentsField}' must be provided`\n    );\n  }\n  if (recordSet.embeddings) {\n    validateEmbeddings({\n      embeddings: recordSet.embeddings,\n      fieldName: embeddingsField\n    });\n  }\n  if (recordSet.documents) {\n    validateDocuments({\n      documents: recordSet.documents,\n      fieldName: documentsField\n    });\n  }\n  if (recordSet.metadatas) {\n    validateMetadatas(recordSet.metadatas);\n  }\n};\nvar validateMaxBatchSize = (recordSetLength, maxBatchSize) => {\n  if (recordSetLength > maxBatchSize) {\n    throw new ChromaValueError(\n      `Record set length ${recordSetLength} exceeds max batch size ${maxBatchSize}`\n    );\n  }\n};\nvar validateWhere = (where) => {\n  if (typeof where !== \"object\") {\n    throw new ChromaValueError(\"Expected where to be a non-empty object\");\n  }\n  if (Object.keys(where).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'where' to have exactly one operator, but got ${Object.keys(where).length}`\n    );\n  }\n  Object.entries(where).forEach(([key, value]) => {\n    if (key !== \"$and\" && key !== \"$or\" && key !== \"$in\" && key !== \"$nin\" && ![\"string\", \"number\", \"boolean\", \"object\"].includes(typeof value)) {\n      throw new ChromaValueError(\n        `Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${value}`\n      );\n    }\n    if (key === \"$and\" || key === \"$or\") {\n      if (Object.keys(value).length <= 1) {\n        throw new ChromaValueError(\n          `Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${value}`\n        );\n      }\n      value.forEach((w2) => validateWhere(w2));\n      return;\n    }\n    if (typeof value === \"object\") {\n      if (Object.keys(value).length != 1) {\n        throw new ChromaValueError(\n          `Expected operator expression to have one operator, but got ${value}`\n        );\n      }\n      const [operator, operand] = Object.entries(value)[0];\n      if ([\"$gt\", \"$gte\", \"$lt\", \"$lte\"].includes(operator) && typeof operand !== \"number\") {\n        throw new ChromaValueError(\n          `Expected operand value to be a number for ${operator}, but got ${typeof operand}`\n        );\n      }\n      if ([\"$in\", \"$nin\"].includes(operator) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          `Expected operand value to be an array for ${operator}, but got ${operand}`\n        );\n      }\n      if (![\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\", \"$eq\", \"$in\", \"$nin\"].includes(\n        operator\n      )) {\n        throw new ChromaValueError(\n          `Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${operator}`\n        );\n      }\n      if (![\"string\", \"number\", \"boolean\"].includes(typeof operand) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          \"Expected operand value to be a string, number, boolean, or a list of those types\"\n        );\n      }\n      if (Array.isArray(operand) && (operand.length === 0 || !operand.every((item) => typeof item === typeof operand[0]))) {\n        throw new ChromaValueError(\n          \"Expected 'where' operand value to be a non-empty list and all values to be of the same type\"\n        );\n      }\n    }\n  });\n};\nvar validateWhereDocument = (whereDocument) => {\n  if (typeof whereDocument !== \"object\") {\n    throw new ChromaValueError(\n      \"Expected 'whereDocument' to be a non-empty object\"\n    );\n  }\n  if (Object.keys(whereDocument).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' to have exactly one operator, but got ${whereDocument}`\n    );\n  }\n  const [operator, operand] = Object.entries(whereDocument)[0];\n  if (![\n    \"$contains\",\n    \"$not_contains\",\n    \"$matches\",\n    \"$not_matches\",\n    \"$regex\",\n    \"$not_regex\",\n    \"$and\",\n    \"$or\"\n  ].includes(operator)) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${operator}`\n    );\n  }\n  if (operator === \"$and\" || operator === \"$or\") {\n    if (!Array.isArray(operand)) {\n      throw new ChromaValueError(\n        `Expected operand for ${operator} to be a list of 'whereDocument' expressions, but got ${operand}`\n      );\n    }\n    if (operand.length <= 1) {\n      throw new ChromaValueError(\n        `Expected 'whereDocument' operand for ${operator} to be a list with at least two 'whereDocument' expressions`\n      );\n    }\n    operand.forEach((item) => validateWhereDocument(item));\n  }\n  if ((operand === \"$contains\" || operand === \"$not_contains\" || operand === \"$regex\" || operand === \"$not_regex\") && (typeof operator !== \"string\" || operator.length === 0)) {\n    throw new ChromaValueError(\n      `Expected operand for ${operator} to be a non empty string, but got ${operand}`\n    );\n  }\n};\nvar validateInclude = ({\n  include,\n  exclude\n}) => {\n  if (!Array.isArray(include)) {\n    throw new ChromaValueError(\"Expected 'include' to be a non-empty array\");\n  }\n  const validValues = Object.keys(IncludeEnum);\n  include.forEach((item) => {\n    if (typeof item !== \"string\") {\n      throw new ChromaValueError(\"Expected 'include' items to be strings\");\n    }\n    if (!validValues.includes(item)) {\n      throw new ChromaValueError(\n        `Expected 'include' items to be one of ${validValues.join(\n          \", \"\n        )}, but got ${item}`\n      );\n    }\n    if (exclude?.includes(item)) {\n      throw new ChromaValueError(`${item} is not allowed for this operation`);\n    }\n  });\n};\nvar validateNResults = (nResults) => {\n  if (typeof nResults !== \"number\") {\n    throw new ChromaValueError(\n      `Expected 'nResults' to be a number, but got ${typeof nResults}`\n    );\n  }\n  if (nResults <= 0) {\n    throw new ChromaValueError(\"Number of requested results has to positive\");\n  }\n};\nvar parseConnectionPath = (path) => {\n  try {\n    const url = new URL(path);\n    const ssl = url.protocol === \"https:\";\n    const host = url.hostname;\n    const port = url.port;\n    return {\n      ssl,\n      host,\n      port: Number(port)\n    };\n  } catch {\n    throw new ChromaValueError(`Invalid URL: ${path}`);\n  }\n};\nvar packEmbedding = (embedding) => {\n  const buffer = new ArrayBuffer(embedding.length * 4);\n  const view = new Float32Array(buffer);\n  for (let i = 0; i < embedding.length; i++) {\n    view[i] = embedding[i];\n  }\n  return buffer;\n};\nvar embeddingsToBase64Bytes = (embeddings) => {\n  return embeddings.map((embedding) => {\n    const buffer = packEmbedding(embedding);\n    const uint8Array = new Uint8Array(buffer);\n    const binaryString = Array.from(\n      uint8Array,\n      (byte) => String.fromCharCode(byte)\n    ).join(\"\");\n    return btoa(binaryString);\n  });\n};\n\n// src/embedding-function.ts\nvar knownEmbeddingFunctions = /* @__PURE__ */ new Map();\nvar registerEmbeddingFunction = (name, fn) => {\n  if (knownEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Embedding function with name ${name} is already registered.`\n    );\n  }\n  knownEmbeddingFunctions.set(name, fn);\n};\nvar getEmbeddingFunction = async (collectionName, efConfig) => {\n  if (!efConfig) {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  if (efConfig.type === \"legacy\") {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  }\n  const name = efConfig.name;\n  const embeddingFunction = knownEmbeddingFunctions.get(name);\n  if (!embeddingFunction) {\n    console.warn(\n      `Collection ${collectionName} was created with the ${embeddingFunction} embedding function. However, the @chroma-core/${embeddingFunction} package is not install. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${embeddingFunction} package.`\n    );\n    return void 0;\n  }\n  let constructorConfig = efConfig.type === \"known\" ? efConfig.config : {};\n  try {\n    if (embeddingFunction.buildFromConfig) {\n      return embeddingFunction.buildFromConfig(constructorConfig);\n    }\n    console.warn(\n      `Embedding function ${name} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`\n    );\n    return void 0;\n  } catch (e) {\n    console.warn(\n      `Embedding function ${name} failed to build with config: ${constructorConfig}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`\n    );\n    return void 0;\n  }\n};\nvar serializeEmbeddingFunction = ({\n  embeddingFunction,\n  configEmbeddingFunction\n}) => {\n  if (embeddingFunction && configEmbeddingFunction) {\n    throw new ChromaValueError(\n      \"Embedding function provided when already defined in the collection configuration\"\n    );\n  }\n  if (!embeddingFunction && !configEmbeddingFunction) {\n    return void 0;\n  }\n  const ef = embeddingFunction || configEmbeddingFunction;\n  if (!ef.getConfig || !ef.name || !ef.constructor.buildFromConfig) {\n    return { type: \"legacy\" };\n  }\n  if (ef.validateConfig) ef.validateConfig(ef.getConfig());\n  return {\n    name: ef.name,\n    type: \"known\",\n    config: ef.getConfig()\n  };\n};\nvar getDefaultEFConfig = async () => {\n  try {\n    const { DefaultEmbeddingFunction } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/ajv@8.17.1\"), __webpack_require__.e(\"vendor-chunks/onnxruntime-common@1.21.0\"), __webpack_require__.e(\"vendor-chunks/sharp@0.34.4\"), __webpack_require__.e(\"vendor-chunks/detect-libc@2.1.2\"), __webpack_require__.e(\"vendor-chunks/fast-uri@3.1.0\"), __webpack_require__.e(\"vendor-chunks/@img+sharp-libvips-darwin-arm64@1.2.3\"), __webpack_require__.e(\"vendor-chunks/@img+colour@1.0.0\"), __webpack_require__.e(\"vendor-chunks/@huggingface+transformers@3.7.6\"), __webpack_require__.e(\"vendor-chunks/@chroma-core+default-embed@0.1.8\"), __webpack_require__.e(\"vendor-chunks/@chroma-core+ai-embeddings-common@0.1.7\"), __webpack_require__.e(\"vendor-chunks/json-schema-traverse@1.0.0\"), __webpack_require__.e(\"vendor-chunks/fast-deep-equal@3.1.3\"), __webpack_require__.e(\"_rsc_node_modules_pnpm_sharp_0_34_4_node_modules_img_node_modules_pnpm_node_modules_img_node_-431891\")]).then(__webpack_require__.bind(__webpack_require__, /*! @chroma-core/default-embed */ \"(rsc)/./node_modules/.pnpm/@chroma-core+default-embed@0.1.8/node_modules/@chroma-core/default-embed/dist/default-embed.mjs\"));\n    if (!knownEmbeddingFunctions.has(new DefaultEmbeddingFunction().name)) {\n      registerEmbeddingFunction(\"default\", DefaultEmbeddingFunction);\n    }\n  } catch (e) {\n    console.error(e);\n    throw new Error(\n      \"Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function\"\n    );\n  }\n  return {\n    name: \"default\",\n    type: \"known\",\n    config: {}\n  };\n};\n\n// src/collection-configuration.ts\nvar processCreateCollectionConfig = async ({\n  configuration,\n  embeddingFunction,\n  metadata\n}) => {\n  if (configuration?.hnsw && configuration?.spann) {\n    throw new ChromaValueError(\n      \"Cannot specify both HNSW and SPANN configurations\"\n    );\n  }\n  let embeddingFunctionConfiguration = serializeEmbeddingFunction({\n    embeddingFunction: embeddingFunction ?? void 0,\n    configEmbeddingFunction: configuration?.embeddingFunction\n  });\n  if (!embeddingFunctionConfiguration && embeddingFunction !== null) {\n    embeddingFunctionConfiguration = await getDefaultEFConfig();\n  }\n  const overallEf = embeddingFunction || configuration?.embeddingFunction;\n  if (overallEf && overallEf.defaultSpace && overallEf.supportedSpaces) {\n    if (configuration?.hnsw === void 0 && configuration?.spann === void 0) {\n      if (metadata === void 0 || metadata?.[\"hnsw:space\"] === void 0) {\n        if (!configuration) configuration = {};\n        configuration.hnsw = { space: overallEf.defaultSpace() };\n      }\n    }\n    if (configuration?.hnsw && !configuration.hnsw.space && overallEf.defaultSpace) {\n      configuration.hnsw.space = overallEf.defaultSpace();\n    }\n    if (configuration?.spann && !configuration.spann.space && overallEf.defaultSpace) {\n      configuration.spann.space = overallEf.defaultSpace();\n    }\n    if (overallEf.supportedSpaces) {\n      const supportedSpaces = overallEf.supportedSpaces();\n      if (configuration?.hnsw?.space && !supportedSpaces.includes(configuration.hnsw.space)) {\n        console.warn(\n          `Space '${configuration.hnsw.space}' is not supported by embedding function '${overallEf.name || \"unknown\"}'. Supported spaces: ${supportedSpaces.join(\", \")}`\n        );\n      }\n      if (configuration?.spann?.space && !supportedSpaces.includes(configuration.spann.space)) {\n        console.warn(\n          `Space '${configuration.spann.space}' is not supported by embedding function '${overallEf.name || \"unknown\"}'. Supported spaces: ${supportedSpaces.join(\", \")}`\n        );\n      }\n      if (!configuration?.hnsw && !configuration?.spann && metadata && typeof metadata[\"hnsw:space\"] === \"string\" && !supportedSpaces.includes(metadata[\"hnsw:space\"])) {\n        console.warn(\n          `Space '${metadata[\"hnsw:space\"]}' from metadata is not supported by embedding function '${overallEf.name || \"unknown\"}'. Supported spaces: ${supportedSpaces.join(\", \")}`\n        );\n      }\n    }\n  }\n  return {\n    ...configuration || {},\n    embedding_function: embeddingFunctionConfiguration\n  };\n};\nvar processUpdateCollectionConfig = async ({\n  collectionName,\n  currentConfiguration,\n  currentEmbeddingFunction,\n  newConfiguration\n}) => {\n  if (newConfiguration.hnsw && typeof newConfiguration.hnsw !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid HNSW config provided in UpdateCollectionConfiguration\"\n    );\n  }\n  if (newConfiguration.spann && typeof newConfiguration.spann !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid SPANN config provided in UpdateCollectionConfiguration\"\n    );\n  }\n  const embeddingFunction = currentEmbeddingFunction || await getEmbeddingFunction(\n    collectionName,\n    currentConfiguration.embeddingFunction ?? void 0\n  );\n  const newEmbeddingFunction = newConfiguration.embeddingFunction;\n  if (embeddingFunction && embeddingFunction.validateConfigUpdate && newEmbeddingFunction && newEmbeddingFunction.getConfig) {\n    embeddingFunction.validateConfigUpdate(newEmbeddingFunction.getConfig());\n  }\n  return {\n    updateConfiguration: {\n      hnsw: newConfiguration.hnsw,\n      spann: newConfiguration.spann,\n      embedding_function: newEmbeddingFunction && serializeEmbeddingFunction({ embeddingFunction: newEmbeddingFunction })\n    },\n    updateEmbeddingFunction: newEmbeddingFunction\n  };\n};\n\n// src/collection.ts\nvar CollectionImpl = class _CollectionImpl {\n  /**\n   * Creates a new CollectionAPIImpl instance.\n   * @param options - Configuration for the collection API\n   */\n  constructor({\n    chromaClient,\n    apiClient,\n    id,\n    name,\n    metadata,\n    configuration,\n    embeddingFunction\n  }) {\n    this.chromaClient = chromaClient;\n    this.apiClient = apiClient;\n    this.id = id;\n    this._name = name;\n    this._metadata = metadata;\n    this._configuration = configuration;\n    this._embeddingFunction = embeddingFunction;\n  }\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n  }\n  get configuration() {\n    return this._configuration;\n  }\n  set configuration(configuration) {\n    this._configuration = configuration;\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  set metadata(metadata) {\n    this._metadata = metadata;\n  }\n  get embeddingFunction() {\n    return this._embeddingFunction;\n  }\n  set embeddingFunction(embeddingFunction) {\n    this._embeddingFunction = embeddingFunction;\n  }\n  async path() {\n    const clientPath = await this.chromaClient._path();\n    return {\n      ...clientPath,\n      collection_id: this.id\n    };\n  }\n  async embed(documents) {\n    if (!this._embeddingFunction) {\n      throw new ChromaValueError(\n        \"Embedding function must be defined for operations requiring embeddings.\"\n      );\n    }\n    return await this._embeddingFunction.generate(documents);\n  }\n  async prepareRecords({\n    recordSet,\n    update = false\n  }) {\n    const maxBatchSize = await this.chromaClient.getMaxBatchSize();\n    validateRecordSetLengthConsistency(recordSet);\n    validateIDs(recordSet.ids);\n    validateBaseRecordSet({ recordSet, update });\n    validateMaxBatchSize(recordSet.ids.length, maxBatchSize);\n    if (!recordSet.embeddings && recordSet.documents) {\n      recordSet.embeddings = await this.embed(recordSet.documents);\n    }\n    const preparedRecordSet = { ...recordSet };\n    const base64Supported = await this.chromaClient.supportsBase64Encoding();\n    if (base64Supported && recordSet.embeddings) {\n      preparedRecordSet.embeddings = embeddingsToBase64Bytes(\n        recordSet.embeddings\n      );\n    }\n    return preparedRecordSet;\n  }\n  validateGet(include, ids, where, whereDocument) {\n    validateInclude({ include, exclude: [\"distances\"] });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n  async prepareQuery(recordSet, include, ids, where, whereDocument, nResults) {\n    validateBaseRecordSet({\n      recordSet,\n      embeddingsField: \"queryEmbeddings\",\n      documentsField: \"queryTexts\"\n    });\n    validateInclude({ include });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n    if (nResults) validateNResults(nResults);\n    let embeddings;\n    if (!recordSet.embeddings) {\n      embeddings = await this.embed(recordSet.documents);\n    } else {\n      embeddings = recordSet.embeddings;\n    }\n    return {\n      ...recordSet,\n      ids,\n      embeddings\n    };\n  }\n  validateDelete(ids, where, whereDocument) {\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n  async count() {\n    const { data } = await DefaultService.collectionCount({\n      client: this.apiClient,\n      path: await this.path()\n    });\n    return data;\n  }\n  async add({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({ recordSet });\n    await DefaultService.collectionAdd({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        documents: preparedRecordSet.documents,\n        metadatas: preparedRecordSet.metadatas,\n        uris: preparedRecordSet.uris\n      }\n    });\n  }\n  async get(args = {}) {\n    const {\n      ids,\n      where,\n      limit,\n      offset,\n      whereDocument,\n      include = [\"documents\", \"metadatas\"]\n    } = args;\n    this.validateGet(include, ids, where, whereDocument);\n    const { data } = await DefaultService.collectionGet({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        limit,\n        offset,\n        where_document: whereDocument,\n        include\n      }\n    });\n    return new GetResult({\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids,\n      include: data.include,\n      metadatas: data.metadatas ?? [],\n      uris: data.uris ?? []\n    });\n  }\n  async peek({ limit = 10 }) {\n    return this.get({ limit });\n  }\n  async query({\n    queryEmbeddings,\n    queryTexts,\n    queryURIs,\n    ids,\n    nResults = 10,\n    where,\n    whereDocument,\n    include = [\"metadatas\", \"documents\", \"distances\"]\n  }) {\n    const recordSet = {\n      embeddings: queryEmbeddings,\n      documents: queryTexts,\n      uris: queryURIs\n    };\n    const queryRecordSet = await this.prepareQuery(\n      recordSet,\n      include,\n      ids,\n      where,\n      whereDocument,\n      nResults\n    );\n    const { data } = await DefaultService.collectionQuery({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: queryRecordSet.ids,\n        include,\n        n_results: nResults,\n        query_embeddings: queryRecordSet.embeddings,\n        where,\n        where_document: whereDocument\n      }\n    });\n    return new QueryResult({\n      distances: data.distances ?? [],\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids ?? [],\n      include: data.include,\n      metadatas: data.metadatas ?? [],\n      uris: data.uris ?? []\n    });\n  }\n  async modify({\n    name,\n    metadata,\n    configuration\n  }) {\n    if (name) this.name = name;\n    if (metadata) {\n      validateMetadata(metadata);\n      this.metadata = metadata;\n    }\n    const { updateConfiguration, updateEmbeddingFunction } = configuration ? await processUpdateCollectionConfig({\n      collectionName: this.name,\n      currentConfiguration: this.configuration,\n      newConfiguration: configuration,\n      currentEmbeddingFunction: this.embeddingFunction\n    }) : {};\n    if (updateEmbeddingFunction) {\n      this.embeddingFunction = updateEmbeddingFunction;\n    }\n    if (updateConfiguration) {\n      this.configuration = {\n        hnsw: { ...this.configuration.hnsw, ...updateConfiguration.hnsw },\n        spann: { ...this.configuration.spann, ...updateConfiguration.spann },\n        embeddingFunction: updateConfiguration.embedding_function\n      };\n    }\n    await DefaultService.updateCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        new_name: name,\n        new_metadata: metadata,\n        new_configuration: updateConfiguration\n      }\n    });\n  }\n  async fork({ name }) {\n    const { data } = await DefaultService.forkCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { new_name: name }\n    });\n    return new _CollectionImpl({\n      chromaClient: this.chromaClient,\n      apiClient: this.apiClient,\n      name: data.name,\n      id: data.id,\n      embeddingFunction: this._embeddingFunction,\n      metadata: data.metadata ?? void 0,\n      configuration: data.configuration_json\n    });\n  }\n  async update({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n      update: true\n    });\n    await DefaultService.collectionUpdate({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: preparedRecordSet.metadatas,\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents\n      }\n    });\n  }\n  async upsert({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris\n  }) {\n    const recordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris\n    };\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet\n    });\n    await DefaultService.collectionUpsert({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: preparedRecordSet.metadatas,\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents\n      }\n    });\n  }\n  async delete({\n    ids,\n    where,\n    whereDocument\n  }) {\n    this.validateDelete(ids, where, whereDocument);\n    await DefaultService.collectionDelete({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        where_document: whereDocument\n      }\n    });\n  }\n};\n\n// src/next.ts\nfunction withChroma(userNextConfig = {}) {\n  const originalWebpackFunction = userNextConfig.webpack;\n  const newWebpackFunction = (config, options) => {\n    if (!Array.isArray(config.externals)) {\n      config.externals = [];\n    }\n    const externalsToAdd = [\"@huggingface/transformers\", \"chromadb\"];\n    for (const ext of externalsToAdd) {\n      if (!config.externals.includes(ext)) {\n        config.externals.push(ext);\n      }\n    }\n    if (typeof originalWebpackFunction === \"function\") {\n      return originalWebpackFunction(config, options);\n    }\n    return config;\n  };\n  return {\n    ...userNextConfig,\n    webpack: newWebpackFunction\n  };\n}\n\n// src/chroma-fetch.ts\nvar offlineError = (error) => {\n  return Boolean(\n    (error?.name === \"TypeError\" || error?.name === \"FetchError\") && (error.message?.includes(\"fetch failed\") || error.message?.includes(\"Failed to fetch\") || error.message?.includes(\"ENOTFOUND\"))\n  );\n};\nvar chromaFetch = async (input, init) => {\n  let response;\n  try {\n    response = await fetch(input, init);\n  } catch (err) {\n    if (offlineError(err)) {\n      throw new ChromaConnectionError(\n        \"Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.\"\n      );\n    }\n    throw new ChromaConnectionError(\"Failed to connect to Chroma\");\n  }\n  if (response.ok) {\n    return response;\n  }\n  switch (response.status) {\n    case 400:\n      let status = \"Bad Request\";\n      try {\n        const responseBody = await response.json();\n        status = responseBody.message || status;\n      } catch {\n      }\n      throw new ChromaClientError(\n        `Bad request to ${input.url || \"Chroma\"} with status: ${status}`\n      );\n    case 401:\n      throw new ChromaUnauthorizedError(`Unauthorized`);\n    case 403:\n      throw new ChromaForbiddenError(\n        `You do not have permission to access the requested resource.`\n      );\n    case 404:\n      throw new ChromaNotFoundError(\n        `The requested resource could not be found`\n      );\n    case 409:\n      throw new ChromaUniqueError(\"The resource already exists\");\n    case 422:\n      const body = await response.json();\n      if (body && body.message && (body.message.startsWith(\"Quota exceeded\") || body.message.startsWith(\"Billing limit exceeded\"))) {\n        throw new ChromaQuotaExceededError(body?.message);\n      }\n      break;\n    case 429:\n      throw new ChromaRateLimitError(\"Rate limit exceeded\");\n  }\n  throw new ChromaConnectionError(\n    `Unable to connect to the chromadb server (status: ${response.status}). Please try again later.`\n  );\n};\n\n// src/admin-client.ts\nvar AdminClient = class {\n  /**\n   * Creates a new AdminClient instance.\n   * @param args - Optional configuration for the admin client\n   */\n  constructor(args) {\n    const { host, port, ssl, headers, fetchOptions } = args || defaultAdminClientArgs;\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method),\n      baseUrl,\n      headers\n    };\n    this.apiClient = J(w(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n  /**\n   * Creates a new database within a tenant.\n   * @param options - Database creation options\n   * @param options.name - Name of the database to create\n   * @param options.tenant - Tenant that will own the database\n   */\n  async createDatabase({\n    name,\n    tenant\n  }) {\n    await DefaultService.createDatabase({\n      client: this.apiClient,\n      path: { tenant },\n      body: { name }\n    });\n  }\n  /**\n   * Retrieves information about a specific database.\n   * @param options - Database retrieval options\n   * @param options.name - Name of the database to retrieve\n   * @param options.tenant - Tenant that owns the database\n   * @returns Promise resolving to database information\n   */\n  async getDatabase({\n    name,\n    tenant\n  }) {\n    const { data } = await DefaultService.getDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name }\n    });\n    return data;\n  }\n  /**\n   * Deletes a database and all its data.\n   * @param options - Database deletion options\n   * @param options.name - Name of the database to delete\n   * @param options.tenant - Tenant that owns the database\n   * @warning This operation is irreversible and will delete all data\n   */\n  async deleteDatabase({\n    name,\n    tenant\n  }) {\n    await DefaultService.deleteDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name }\n    });\n  }\n  /**\n   * Lists all databases within a tenant.\n   * @param args - Listing parameters including tenant and pagination\n   * @returns Promise resolving to an array of database information\n   */\n  async listDatabases(args) {\n    const { limit = 100, offset = 0, tenant } = args;\n    const { data } = await DefaultService.listDatabases({\n      client: this.apiClient,\n      path: { tenant },\n      query: { limit, offset }\n    });\n    return data;\n  }\n  /**\n   * Creates a new tenant.\n   * @param options - Tenant creation options\n   * @param options.name - Name of the tenant to create\n   */\n  async createTenant({ name }) {\n    await DefaultService.createTenant({\n      client: this.apiClient,\n      body: { name }\n    });\n  }\n  /**\n   * Retrieves information about a specific tenant.\n   * @param options - Tenant retrieval options\n   * @param options.name - Name of the tenant to retrieve\n   * @returns Promise resolving to the tenant name\n   */\n  async getTenant({ name }) {\n    const { data } = await DefaultService.getTenant({\n      client: this.apiClient,\n      path: { tenant_name: name }\n    });\n    return data.name;\n  }\n};\n\n// src/chroma-client.ts\n\nvar ChromaClient = class {\n  /**\n   * Creates a new ChromaClient instance.\n   * @param args - Configuration options for the client\n   */\n  constructor(args = {}) {\n    let {\n      host = defaultChromaClientArgs.host,\n      port = defaultChromaClientArgs.port,\n      ssl = defaultChromaClientArgs.ssl,\n      tenant = defaultChromaClientArgs.tenant,\n      database = defaultChromaClientArgs.database,\n      headers = defaultChromaClientArgs.headers,\n      fetchOptions = defaultChromaClientArgs.fetchOptions\n    } = args;\n    if (args.path) {\n      console.warn(\n        \"The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead\"\n      );\n      const parsedPath = parseConnectionPath(args.path);\n      ssl = parsedPath.ssl;\n      host = parsedPath.host;\n      port = parsedPath.port;\n    }\n    if (args.auth) {\n      console.warn(\n        \"The 'auth' argument is deprecated. Please use 'headers' instead\"\n      );\n      if (!headers) {\n        headers = {};\n      }\n      if (!headers[\"x-chroma-token\"] && args.auth.tokenHeaderType === \"X_CHROMA_TOKEN\" && args.auth.credentials) {\n        headers[\"x-chroma-token\"] = args.auth.credentials;\n      }\n    }\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n    this._tenant = tenant || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_TENANT;\n    this._database = database || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_DATABASE;\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method),\n      baseUrl,\n      headers\n    };\n    this.apiClient = J(w(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n  /**\n   * Gets the current tenant name.\n   * @returns The tenant name or undefined if not set\n   */\n  get tenant() {\n    return this._tenant;\n  }\n  set tenant(tenant) {\n    this._tenant = tenant;\n  }\n  /**\n   * Gets the current database name.\n   * @returns The database name or undefined if not set\n   */\n  get database() {\n    return this._database;\n  }\n  set database(database) {\n    this._database = database;\n  }\n  /**\n   * Gets the preflight checks\n   * @returns The preflight checks or undefined if not set\n   */\n  get preflightChecks() {\n    return this._preflightChecks;\n  }\n  set preflightChecks(preflightChecks) {\n    this._preflightChecks = preflightChecks;\n  }\n  /** @ignore */\n  async _path() {\n    if (!this._tenant || !this._database) {\n      const { tenant, databases } = await this.getUserIdentity();\n      const uniqueDBs = [...new Set(databases)];\n      this._tenant = tenant;\n      if (uniqueDBs.length === 0) {\n        throw new ChromaUnauthorizedError(\n          `Your API key does not have access to any DBs for tenant ${this.tenant}`\n        );\n      }\n      if (uniqueDBs.length > 1 || uniqueDBs[0] === \"*\") {\n        throw new ChromaValueError(\n          \"Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor\"\n        );\n      }\n      this._database = uniqueDBs[0];\n    }\n    return { tenant: this._tenant, database: this._database };\n  }\n  /**\n   * Gets the user identity information including tenant and accessible databases.\n   * @returns Promise resolving to user identity data\n   */\n  async getUserIdentity() {\n    const { data } = await DefaultService.getUserIdentity({\n      client: this.apiClient\n    });\n    return data;\n  }\n  /**\n   * Sends a heartbeat request to check server connectivity.\n   * @returns Promise resolving to the server's nanosecond heartbeat timestamp\n   */\n  async heartbeat() {\n    const { data } = await DefaultService.heartbeat({\n      client: this.apiClient\n    });\n    return data[\"nanosecond heartbeat\"];\n  }\n  /**\n   * Lists all collections in the current database.\n   * @param args - Optional pagination parameters\n   * @param args.limit - Maximum number of collections to return (default: 100)\n   * @param args.offset - Number of collections to skip (default: 0)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  async listCollections(args) {\n    const { limit = 100, offset = 0 } = args || {};\n    const { data } = await DefaultService.listCollections({\n      client: this.apiClient,\n      path: await this._path(),\n      query: { limit, offset }\n    });\n    return Promise.all(\n      data.map(\n        async (collection) => new CollectionImpl({\n          chromaClient: this,\n          apiClient: this.apiClient,\n          name: collection.name,\n          id: collection.id,\n          embeddingFunction: await getEmbeddingFunction(\n            collection.name,\n            collection.configuration_json.embedding_function ?? void 0\n          ),\n          configuration: collection.configuration_json,\n          metadata: collection.metadata ?? void 0\n        })\n      )\n    );\n  }\n  /**\n   * Gets the total number of collections in the current database.\n   * @returns Promise resolving to the collection count\n   */\n  async countCollections() {\n    const { data } = await DefaultService.countCollections({\n      client: this.apiClient,\n      path: await this._path()\n    });\n    return data;\n  }\n  /**\n   * Creates a new collection with the specified configuration.\n   * @param options - Collection creation options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration\n   * @param options.metadata - Optional metadata for the collection\n   * @param options.embeddingFunction - Optional embedding function to use. Defaults to `DefaultEmbeddingFunction` from @chroma-core/default-embed\n   * @returns Promise resolving to the created Collection instance\n   * @throws Error if a collection with the same name already exists\n   */\n  async createCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction\n  }) {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata\n    });\n    const { data } = await DefaultService.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata,\n        get_or_create: false\n      }\n    });\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      configuration: data.configuration_json,\n      metadata,\n      embeddingFunction: embeddingFunction ?? await getEmbeddingFunction(\n        data.name,\n        data.configuration_json.embedding_function ?? void 0\n      ),\n      id: data.id\n    });\n  }\n  /**\n   * Retrieves an existing collection by name.\n   * @param options - Collection retrieval options\n   * @param options.name - The name of the collection to retrieve\n   * @param options.embeddingFunction - Optional embedding function. Should match the one used to create the collection.\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  async getCollection({\n    name,\n    embeddingFunction\n  }) {\n    const { data } = await DefaultService.getCollection({\n      client: this.apiClient,\n      path: { ...await this._path(), collection_id: name }\n    });\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      configuration: data.configuration_json,\n      metadata: data.metadata ?? void 0,\n      embeddingFunction: embeddingFunction ? embeddingFunction : await getEmbeddingFunction(\n        data.name,\n        data.configuration_json.embedding_function ?? void 0\n      ),\n      id: data.id\n    });\n  }\n  /**\n   * Retrieves multiple collections by name.\n   * @param items - Array of collection names or objects with name and optional embedding function (should match the ones used to create the collections)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  async getCollections(items) {\n    if (items.length === 0) return [];\n    let requestedCollections = items;\n    if (typeof items[0] === \"string\") {\n      requestedCollections = items.map((item) => {\n        return { name: item, embeddingFunction: void 0 };\n      });\n    }\n    let collections = requestedCollections;\n    return Promise.all(\n      collections.map(async (collection) => {\n        return this.getCollection({ ...collection });\n      })\n    );\n  }\n  /**\n   * Gets an existing collection or creates it if it doesn't exist.\n   * @param options - Collection options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration (used only if creating)\n   * @param options.metadata - Optional metadata for the collection (used only if creating)\n   * @param options.embeddingFunction - Optional embedding function to use\n   * @returns Promise resolving to the Collection instance\n   */\n  async getOrCreateCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction\n  }) {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata\n    });\n    const { data } = await DefaultService.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata,\n        get_or_create: true\n      }\n    });\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      configuration: data.configuration_json,\n      metadata: data.metadata ?? void 0,\n      embeddingFunction: embeddingFunction ?? await getEmbeddingFunction(\n        name,\n        data.configuration_json.embedding_function ?? void 0\n      ),\n      id: data.id\n    });\n  }\n  /**\n   * Deletes a collection and all its data.\n   * @param options - Deletion options\n   * @param options.name - The name of the collection to delete\n   */\n  async deleteCollection({ name }) {\n    await DefaultService.deleteCollection({\n      client: this.apiClient,\n      path: { ...await this._path(), collection_id: name }\n    });\n  }\n  /**\n   * Resets the entire database, deleting all collections and data.\n   * @returns Promise that resolves when the reset is complete\n   * @warning This operation is irreversible and will delete all data\n   */\n  async reset() {\n    await DefaultService.reset({\n      client: this.apiClient\n    });\n  }\n  /**\n   * Gets the version of the Chroma server.\n   * @returns Promise resolving to the server version string\n   */\n  async version() {\n    const { data } = await DefaultService.version({\n      client: this.apiClient\n    });\n    return data;\n  }\n  /**\n   * Gets the preflight checks\n   * @returns Promise resolving to the preflight checks\n   */\n  async getPreflightChecks() {\n    if (!this.preflightChecks) {\n      const { data } = await DefaultService.preFlightChecks({\n        client: this.apiClient\n      });\n      this.preflightChecks = data;\n      return this.preflightChecks;\n    }\n    return this.preflightChecks;\n  }\n  /**\n   * Gets the max batch size\n   * @returns Promise resolving to the max batch size\n   */\n  async getMaxBatchSize() {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.max_batch_size ?? -1;\n  }\n  /**\n   * Gets whether base64_encoding is supported by the connected server\n   * @returns Promise resolving to whether base64_encoding is supported\n   */\n  async supportsBase64Encoding() {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.supports_base64_encoding ?? false;\n  }\n};\n\n// src/cloud-client.ts\n\nvar CloudClient = class extends ChromaClient {\n  /**\n   * Creates a new CloudClient instance for Chroma Cloud.\n   * @param args - Cloud client configuration options\n   */\n  constructor(args = {}) {\n    const apiKey = args.apiKey || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\"\n      );\n    }\n    const tenant = args.tenant || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_TENANT;\n    const database = args.database || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_DATABASE;\n    super({\n      host: \"api.trychroma.com\",\n      port: 8e3,\n      ssl: true,\n      tenant,\n      database,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions\n    });\n    this.tenant = tenant;\n    this.database = database;\n  }\n};\nvar AdminCloudClient = class extends AdminClient {\n  /**\n   * Creates a new AdminCloudClient instance for cloud admin operations.\n   * @param args - Admin cloud client configuration options\n   */\n  constructor(args = {}) {\n    const apiKey = args.apiKey || node_process__WEBPACK_IMPORTED_MODULE_1__.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\"\n      );\n    }\n    super({\n      host: \"api.trychroma.com\",\n      port: 8e3,\n      ssl: true,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions\n    });\n  }\n};\n\n//# sourceMappingURL=chromadb.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vY2hyb21hZGJAMy4wLjE3L25vZGVfbW9kdWxlcy9jaHJvbWFkYi9kaXN0L2Nocm9tYWRiLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLG9DQUFvQyxRQUFRO0FBQ2hHO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUEyRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0EsaUJBQWlCLEVBQUUsRUFBRSxHQUFHLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUsR0FBRyxFQUFFO0FBQ3pCO0FBQ0E7QUFDQSx1R0FBdUcscUNBQXFDO0FBQzVJO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRDtBQUNBO0FBQ0EsWUFBWSxFQUFFLEdBQUcsOEJBQThCO0FBQy9DO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEUsbUNBQW1DLEVBQUUsR0FBRyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUsR0FBRyxFQUFFO0FBQ3pCO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckI7QUFDQSxpQkFBaUIsRUFBRSxFQUFFLEdBQUcsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnREFBZ0QsRUFBRSxHQUFHLEVBQUUsa0JBQWtCO0FBQ25JO0FBQ0E7QUFDQSxXQUFXLElBQUksSUFBSTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUF5QztBQUNwRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUNBQXlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFLElBQUksbUJBQW1CLEVBQUU7QUFDcEQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3Q0FBd0MsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlFQUF5RTtBQUNoRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0VBQStFO0FBQ3RHO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxHQUFHLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtLQUFrSztBQUNyTCxXQUFXLDJEQUEyRDtBQUN0RSxzQ0FBc0MsRUFBRTtBQUN4QyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsbUVBQW1FLEVBQUU7QUFDckU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtFQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFxRDtBQUN0RSxZQUFZLCtCQUErQiw4QkFBOEIsWUFBWSxzQ0FBc0M7QUFDM0gsVUFBVTtBQUNWLGVBQWUsUUFBUSw2REFBNkQ7QUFDcEYsZUFBZTtBQUNmLGtDQUFrQyxNQUFNO0FBQ3hDLGNBQWM7QUFDZCw0QkFBNEIsNEJBQTRCO0FBQ3hELHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0ZBQWdGLFFBQVE7QUFDeEY7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxxSkFBcUo7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYjtBQUNBLFdBQVcsaUNBQWlDLHlCQUF5QixzQkFBc0Isd0JBQXdCLG1CQUFtQixxQkFBcUIsa0NBQWtDLHNCQUFzQix3Q0FBd0MseUJBQXlCLHFCQUFxQix1QkFBdUIsb0JBQW9CLHNCQUFzQixtQkFBbUIscUJBQXFCLCtDQUErQyx1QkFBdUI7QUFDeGQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLFlBQVksU0FBUztBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxZQUFZLFNBQVM7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTLGNBQWMsY0FBYztBQUNyRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxZQUFZLFNBQVMsY0FBYyxjQUFjO0FBQ3JGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLFlBQVksU0FBUyxjQUFjLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxZQUFZLFNBQVMsY0FBYyxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTLGNBQWMsY0FBYztBQUNyRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxZQUFZLFNBQVMsY0FBYyxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTLGNBQWMsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLFlBQVksU0FBUyxjQUFjLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxZQUFZLFNBQVMsY0FBYyxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTLGNBQWMsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLFlBQVksU0FBUyxjQUFjLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxZQUFZLFNBQVMsY0FBYyxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sWUFBWSxTQUFTO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUErQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixVQUFVLDRCQUE0QixrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLEVBQUU7QUFDekc7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSw0QkFBNEIsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEVBQUUsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUyxFQUFFLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixTQUFTLGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUIseUJBQXlCLGFBQWE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDBCQUEwQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLE1BQU07QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxNQUFNO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsTUFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVMsWUFBWSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVMsWUFBWSxRQUFRO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixTQUFTO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxjQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFBb0osU0FBUztBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsdURBQXVELFFBQVE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxvQ0FBb0MsUUFBUTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxVQUFVLFlBQVksS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZUFBZTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCLHVCQUF1QixtQkFBbUIsZ0RBQWdELG1CQUFtQiwrSEFBK0gsbUJBQW1CO0FBQ25TO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0QkFBNEIsTUFBTSwrQkFBK0Isa0JBQWtCLG9GQUFvRixFQUFFO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkIsUUFBUSxvbkNBQW9DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUIsNENBQTRDLDRCQUE0Qix1QkFBdUIsMkJBQTJCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQiw0Q0FBNEMsNEJBQTRCLHVCQUF1QiwyQkFBMkI7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCLDBEQUEwRCw0QkFBNEIsdUJBQXVCLDJCQUEyQjtBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UseUNBQXlDO0FBQ3hILEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsWUFBWTtBQUMzQixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQXlEO0FBQ3pFLGlCQUFpQiwyREFBMkQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsTUFBTTtBQUNyQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsZUFBZSxPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRCx1QkFBdUIsdUJBQXVCLEtBQUssS0FBSyxHQUFHLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ3dDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QixLQUFLLEtBQUssR0FBRyxLQUFLO0FBQ2hFLDZCQUE2Qiw2Q0FBVztBQUN4QyxpQ0FBaUMsNkNBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25ELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGtDQUFrQyw2Q0FBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZDQUFZO0FBQzlDLHNDQUFzQyw2Q0FBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixrQ0FBa0MsNkNBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBaUNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVucm91dGVyLWxhbmdncmFwaC8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaHJvbWFkYkAzLjAuMTcvbm9kZV9tb2R1bGVzL2Nocm9tYWRiL2Rpc3QvY2hyb21hZGIubWpzP2E1ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19wdWJsaWNGaWVsZFxufSBmcm9tIFwiLi9jaHVuay1OU1NNVFhKSi5tanNcIjtcblxuLy8gc3JjL2Rlbm8udHNcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5EZW5vICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGNvbnN0IE9yaWdpbmFsUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdDtcbiAgY29uc3QgUGF0Y2hlZFJlcXVlc3QgPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBjbGVhbkluaXQgPSB7IC4uLmluaXQgfTtcbiAgICAgIGlmIChcImNsaWVudFwiIGluIGNsZWFuSW5pdCkge1xuICAgICAgICBkZWxldGUgY2xlYW5Jbml0LmNsaWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgT3JpZ2luYWxSZXF1ZXN0KGlucHV0LCBjbGVhbkluaXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yaWdpbmFsUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gIH07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihQYXRjaGVkUmVxdWVzdCwgT3JpZ2luYWxSZXF1ZXN0KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhdGNoZWRSZXF1ZXN0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgdmFsdWU6IE9yaWdpbmFsUmVxdWVzdC5wcm90b3R5cGUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBnbG9iYWxUaGlzLlJlcXVlc3QgPSBQYXRjaGVkUmVxdWVzdDtcbn1cblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgYmFzZVJlY29yZFNldEZpZWxkcyA9IFtcbiAgXCJpZHNcIixcbiAgXCJlbWJlZGRpbmdzXCIsXG4gIFwibWV0YWRhdGFzXCIsXG4gIFwiZG9jdW1lbnRzXCIsXG4gIFwidXJpc1wiXG5dO1xudmFyIHJlY29yZFNldEZpZWxkcyA9IFsuLi5iYXNlUmVjb3JkU2V0RmllbGRzLCBcImlkc1wiXTtcbnZhciBJbmNsdWRlRW51bSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY2x1ZGVFbnVtMikgPT4ge1xuICBJbmNsdWRlRW51bTJbXCJkaXN0YW5jZXNcIl0gPSBcImRpc3RhbmNlc1wiO1xuICBJbmNsdWRlRW51bTJbXCJkb2N1bWVudHNcIl0gPSBcImRvY3VtZW50c1wiO1xuICBJbmNsdWRlRW51bTJbXCJlbWJlZGRpbmdzXCJdID0gXCJlbWJlZGRpbmdzXCI7XG4gIEluY2x1ZGVFbnVtMltcIm1ldGFkYXRhc1wiXSA9IFwibWV0YWRhdGFzXCI7XG4gIEluY2x1ZGVFbnVtMltcInVyaXNcIl0gPSBcInVyaXNcIjtcbiAgcmV0dXJuIEluY2x1ZGVFbnVtMjtcbn0pKEluY2x1ZGVFbnVtIHx8IHt9KTtcbnZhciBHZXRSZXN1bHQgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEdldFJlc3VsdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgcmVzdWx0IGRhdGEgY29udGFpbmluZyBhbGwgZmllbGRzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZG9jdW1lbnRzLFxuICAgIGVtYmVkZGluZ3MsXG4gICAgaWRzLFxuICAgIGluY2x1ZGUsXG4gICAgbWV0YWRhdGFzLFxuICAgIHVyaXNcbiAgfSkge1xuICAgIHRoaXMuZG9jdW1lbnRzID0gZG9jdW1lbnRzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IGVtYmVkZGluZ3M7XG4gICAgdGhpcy5pZHMgPSBpZHM7XG4gICAgdGhpcy5pbmNsdWRlID0gaW5jbHVkZTtcbiAgICB0aGlzLm1ldGFkYXRhcyA9IG1ldGFkYXRhcztcbiAgICB0aGlzLnVyaXMgPSB1cmlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgcmVzdWx0IHRvIGEgcm93LWJhc2VkIGZvcm1hdCBmb3IgZWFzaWVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgaW5jbHVkZSBmaWVsZHMgYW5kIGFycmF5IG9mIHJlY29yZCBvYmplY3RzXG4gICAqL1xuICByb3dzKCkge1xuICAgIHJldHVybiB0aGlzLmlkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRvY3VtZW50OiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJkb2N1bWVudHNcIikgPyB0aGlzLmRvY3VtZW50c1tpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgIGVtYmVkZGluZzogdGhpcy5pbmNsdWRlLmluY2x1ZGVzKFwiZW1iZWRkaW5nc1wiKSA/IHRoaXMuZW1iZWRkaW5nc1tpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJtZXRhZGF0YXNcIikgPyB0aGlzLm1ldGFkYXRhc1tpbmRleF0gOiB2b2lkIDAsXG4gICAgICAgIHVyaTogdGhpcy5pbmNsdWRlLmluY2x1ZGVzKFwidXJpc1wiKSA/IHRoaXMudXJpc1tpbmRleF0gOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn07XG52YXIgUXVlcnlSZXN1bHQgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5UmVzdWx0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBxdWVyeSByZXN1bHQgZGF0YSBjb250YWluaW5nIGFsbCBmaWVsZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXN0YW5jZXMsXG4gICAgZG9jdW1lbnRzLFxuICAgIGVtYmVkZGluZ3MsXG4gICAgaWRzLFxuICAgIGluY2x1ZGUsXG4gICAgbWV0YWRhdGFzLFxuICAgIHVyaXNcbiAgfSkge1xuICAgIHRoaXMuZGlzdGFuY2VzID0gZGlzdGFuY2VzO1xuICAgIHRoaXMuZG9jdW1lbnRzID0gZG9jdW1lbnRzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IGVtYmVkZGluZ3M7XG4gICAgdGhpcy5pZHMgPSBpZHM7XG4gICAgdGhpcy5pbmNsdWRlID0gaW5jbHVkZTtcbiAgICB0aGlzLm1ldGFkYXRhcyA9IG1ldGFkYXRhcztcbiAgICB0aGlzLnVyaXMgPSB1cmlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgcXVlcnkgcmVzdWx0IHRvIGEgcm93LWJhc2VkIGZvcm1hdCBmb3IgZWFzaWVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgaW5jbHVkZSBmaWVsZHMgYW5kIHN0cnVjdHVyZWQgcXVlcnkgcmVzdWx0c1xuICAgKi9cbiAgcm93cygpIHtcbiAgICBjb25zdCBxdWVyaWVzID0gW107XG4gICAgZm9yIChsZXQgcTIgPSAwOyBxMiA8IHRoaXMuaWRzLmxlbmd0aDsgcTIrKykge1xuICAgICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuaWRzW3EyXS5tYXAoKGlkLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGRvY3VtZW50OiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJkb2N1bWVudHNcIikgPyB0aGlzLmRvY3VtZW50c1txMl1baW5kZXhdIDogdm9pZCAwLFxuICAgICAgICAgIGVtYmVkZGluZzogdGhpcy5pbmNsdWRlLmluY2x1ZGVzKFwiZW1iZWRkaW5nc1wiKSA/IHRoaXMuZW1iZWRkaW5nc1txMl1baW5kZXhdIDogdm9pZCAwLFxuICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJtZXRhZGF0YXNcIikgPyB0aGlzLm1ldGFkYXRhc1txMl1baW5kZXhdIDogdm9pZCAwLFxuICAgICAgICAgIHVyaTogdGhpcy5pbmNsdWRlLmluY2x1ZGVzKFwidXJpc1wiKSA/IHRoaXMudXJpc1txMl1baW5kZXhdIDogdm9pZCAwLFxuICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLmluY2x1ZGUuaW5jbHVkZXMoXCJkaXN0YW5jZXNcIikgPyB0aGlzLmRpc3RhbmNlc1txMl1baW5kZXhdIDogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHF1ZXJpZXMucHVzaChyZWNvcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJpZXM7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaGV5LWFwaStjbGllbnQtZmV0Y2hAMC4xMC4wX0BoZXktYXBpK29wZW5hcGktdHNAMC42Ny4zX3R5cGVzY3JpcHRANS44LjNfL25vZGVfbW9kdWxlcy9AaGV5LWFwaS9jbGllbnQtZmV0Y2gvZGlzdC9pbmRleC5qc1xudmFyIEEgPSBhc3luYyAodCwgcikgPT4ge1xuICBsZXQgZSA9IHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IHIodCkgOiByO1xuICBpZiAoZSkgcmV0dXJuIHQuc2NoZW1lID09PSBcImJlYXJlclwiID8gYEJlYXJlciAke2V9YCA6IHQuc2NoZW1lID09PSBcImJhc2ljXCIgPyBgQmFzaWMgJHtidG9hKGUpfWAgOiBlO1xufTtcbnZhciBSID0geyBib2R5U2VyaWFsaXplcjogKHQpID0+IEpTT04uc3RyaW5naWZ5KHQsIChyLCBlKSA9PiB0eXBlb2YgZSA9PSBcImJpZ2ludFwiID8gZS50b1N0cmluZygpIDogZSkgfTtcbnZhciBVID0gKHQpID0+IHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcImxhYmVsXCI6XG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgY2FzZSBcIm1hdHJpeFwiOlxuICAgICAgcmV0dXJuIFwiO1wiO1xuICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgIHJldHVybiBcIixcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiJlwiO1xuICB9XG59O1xudmFyIF8gPSAodCkgPT4ge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgcmV0dXJuIFwiLFwiO1xuICAgIGNhc2UgXCJwaXBlRGVsaW1pdGVkXCI6XG4gICAgICByZXR1cm4gXCJ8XCI7XG4gICAgY2FzZSBcInNwYWNlRGVsaW1pdGVkXCI6XG4gICAgICByZXR1cm4gXCIlMjBcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiLFwiO1xuICB9XG59O1xudmFyIEQgPSAodCkgPT4ge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICByZXR1cm4gXCI7XCI7XG4gICAgY2FzZSBcInNpbXBsZVwiOlxuICAgICAgcmV0dXJuIFwiLFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCImXCI7XG4gIH1cbn07XG52YXIgTyA9ICh7IGFsbG93UmVzZXJ2ZWQ6IHQsIGV4cGxvZGU6IHIsIG5hbWU6IGUsIHN0eWxlOiBhLCB2YWx1ZTogaSB9KSA9PiB7XG4gIGlmICghcikge1xuICAgIGxldCBzID0gKHQgPyBpIDogaS5tYXAoKGwpID0+IGVuY29kZVVSSUNvbXBvbmVudChsKSkpLmpvaW4oXyhhKSk7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgICAgcmV0dXJuIGAuJHtzfWA7XG4gICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgIHJldHVybiBgOyR7ZX09JHtzfWA7XG4gICAgICBjYXNlIFwic2ltcGxlXCI6XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke2V9PSR7c31gO1xuICAgIH1cbiAgfVxuICBsZXQgbyA9IFUoYSksIG4gPSBpLm1hcCgocykgPT4gYSA9PT0gXCJsYWJlbFwiIHx8IGEgPT09IFwic2ltcGxlXCIgPyB0ID8gcyA6IGVuY29kZVVSSUNvbXBvbmVudChzKSA6IHkoeyBhbGxvd1Jlc2VydmVkOiB0LCBuYW1lOiBlLCB2YWx1ZTogcyB9KSkuam9pbihvKTtcbiAgcmV0dXJuIGEgPT09IFwibGFiZWxcIiB8fCBhID09PSBcIm1hdHJpeFwiID8gbyArIG4gOiBuO1xufTtcbnZhciB5ID0gKHsgYWxsb3dSZXNlcnZlZDogdCwgbmFtZTogciwgdmFsdWU6IGUgfSkgPT4ge1xuICBpZiAoZSA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIkRlZXBseS1uZXN0ZWQgYXJyYXlzL29iamVjdHMgYXJlblxcdTIwMTl0IHN1cHBvcnRlZC4gUHJvdmlkZSB5b3VyIG93biBgcXVlcnlTZXJpYWxpemVyKClgIHRvIGhhbmRsZSB0aGVzZS5cIik7XG4gIHJldHVybiBgJHtyfT0ke3QgPyBlIDogZW5jb2RlVVJJQ29tcG9uZW50KGUpfWA7XG59O1xudmFyIHEgPSAoeyBhbGxvd1Jlc2VydmVkOiB0LCBleHBsb2RlOiByLCBuYW1lOiBlLCBzdHlsZTogYSwgdmFsdWU6IGkgfSkgPT4ge1xuICBpZiAoaSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBgJHtlfT0ke2kudG9JU09TdHJpbmcoKX1gO1xuICBpZiAoYSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgIXIpIHtcbiAgICBsZXQgcyA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtmLCB1XSkgPT4ge1xuICAgICAgcyA9IFsuLi5zLCBmLCB0ID8gdSA6IGVuY29kZVVSSUNvbXBvbmVudCh1KV07XG4gICAgfSk7XG4gICAgbGV0IGwgPSBzLmpvaW4oXCIsXCIpO1xuICAgIHN3aXRjaCAoYSkge1xuICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgcmV0dXJuIGAke2V9PSR7bH1gO1xuICAgICAgY2FzZSBcImxhYmVsXCI6XG4gICAgICAgIHJldHVybiBgLiR7bH1gO1xuICAgICAgY2FzZSBcIm1hdHJpeFwiOlxuICAgICAgICByZXR1cm4gYDske2V9PSR7bH1gO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfVxuICB9XG4gIGxldCBvID0gRChhKSwgbiA9IE9iamVjdC5lbnRyaWVzKGkpLm1hcCgoW3MsIGxdKSA9PiB5KHsgYWxsb3dSZXNlcnZlZDogdCwgbmFtZTogYSA9PT0gXCJkZWVwT2JqZWN0XCIgPyBgJHtlfVske3N9XWAgOiBzLCB2YWx1ZTogbCB9KSkuam9pbihvKTtcbiAgcmV0dXJuIGEgPT09IFwibGFiZWxcIiB8fCBhID09PSBcIm1hdHJpeFwiID8gbyArIG4gOiBuO1xufTtcbnZhciBIID0gL1xce1tee31dK1xcfS9nO1xudmFyIEIgPSAoeyBwYXRoOiB0LCB1cmw6IHIgfSkgPT4ge1xuICBsZXQgZSA9IHIsIGEgPSByLm1hdGNoKEgpO1xuICBpZiAoYSkgZm9yIChsZXQgaSBvZiBhKSB7XG4gICAgbGV0IG8gPSBmYWxzZSwgbiA9IGkuc3Vic3RyaW5nKDEsIGkubGVuZ3RoIC0gMSksIHMgPSBcInNpbXBsZVwiO1xuICAgIG4uZW5kc1dpdGgoXCIqXCIpICYmIChvID0gdHJ1ZSwgbiA9IG4uc3Vic3RyaW5nKDAsIG4ubGVuZ3RoIC0gMSkpLCBuLnN0YXJ0c1dpdGgoXCIuXCIpID8gKG4gPSBuLnN1YnN0cmluZygxKSwgcyA9IFwibGFiZWxcIikgOiBuLnN0YXJ0c1dpdGgoXCI7XCIpICYmIChuID0gbi5zdWJzdHJpbmcoMSksIHMgPSBcIm1hdHJpeFwiKTtcbiAgICBsZXQgbCA9IHRbbl07XG4gICAgaWYgKGwgPT0gbnVsbCkgY29udGludWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobCkpIHtcbiAgICAgIGUgPSBlLnJlcGxhY2UoaSwgTyh7IGV4cGxvZGU6IG8sIG5hbWU6IG4sIHN0eWxlOiBzLCB2YWx1ZTogbCB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGUgPSBlLnJlcGxhY2UoaSwgcSh7IGV4cGxvZGU6IG8sIG5hbWU6IG4sIHN0eWxlOiBzLCB2YWx1ZTogbCB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHMgPT09IFwibWF0cml4XCIpIHtcbiAgICAgIGUgPSBlLnJlcGxhY2UoaSwgYDske3koeyBuYW1lOiBuLCB2YWx1ZTogbCB9KX1gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgZiA9IGVuY29kZVVSSUNvbXBvbmVudChzID09PSBcImxhYmVsXCIgPyBgLiR7bH1gIDogbCk7XG4gICAgZSA9IGUucmVwbGFjZShpLCBmKTtcbiAgfVxuICByZXR1cm4gZTtcbn07XG52YXIgRSA9ICh7IGFsbG93UmVzZXJ2ZWQ6IHQsIGFycmF5OiByLCBvYmplY3Q6IGUgfSA9IHt9KSA9PiAoaSkgPT4ge1xuICBsZXQgbyA9IFtdO1xuICBpZiAoaSAmJiB0eXBlb2YgaSA9PSBcIm9iamVjdFwiKSBmb3IgKGxldCBuIGluIGkpIHtcbiAgICBsZXQgcyA9IGlbbl07XG4gICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocykpIHtcbiAgICAgICAgbyA9IFsuLi5vLCBPKHsgYWxsb3dSZXNlcnZlZDogdCwgZXhwbG9kZTogdHJ1ZSwgbmFtZTogbiwgc3R5bGU6IFwiZm9ybVwiLCB2YWx1ZTogcywgLi4uciB9KV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbyA9IFsuLi5vLCBxKHsgYWxsb3dSZXNlcnZlZDogdCwgZXhwbG9kZTogdHJ1ZSwgbmFtZTogbiwgc3R5bGU6IFwiZGVlcE9iamVjdFwiLCB2YWx1ZTogcywgLi4uZSB9KV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbyA9IFsuLi5vLCB5KHsgYWxsb3dSZXNlcnZlZDogdCwgbmFtZTogbiwgdmFsdWU6IHMgfSldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gby5qb2luKFwiJlwiKTtcbn07XG52YXIgUCA9ICh0KSA9PiB7XG4gIGlmICghdCkgcmV0dXJuIFwic3RyZWFtXCI7XG4gIGxldCByID0gdC5zcGxpdChcIjtcIilbMF0/LnRyaW0oKTtcbiAgaWYgKHIpIHtcbiAgICBpZiAoci5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSB8fCByLmVuZHNXaXRoKFwiK2pzb25cIikpIHJldHVybiBcImpzb25cIjtcbiAgICBpZiAociA9PT0gXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpIHJldHVybiBcImZvcm1EYXRhXCI7XG4gICAgaWYgKFtcImFwcGxpY2F0aW9uL1wiLCBcImF1ZGlvL1wiLCBcImltYWdlL1wiLCBcInZpZGVvL1wiXS5zb21lKChlKSA9PiByLnN0YXJ0c1dpdGgoZSkpKSByZXR1cm4gXCJibG9iXCI7XG4gICAgaWYgKHIuc3RhcnRzV2l0aChcInRleHQvXCIpKSByZXR1cm4gXCJ0ZXh0XCI7XG4gIH1cbn07XG52YXIgSSA9IGFzeW5jICh7IHNlY3VyaXR5OiB0LCAuLi5yIH0pID0+IHtcbiAgZm9yIChsZXQgZSBvZiB0KSB7XG4gICAgbGV0IGEgPSBhd2FpdCBBKGUsIHIuYXV0aCk7XG4gICAgaWYgKCFhKSBjb250aW51ZTtcbiAgICBsZXQgaSA9IGUubmFtZSA/PyBcIkF1dGhvcml6YXRpb25cIjtcbiAgICBzd2l0Y2ggKGUuaW4pIHtcbiAgICAgIGNhc2UgXCJxdWVyeVwiOlxuICAgICAgICByLnF1ZXJ5IHx8IChyLnF1ZXJ5ID0ge30pLCByLnF1ZXJ5W2ldID0gYTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29va2llXCI6XG4gICAgICAgIHIuaGVhZGVycy5hcHBlbmQoXCJDb29raWVcIiwgYCR7aX09JHthfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIuaGVhZGVycy5zZXQoaSwgYSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbn07XG52YXIgUyA9ICh0KSA9PiBXKHsgYmFzZVVybDogdC5iYXNlVXJsLCBwYXRoOiB0LnBhdGgsIHF1ZXJ5OiB0LnF1ZXJ5LCBxdWVyeVNlcmlhbGl6ZXI6IHR5cGVvZiB0LnF1ZXJ5U2VyaWFsaXplciA9PSBcImZ1bmN0aW9uXCIgPyB0LnF1ZXJ5U2VyaWFsaXplciA6IEUodC5xdWVyeVNlcmlhbGl6ZXIpLCB1cmw6IHQudXJsIH0pO1xudmFyIFcgPSAoeyBiYXNlVXJsOiB0LCBwYXRoOiByLCBxdWVyeTogZSwgcXVlcnlTZXJpYWxpemVyOiBhLCB1cmw6IGkgfSkgPT4ge1xuICBsZXQgbyA9IGkuc3RhcnRzV2l0aChcIi9cIikgPyBpIDogYC8ke2l9YCwgbiA9ICh0ID8/IFwiXCIpICsgbztcbiAgciAmJiAobiA9IEIoeyBwYXRoOiByLCB1cmw6IG4gfSkpO1xuICBsZXQgcyA9IGUgPyBhKGUpIDogXCJcIjtcbiAgcmV0dXJuIHMuc3RhcnRzV2l0aChcIj9cIikgJiYgKHMgPSBzLnN1YnN0cmluZygxKSksIHMgJiYgKG4gKz0gYD8ke3N9YCksIG47XG59O1xudmFyIEMgPSAodCwgcikgPT4ge1xuICBsZXQgZSA9IHsgLi4udCwgLi4uciB9O1xuICByZXR1cm4gZS5iYXNlVXJsPy5lbmRzV2l0aChcIi9cIikgJiYgKGUuYmFzZVVybCA9IGUuYmFzZVVybC5zdWJzdHJpbmcoMCwgZS5iYXNlVXJsLmxlbmd0aCAtIDEpKSwgZS5oZWFkZXJzID0geCh0LmhlYWRlcnMsIHIuaGVhZGVycyksIGU7XG59O1xudmFyIHggPSAoLi4udCkgPT4ge1xuICBsZXQgciA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAobGV0IGUgb2YgdCkge1xuICAgIGlmICghZSB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKSBjb250aW51ZTtcbiAgICBsZXQgYSA9IGUgaW5zdGFuY2VvZiBIZWFkZXJzID8gZS5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhlKTtcbiAgICBmb3IgKGxldCBbaSwgb10gb2YgYSkgaWYgKG8gPT09IG51bGwpIHIuZGVsZXRlKGkpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIGZvciAobGV0IG4gb2Ygbykgci5hcHBlbmQoaSwgbik7XG4gICAgZWxzZSBvICE9PSB2b2lkIDAgJiYgci5zZXQoaSwgdHlwZW9mIG8gPT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KG8pIDogbyk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xudmFyIGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZm5zXCIpO1xuICAgIHRoaXMuX2ZucyA9IFtdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2ZucyA9IFtdO1xuICB9XG4gIGV4aXN0cyhyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zucy5pbmRleE9mKHIpICE9PSAtMTtcbiAgfVxuICBlamVjdChyKSB7XG4gICAgbGV0IGUgPSB0aGlzLl9mbnMuaW5kZXhPZihyKTtcbiAgICBlICE9PSAtMSAmJiAodGhpcy5fZm5zID0gWy4uLnRoaXMuX2Zucy5zbGljZSgwLCBlKSwgLi4udGhpcy5fZm5zLnNsaWNlKGUgKyAxKV0pO1xuICB9XG4gIHVzZShyKSB7XG4gICAgdGhpcy5fZm5zID0gWy4uLnRoaXMuX2Zucywgcl07XG4gIH1cbn07XG52YXIgVCA9ICgpID0+ICh7IGVycm9yOiBuZXcgaCgpLCByZXF1ZXN0OiBuZXcgaCgpLCByZXNwb25zZTogbmV3IGgoKSB9KTtcbnZhciBOID0gRSh7IGFsbG93UmVzZXJ2ZWQ6IGZhbHNlLCBhcnJheTogeyBleHBsb2RlOiB0cnVlLCBzdHlsZTogXCJmb3JtXCIgfSwgb2JqZWN0OiB7IGV4cGxvZGU6IHRydWUsIHN0eWxlOiBcImRlZXBPYmplY3RcIiB9IH0pO1xudmFyIFEgPSB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG52YXIgdyA9ICh0ID0ge30pID0+ICh7IC4uLlIsIGhlYWRlcnM6IFEsIHBhcnNlQXM6IFwiYXV0b1wiLCBxdWVyeVNlcmlhbGl6ZXI6IE4sIC4uLnQgfSk7XG52YXIgSiA9ICh0ID0ge30pID0+IHtcbiAgbGV0IHIgPSBDKHcoKSwgdCksIGUgPSAoKSA9PiAoeyAuLi5yIH0pLCBhID0gKG4pID0+IChyID0gQyhyLCBuKSwgZSgpKSwgaSA9IFQoKSwgbyA9IGFzeW5jIChuKSA9PiB7XG4gICAgbGV0IHMgPSB7IC4uLnIsIC4uLm4sIGZldGNoOiBuLmZldGNoID8/IHIuZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaCwgaGVhZGVyczogeChyLmhlYWRlcnMsIG4uaGVhZGVycykgfTtcbiAgICBzLnNlY3VyaXR5ICYmIGF3YWl0IEkoeyAuLi5zLCBzZWN1cml0eTogcy5zZWN1cml0eSB9KSwgcy5ib2R5ICYmIHMuYm9keVNlcmlhbGl6ZXIgJiYgKHMuYm9keSA9IHMuYm9keVNlcmlhbGl6ZXIocy5ib2R5KSksIChzLmJvZHkgPT09IHZvaWQgMCB8fCBzLmJvZHkgPT09IFwiXCIpICYmIHMuaGVhZGVycy5kZWxldGUoXCJDb250ZW50LVR5cGVcIik7XG4gICAgbGV0IGwgPSBTKHMpLCBmID0geyByZWRpcmVjdDogXCJmb2xsb3dcIiwgLi4ucyB9LCB1ID0gbmV3IFJlcXVlc3QobCwgZik7XG4gICAgZm9yIChsZXQgcCBvZiBpLnJlcXVlc3QuX2ZucykgdSA9IGF3YWl0IHAodSwgcyk7XG4gICAgbGV0IGsgPSBzLmZldGNoLCBjID0gYXdhaXQgayh1KTtcbiAgICBmb3IgKGxldCBwIG9mIGkucmVzcG9uc2UuX2ZucykgYyA9IGF3YWl0IHAoYywgdSwgcyk7XG4gICAgbGV0IG0gPSB7IHJlcXVlc3Q6IHUsIHJlc3BvbnNlOiBjIH07XG4gICAgaWYgKGMub2spIHtcbiAgICAgIGlmIChjLnN0YXR1cyA9PT0gMjA0IHx8IGMuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSA9PT0gXCIwXCIpIHJldHVybiB7IGRhdGE6IHt9LCAuLi5tIH07XG4gICAgICBsZXQgcCA9IChzLnBhcnNlQXMgPT09IFwiYXV0b1wiID8gUChjLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpKSA6IHMucGFyc2VBcykgPz8gXCJqc29uXCI7XG4gICAgICBpZiAocCA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIHsgZGF0YTogYy5ib2R5LCAuLi5tIH07XG4gICAgICBsZXQgYiA9IGF3YWl0IGNbcF0oKTtcbiAgICAgIHJldHVybiBwID09PSBcImpzb25cIiAmJiAocy5yZXNwb25zZVZhbGlkYXRvciAmJiBhd2FpdCBzLnJlc3BvbnNlVmFsaWRhdG9yKGIpLCBzLnJlc3BvbnNlVHJhbnNmb3JtZXIgJiYgKGIgPSBhd2FpdCBzLnJlc3BvbnNlVHJhbnNmb3JtZXIoYikpKSwgeyBkYXRhOiBiLCAuLi5tIH07XG4gICAgfVxuICAgIGxldCBnID0gYXdhaXQgYy50ZXh0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGcgPSBKU09OLnBhcnNlKGcpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBsZXQgZCA9IGc7XG4gICAgZm9yIChsZXQgcCBvZiBpLmVycm9yLl9mbnMpIGQgPSBhd2FpdCBwKGcsIGMsIHUsIHMpO1xuICAgIGlmIChkID0gZCB8fCB7fSwgcy50aHJvd09uRXJyb3IpIHRocm93IGQ7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGQsIC4uLm0gfTtcbiAgfTtcbiAgcmV0dXJuIHsgYnVpbGRVcmw6IFMsIGNvbm5lY3Q6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIkNPTk5FQ1RcIiB9KSwgZGVsZXRlOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJERUxFVEVcIiB9KSwgZ2V0OiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJHRVRcIiB9KSwgZ2V0Q29uZmlnOiBlLCBoZWFkOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJIRUFEXCIgfSksIGludGVyY2VwdG9yczogaSwgb3B0aW9uczogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiT1BUSU9OU1wiIH0pLCBwYXRjaDogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiUEFUQ0hcIiB9KSwgcG9zdDogKG4pID0+IG8oeyAuLi5uLCBtZXRob2Q6IFwiUE9TVFwiIH0pLCBwdXQ6IChuKSA9PiBvKHsgLi4ubiwgbWV0aG9kOiBcIlBVVFwiIH0pLCByZXF1ZXN0OiBvLCBzZXRDb25maWc6IGEsIHRyYWNlOiAobikgPT4gbyh7IC4uLm4sIG1ldGhvZDogXCJUUkFDRVwiIH0pIH07XG59O1xuXG4vLyBzcmMvYXBpL2NsaWVudC5nZW4udHNcbnZhciBjbGllbnQgPSBKKHcoe1xuICBiYXNlVXJsOiBcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFwiLFxuICB0aHJvd09uRXJyb3I6IHRydWVcbn0pKTtcblxuLy8gc3JjL2FwaS9zZGsuZ2VuLnRzXG52YXIgRGVmYXVsdFNlcnZpY2UgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgdXNlcidzIGlkZW50aXR5LCB0ZW5hbnQsIGFuZCBkYXRhYmFzZXMuXG4gICAqL1xuICBzdGF0aWMgZ2V0VXNlcklkZW50aXR5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi9hdXRoL2lkZW50aXR5XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGNvbGxlY3Rpb24gYnkgQ2hyb21hIFJlc291cmNlIE5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0Q29sbGVjdGlvbkJ5Q3JuKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL2NvbGxlY3Rpb25zL3tjcm59XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlYWx0aCBjaGVjayBlbmRwb2ludCB0aGF0IHJldHVybnMgMjAwIGlmIHRoZSBzZXJ2ZXIgYW5kIGV4ZWN1dG9yIGFyZSByZWFkeVxuICAgKi9cbiAgc3RhdGljIGhlYWx0aGNoZWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi9oZWFsdGhjaGVja1wiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIZWFydGJlYXQgZW5kcG9pbnQgdGhhdCByZXR1cm5zIGEgbmFub3NlY29uZCB0aW1lc3RhbXAgb2YgdGhlIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHN0YXRpYyBoZWFydGJlYXQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL2hlYXJ0YmVhdFwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmUtZmxpZ2h0IGNoZWNrcyBlbmRwb2ludCByZXBvcnRpbmcgYmFzaWMgcmVhZGluZXNzIGluZm8uXG4gICAqL1xuICBzdGF0aWMgcHJlRmxpZ2h0Q2hlY2tzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi9wcmUtZmxpZ2h0LWNoZWNrc1wiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBlbmRwb2ludCBhbGxvd2luZyBhdXRob3JpemVkIHVzZXJzIHRvIHJlc2V0IHRoZSBkYXRhYmFzZS5cbiAgICovXG4gIHN0YXRpYyByZXNldChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3Jlc2V0XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGVuYW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRlbmFudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50c1wiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBleGlzdGluZyB0ZW5hbnQgYnkgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXRUZW5hbnQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50X25hbWV9XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGVuYW50IGJ5IG5hbWUuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlVGVuYW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucGF0Y2goe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50X25hbWV9XCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZGF0YWJhc2VzIGZvciBhIGdpdmVuIHRlbmFudC5cbiAgICovXG4gIHN0YXRpYyBsaXN0RGF0YWJhc2VzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZ2V0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4gdGVuYW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZURhdGFiYXNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlc1wiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIHNwZWNpZmljIGRhdGFiYXNlLlxuICAgKi9cbiAgc3RhdGljIGRlbGV0ZURhdGFiYXNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkuZGVsZXRlKHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX1cIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgc3BlY2lmaWMgZGF0YWJhc2UgYnkgbmFtZS5cbiAgICovXG4gIHN0YXRpYyBnZXREYXRhYmFzZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBjb2xsZWN0aW9ucyBpbiB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlLlxuICAgKi9cbiAgc3RhdGljIGxpc3RDb2xsZWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sbGVjdGlvbiB1bmRlciB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUNvbGxlY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnNcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBjb2xsZWN0aW9uIGluIGEgZ2l2ZW4gZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgZGVsZXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmRlbGV0ZSh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfVwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBjb2xsZWN0aW9uIGJ5IElEIG9yIG5hbWUuXG4gICAqL1xuICBzdGF0aWMgZ2V0Q29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfVwiLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb24ncyBuYW1lIG9yIG1ldGFkYXRhLlxuICAgKi9cbiAgc3RhdGljIHVwZGF0ZUNvbGxlY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wdXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH1cIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgcmVjb3JkcyB0byBhIGNvbGxlY3Rpb24uXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvbkFkZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vYWRkXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIGEgY29sbGVjdGlvbi5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uQ291bnQob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5nZXQoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vY291bnRcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyByZWNvcmRzIGluIGEgY29sbGVjdGlvbi4gQ2FuIGZpbHRlciBieSBJRHMgb3IgbWV0YWRhdGEuXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvbkRlbGV0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vZGVsZXRlXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGb3JrcyBhbiBleGlzdGluZyBjb2xsZWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGZvcmtDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9mb3JrXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcmVjb3JkcyBmcm9tIGEgY29sbGVjdGlvbiBieSBJRCBvciBtZXRhZGF0YSBmaWx0ZXIuXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvbkdldChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLnBvc3Qoe1xuICAgICAgdXJsOiBcIi9hcGkvdjIvdGVuYW50cy97dGVuYW50fS9kYXRhYmFzZXMve2RhdGFiYXNlfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9pZH0vZ2V0XCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBRdWVyeSBhIGNvbGxlY3Rpb24gaW4gYSB2YXJpZXR5IG9mIHdheXMsIGluY2x1ZGluZyB2ZWN0b3Igc2VhcmNoLCBtZXRhZGF0YSBmaWx0ZXJpbmcsIGFuZCBmdWxsLXRleHQgc2VhcmNoXG4gICAqL1xuICBzdGF0aWMgY29sbGVjdGlvblF1ZXJ5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS9xdWVyeVwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIHJlY29yZHMgZnJvbSBhIGNvbGxlY3Rpb24gd2l0aCBoeWJyaWQgY3JpdGVyaWFzLlxuICAgKi9cbiAgc3RhdGljIGNvbGxlY3Rpb25TZWFyY2gob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gY2xpZW50KS5wb3N0KHtcbiAgICAgIHVybDogXCIvYXBpL3YyL3RlbmFudHMve3RlbmFudH0vZGF0YWJhc2VzL3tkYXRhYmFzZX0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25faWR9L3NlYXJjaFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyByZWNvcmRzIGluIGEgY29sbGVjdGlvbiBieSBJRC5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uVXBkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS91cGRhdGVcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwc2VydHMgcmVjb3JkcyBpbiBhIGNvbGxlY3Rpb24gKGNyZWF0ZSBpZiBub3QgZXhpc3RzLCBvdGhlcndpc2UgdXBkYXRlKS5cbiAgICovXG4gIHN0YXRpYyBjb2xsZWN0aW9uVXBzZXJ0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IGNsaWVudCkucG9zdCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX2lkfS91cHNlcnRcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbGxlY3Rpb25zIGluIGEgZ2l2ZW4gZGF0YWJhc2UuXG4gICAqL1xuICBzdGF0aWMgY291bnRDb2xsZWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi90ZW5hbnRzL3t0ZW5hbnR9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L2NvbGxlY3Rpb25zX2NvdW50XCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhlIHNlcnZlci5cbiAgICovXG4gIHN0YXRpYyB2ZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyBjbGllbnQpLmdldCh7XG4gICAgICB1cmw6IFwiL2FwaS92Mi92ZXJzaW9uXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMudHNcbnZhciBDaHJvbWFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihuYW1lLCBtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG59O1xudmFyIENocm9tYUNvbm5lY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYUNvbm5lY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYVNlcnZlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hU2VydmVyRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFDbGllbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYUNsaWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hVW5hdXRob3JpemVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFBdXRoRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFGb3JiaWRkZW5FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYUZvcmJpZGRlbkVycm9yXCI7XG4gIH1cbn07XG52YXIgQ2hyb21hTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYU5vdEZvdW5kRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFWYWx1ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hVmFsdWVFcnJvclwiO1xuICB9XG59O1xudmFyIEludmFsaWRDb2xsZWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkQ29sbGVjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkQXJndW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIENocm9tYVVuaXF1ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMubmFtZSA9IFwiQ2hyb21hVW5pcXVlRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFRdW90YUV4Y2VlZGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5uYW1lID0gXCJDaHJvbWFRdW90YUV4Y2VlZGVkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDaHJvbWFSYXRlTGltaXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLm5hbWUgPSBcIkNocm9tYVJhdGVMaW1pdEVycm9yXCI7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVFcnJvckJ5VHlwZSh0eXBlLCBtZXNzYWdlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJJbnZhbGlkQ29sbGVjdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQ29sbGVjdGlvbkVycm9yKG1lc3NhZ2UpO1xuICAgIGNhc2UgXCJJbnZhbGlkQXJndW1lbnRFcnJvclwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihtZXNzYWdlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBERUZBVUxUX1RFTkFOVCA9IFwiZGVmYXVsdF90ZW5hbnRcIjtcbnZhciBERUZBVUxUX0RBVEFCQVNFID0gXCJkZWZhdWx0X2RhdGFiYXNlXCI7XG52YXIgZGVmYXVsdEFkbWluQ2xpZW50QXJncyA9IHtcbiAgaG9zdDogXCJsb2NhbGhvc3RcIixcbiAgcG9ydDogOGUzLFxuICBzc2w6IGZhbHNlXG59O1xudmFyIGRlZmF1bHRDaHJvbWFDbGllbnRBcmdzID0ge1xuICAuLi5kZWZhdWx0QWRtaW5DbGllbnRBcmdzLFxuICB0ZW5hbnQ6IERFRkFVTFRfVEVOQU5ULFxuICBkYXRhYmFzZTogREVGQVVMVF9EQVRBQkFTRVxufTtcbnZhciBub3JtYWxpemVNZXRob2QgPSAobWV0aG9kKSA9PiB7XG4gIGlmIChtZXRob2QpIHtcbiAgICBzd2l0Y2ggKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgICAgY2FzZSBcIlBPU1RcIjpcbiAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICByZXR1cm4gXCJQVVRcIjtcbiAgICAgIGNhc2UgXCJERUxFVEVcIjpcbiAgICAgICAgcmV0dXJuIFwiREVMRVRFXCI7XG4gICAgICBjYXNlIFwiSEVBRFwiOlxuICAgICAgICByZXR1cm4gXCJIRUFEXCI7XG4gICAgICBjYXNlIFwiQ09OTkVDVFwiOlxuICAgICAgICByZXR1cm4gXCJDT05ORUNUXCI7XG4gICAgICBjYXNlIFwiT1BUSU9OU1wiOlxuICAgICAgICByZXR1cm4gXCJPUFRJT05TXCI7XG4gICAgICBjYXNlIFwiUEFUQ0hcIjpcbiAgICAgICAgcmV0dXJuIFwiUEFUQ0hcIjtcbiAgICAgIGNhc2UgXCJUUkFDRVwiOlxuICAgICAgICByZXR1cm4gXCJUUkFDRVwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG52YXIgdmFsaWRhdGVSZWNvcmRTZXRMZW5ndGhDb25zaXN0ZW5jeSA9IChyZWNvcmRTZXQpID0+IHtcbiAgY29uc3QgbGVuZ3RocyA9IE9iamVjdC5lbnRyaWVzKHJlY29yZFNldCkuZmlsdGVyKFxuICAgIChbZmllbGQsIHZhbHVlXSkgPT4gcmVjb3JkU2V0RmllbGRzLmluY2x1ZGVzKGZpZWxkKSAmJiB2YWx1ZSAhPT0gdm9pZCAwXG4gICkubWFwKChbZmllbGQsIHZhbHVlXSkgPT4gW2ZpZWxkLCB2YWx1ZS5sZW5ndGhdKTtcbiAgaWYgKGxlbmd0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgQXQgbGVhc3Qgb25lIG9mICR7cmVjb3JkU2V0RmllbGRzLmpvaW4oXCIsIFwiKX0gbXVzdCBiZSBwcm92aWRlZGBcbiAgICApO1xuICB9XG4gIGNvbnN0IHplcm9MZW5ndGggPSBsZW5ndGhzLmZpbHRlcigoW18yLCBsZW5ndGhdKSA9PiBsZW5ndGggPT09IDApLm1hcCgoW2ZpZWxkLCBfMl0pID0+IGZpZWxkKTtcbiAgaWYgKHplcm9MZW5ndGgubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYE5vbi1lbXB0eSBsaXN0cyBhcmUgcmVxdWlyZWQgZm9yICR7emVyb0xlbmd0aC5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH1cbiAgaWYgKG5ldyBTZXQobGVuZ3Rocy5tYXAoKFtfMiwgbGVuZ3RoXSkgPT4gbGVuZ3RoKSkuc2l6ZSA+IDEpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBVbmVxdWFsIGxlbmd0aHMgZm9yIGZpZWxkcyAke2xlbmd0aHMubWFwKChbZmllbGQsIF8yXSkgPT4gZmllbGQpLmpvaW4oXCIsIFwiKX1gXG4gICAgKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUVtYmVkZGluZ3MgPSAoe1xuICBlbWJlZGRpbmdzLFxuICBmaWVsZE5hbWUgPSBcImVtYmVkZGluZ3NcIlxufSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZW1iZWRkaW5ncykpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBFeHBlY3RlZCAnJHtmaWVsZE5hbWV9JyB0byBiZSBhbiBhcnJheSwgYnV0IGdvdCAke3R5cGVvZiBlbWJlZGRpbmdzfWBcbiAgICApO1xuICB9XG4gIGlmIChlbWJlZGRpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBlbWJlZGRpbmdzIHRvIGJlIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGl0ZW1cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFlbWJlZGRpbmdzLmZpbHRlcigoZSkgPT4gZS5ldmVyeSgobikgPT4gdHlwZW9mIG4gPT09IFwibnVtYmVyXCIpKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBlYWNoIGVtYmVkZGluZyB0byBiZSBhbiBhcnJheSBvZiBudW1iZXJzXCJcbiAgICApO1xuICB9XG4gIGVtYmVkZGluZ3MuZm9yRWFjaCgoZW1iZWRkaW5nLCBpKSA9PiB7XG4gICAgaWYgKGVtYmVkZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgZWFjaCBlbWJlZGRpbmcgdG8gYmUgYSBub24tZW1wdHkgYXJyYXkgb2YgbnVtYmVycywgYnV0IGdvdCBhbiBlbXB0eSBhcnJheSBhdCBpbmRleCAke2l9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZURvY3VtZW50cyA9ICh7XG4gIGRvY3VtZW50cyxcbiAgbnVsbGFibGUgPSBmYWxzZSxcbiAgZmllbGROYW1lID0gXCJkb2N1bWVudHNcIlxufSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jdW1lbnRzKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICcke2ZpZWxkTmFtZX0nIHRvIGJlIGFuIGFycmF5LCBidXQgZ290ICR7dHlwZW9mIGRvY3VtZW50c31gXG4gICAgKTtcbiAgfVxuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICcke2ZpZWxkTmFtZX0nIHRvIGJlIGEgbm9uLWVtcHR5IGxpc3RgXG4gICAgKTtcbiAgfVxuICBkb2N1bWVudHMuZm9yRWFjaCgoZG9jdW1lbnQpID0+IHtcbiAgICBpZiAoIW51bGxhYmxlICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJzdHJpbmdcIiAmJiAhZG9jdW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgZWFjaCBkb2N1bWVudCB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke3R5cGVvZiBkb2N1bWVudH1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlSURzID0gKGlkcykgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICdpZHMnIHRvIGJlIGFuIGFycmF5LCBidXQgZ290ICR7dHlwZW9mIGlkc31gXG4gICAgKTtcbiAgfVxuICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2lkcycgdG8gYmUgYSBub24tZW1wdHkgbGlzdFwiKTtcbiAgfVxuICBjb25zdCBub25TdHJpbmdzID0gaWRzLm1hcCgoaWQsIGkpID0+IFtpZCwgaV0pLmZpbHRlcigoW2lkLCBfMl0pID0+IHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikubWFwKChbXzIsIGldKSA9PiBpKTtcbiAgaWYgKG5vblN0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEZvdW5kIG5vbi1zdHJpbmcgSURzIGF0ICR7bm9uU3RyaW5ncy5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGR1cGxpY2F0ZXMgPSBpZHMuZmlsdGVyKChpZCkgPT4ge1xuICAgIGlmIChzZWVuLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgc2Vlbi5hZGQoaWQpO1xuICB9KTtcbiAgbGV0IG1lc3NhZ2UgPSBcIkV4cGVjdGVkIElEcyB0byBiZSB1bmlxdWUsIGJ1dCBmb3VuZCBkdXBsaWNhdGVzIG9mXCI7XG4gIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDAgJiYgZHVwbGljYXRlcy5sZW5ndGggPD0gNSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKGAke21lc3NhZ2V9ICR7ZHVwbGljYXRlcy5qb2luKFwiLCBcIil9YCk7XG4gIH1cbiAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYCR7bWVzc2FnZX0gJHtkdXBsaWNhdGVzLnNsaWNlKDAsIDUpLmpvaW4oXCIsIFwiKX0sIC4uLiwgJHtkdXBsaWNhdGVzLnNsaWNlKGR1cGxpY2F0ZXMubGVuZ3RoIC0gNSkuam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG59O1xudmFyIHZhbGlkYXRlU3BhcnNlVmVjdG9yID0gKHYpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgXCJpbmRpY2VzXCIgaW4gdiAmJiBcInZhbHVlc1wiIGluIHYgJiYgQXJyYXkuaXNBcnJheSh2LmluZGljZXMpICYmIHYuaW5kaWNlcy5ldmVyeSgoZSkgPT4gdHlwZW9mIGUgPT09IFwibnVtYmVyXCIpICYmIEFycmF5LmlzQXJyYXkodi52YWx1ZXMpICYmIHYudmFsdWVzLmV2ZXJ5KChlKSA9PiB0eXBlb2YgZSA9PT0gXCJudW1iZXJcIik7XG59O1xudmFyIHZhbGlkYXRlTWV0YWRhdGEgPSAobWV0YWRhdGEpID0+IHtcbiAgaWYgKCFtZXRhZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXMobWV0YWRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgbWV0YWRhdGEgdG8gYmUgbm9uLWVtcHR5XCIpO1xuICB9XG4gIGlmICghT2JqZWN0LnZhbHVlcyhtZXRhZGF0YSkuZXZlcnkoXG4gICAgKHYpID0+IHYgPT09IG51bGwgfHwgdiA9PT0gdm9pZCAwIHx8IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIiB8fCB2YWxpZGF0ZVNwYXJzZVZlY3Rvcih2KVxuICApKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIG1ldGFkYXRhIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIFNwYXJzZVZlY3Rvciwgb3IgbnVsbGFibGVcIlxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVNZXRhZGF0YXMgPSAobWV0YWRhdGFzKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtZXRhZGF0YXMpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgbWV0YWRhdGFzIHRvIGJlIGFuIGFycmF5LCBidXQgZ290ICR7dHlwZW9mIG1ldGFkYXRhc31gXG4gICAgKTtcbiAgfVxuICBtZXRhZGF0YXMuZm9yRWFjaCgobWV0YWRhdGEpID0+IHZhbGlkYXRlTWV0YWRhdGEobWV0YWRhdGEpKTtcbn07XG52YXIgdmFsaWRhdGVCYXNlUmVjb3JkU2V0ID0gKHtcbiAgcmVjb3JkU2V0LFxuICB1cGRhdGUgPSBmYWxzZSxcbiAgZW1iZWRkaW5nc0ZpZWxkID0gXCJlbWJlZGRpbmdzXCIsXG4gIGRvY3VtZW50c0ZpZWxkID0gXCJkb2N1bWVudHNcIlxufSkgPT4ge1xuICBpZiAoIXJlY29yZFNldC5lbWJlZGRpbmdzICYmICFyZWNvcmRTZXQuZG9jdW1lbnRzICYmICF1cGRhdGUpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBBdCBsZWFzdCBvbmUgb2YgJyR7ZW1iZWRkaW5nc0ZpZWxkfScgYW5kICcke2RvY3VtZW50c0ZpZWxkfScgbXVzdCBiZSBwcm92aWRlZGBcbiAgICApO1xuICB9XG4gIGlmIChyZWNvcmRTZXQuZW1iZWRkaW5ncykge1xuICAgIHZhbGlkYXRlRW1iZWRkaW5ncyh7XG4gICAgICBlbWJlZGRpbmdzOiByZWNvcmRTZXQuZW1iZWRkaW5ncyxcbiAgICAgIGZpZWxkTmFtZTogZW1iZWRkaW5nc0ZpZWxkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY29yZFNldC5kb2N1bWVudHMpIHtcbiAgICB2YWxpZGF0ZURvY3VtZW50cyh7XG4gICAgICBkb2N1bWVudHM6IHJlY29yZFNldC5kb2N1bWVudHMsXG4gICAgICBmaWVsZE5hbWU6IGRvY3VtZW50c0ZpZWxkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlY29yZFNldC5tZXRhZGF0YXMpIHtcbiAgICB2YWxpZGF0ZU1ldGFkYXRhcyhyZWNvcmRTZXQubWV0YWRhdGFzKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZU1heEJhdGNoU2l6ZSA9IChyZWNvcmRTZXRMZW5ndGgsIG1heEJhdGNoU2l6ZSkgPT4ge1xuICBpZiAocmVjb3JkU2V0TGVuZ3RoID4gbWF4QmF0Y2hTaXplKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgUmVjb3JkIHNldCBsZW5ndGggJHtyZWNvcmRTZXRMZW5ndGh9IGV4Y2VlZHMgbWF4IGJhdGNoIHNpemUgJHttYXhCYXRjaFNpemV9YFxuICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVXaGVyZSA9ICh3aGVyZSkgPT4ge1xuICBpZiAodHlwZW9mIHdoZXJlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXCJFeHBlY3RlZCB3aGVyZSB0byBiZSBhIG5vbi1lbXB0eSBvYmplY3RcIik7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGggIT0gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICd3aGVyZScgdG8gaGF2ZSBleGFjdGx5IG9uZSBvcGVyYXRvciwgYnV0IGdvdCAke09iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGh9YFxuICAgICk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMod2hlcmUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkgIT09IFwiJGFuZFwiICYmIGtleSAhPT0gXCIkb3JcIiAmJiBrZXkgIT09IFwiJGluXCIgJiYga2V5ICE9PSBcIiRuaW5cIiAmJiAhW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiLCBcIm9iamVjdFwiXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkICd3aGVyZScgdmFsdWUgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYW4gb3BlcmF0b3IgZXhwcmVzc2lvbiwgYnV0IGdvdCAke3ZhbHVlfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJGFuZFwiIHx8IGtleSA9PT0gXCIkb3JcIikge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPD0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJ3doZXJlJyB2YWx1ZSBmb3IgJGFuZCBvciAkb3IgdG8gYmUgYSBsaXN0IG9mICd3aGVyZScgZXhwcmVzc2lvbnMsIGJ1dCBnb3QgJHt2YWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh3MikgPT4gdmFsaWRhdGVXaGVyZSh3MikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYXRvciBleHByZXNzaW9uIHRvIGhhdmUgb25lIG9wZXJhdG9yLCBidXQgZ290ICR7dmFsdWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgW29wZXJhdG9yLCBvcGVyYW5kXSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKVswXTtcbiAgICAgIGlmIChbXCIkZ3RcIiwgXCIkZ3RlXCIsIFwiJGx0XCIsIFwiJGx0ZVwiXS5pbmNsdWRlcyhvcGVyYXRvcikgJiYgdHlwZW9mIG9wZXJhbmQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIG9wZXJhbmQgdmFsdWUgdG8gYmUgYSBudW1iZXIgZm9yICR7b3BlcmF0b3J9LCBidXQgZ290ICR7dHlwZW9mIG9wZXJhbmR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFtcIiRpblwiLCBcIiRuaW5cIl0uaW5jbHVkZXMob3BlcmF0b3IpICYmICFBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYW5kIHZhbHVlIHRvIGJlIGFuIGFycmF5IGZvciAke29wZXJhdG9yfSwgYnV0IGdvdCAke29wZXJhbmR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFbXCIkZ3RcIiwgXCIkZ3RlXCIsIFwiJGx0XCIsIFwiJGx0ZVwiLCBcIiRuZVwiLCBcIiRlcVwiLCBcIiRpblwiLCBcIiRuaW5cIl0uaW5jbHVkZXMoXG4gICAgICAgIG9wZXJhdG9yXG4gICAgICApKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBvcGVyYXRvciB0byBiZSBvbmUgb2YgJGd0LCAkZ3RlLCAkbHQsICRsdGUsICRuZSwgJGVxLCAkaW4sICRuaW4sIGJ1dCBnb3QgJHtvcGVyYXRvcn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIVtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZW9mIG9wZXJhbmQpICYmICFBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgb3BlcmFuZCB2YWx1ZSB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBhIGxpc3Qgb2YgdGhvc2UgdHlwZXNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3BlcmFuZCkgJiYgKG9wZXJhbmQubGVuZ3RoID09PSAwIHx8ICFvcGVyYW5kLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gdHlwZW9mIG9wZXJhbmRbMF0pKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkICd3aGVyZScgb3BlcmFuZCB2YWx1ZSB0byBiZSBhIG5vbi1lbXB0eSBsaXN0IGFuZCBhbGwgdmFsdWVzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlV2hlcmVEb2N1bWVudCA9ICh3aGVyZURvY3VtZW50KSA9PiB7XG4gIGlmICh0eXBlb2Ygd2hlcmVEb2N1bWVudCAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCAnd2hlcmVEb2N1bWVudCcgdG8gYmUgYSBub24tZW1wdHkgb2JqZWN0XCJcbiAgICApO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyh3aGVyZURvY3VtZW50KS5sZW5ndGggIT0gMSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICd3aGVyZURvY3VtZW50JyB0byBoYXZlIGV4YWN0bHkgb25lIG9wZXJhdG9yLCBidXQgZ290ICR7d2hlcmVEb2N1bWVudH1gXG4gICAgKTtcbiAgfVxuICBjb25zdCBbb3BlcmF0b3IsIG9wZXJhbmRdID0gT2JqZWN0LmVudHJpZXMod2hlcmVEb2N1bWVudClbMF07XG4gIGlmICghW1xuICAgIFwiJGNvbnRhaW5zXCIsXG4gICAgXCIkbm90X2NvbnRhaW5zXCIsXG4gICAgXCIkbWF0Y2hlc1wiLFxuICAgIFwiJG5vdF9tYXRjaGVzXCIsXG4gICAgXCIkcmVnZXhcIixcbiAgICBcIiRub3RfcmVnZXhcIixcbiAgICBcIiRhbmRcIixcbiAgICBcIiRvclwiXG4gIF0uaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgJ3doZXJlRG9jdW1lbnQnIG9wZXJhdG9yIHRvIGJlIG9uZSBvZiAkY29udGFpbnMsICRub3RfY29udGFpbnMsICRtYXRjaGVzLCAkbm90X21hdGNoZXMsICRyZWdleCwgJG5vdF9yZWdleCwgJGFuZCwgb3IgJG9yLCBidXQgZ290ICR7b3BlcmF0b3J9YFxuICAgICk7XG4gIH1cbiAgaWYgKG9wZXJhdG9yID09PSBcIiRhbmRcIiB8fCBvcGVyYXRvciA9PT0gXCIkb3JcIikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcGVyYW5kKSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBvcGVyYW5kIGZvciAke29wZXJhdG9yfSB0byBiZSBhIGxpc3Qgb2YgJ3doZXJlRG9jdW1lbnQnIGV4cHJlc3Npb25zLCBidXQgZ290ICR7b3BlcmFuZH1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3BlcmFuZC5sZW5ndGggPD0gMSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCAnd2hlcmVEb2N1bWVudCcgb3BlcmFuZCBmb3IgJHtvcGVyYXRvcn0gdG8gYmUgYSBsaXN0IHdpdGggYXQgbGVhc3QgdHdvICd3aGVyZURvY3VtZW50JyBleHByZXNzaW9uc2BcbiAgICAgICk7XG4gICAgfVxuICAgIG9wZXJhbmQuZm9yRWFjaCgoaXRlbSkgPT4gdmFsaWRhdGVXaGVyZURvY3VtZW50KGl0ZW0pKTtcbiAgfVxuICBpZiAoKG9wZXJhbmQgPT09IFwiJGNvbnRhaW5zXCIgfHwgb3BlcmFuZCA9PT0gXCIkbm90X2NvbnRhaW5zXCIgfHwgb3BlcmFuZCA9PT0gXCIkcmVnZXhcIiB8fCBvcGVyYW5kID09PSBcIiRub3RfcmVnZXhcIikgJiYgKHR5cGVvZiBvcGVyYXRvciAhPT0gXCJzdHJpbmdcIiB8fCBvcGVyYXRvci5sZW5ndGggPT09IDApKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgb3BlcmFuZCBmb3IgJHtvcGVyYXRvcn0gdG8gYmUgYSBub24gZW1wdHkgc3RyaW5nLCBidXQgZ290ICR7b3BlcmFuZH1gXG4gICAgKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUluY2x1ZGUgPSAoe1xuICBpbmNsdWRlLFxuICBleGNsdWRlXG59KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbmNsdWRlKSkge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2luY2x1ZGUnIHRvIGJlIGEgbm9uLWVtcHR5IGFycmF5XCIpO1xuICB9XG4gIGNvbnN0IHZhbGlkVmFsdWVzID0gT2JqZWN0LmtleXMoSW5jbHVkZUVudW0pO1xuICBpbmNsdWRlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgJ2luY2x1ZGUnIGl0ZW1zIHRvIGJlIHN0cmluZ3NcIik7XG4gICAgfVxuICAgIGlmICghdmFsaWRWYWx1ZXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgJ2luY2x1ZGUnIGl0ZW1zIHRvIGJlIG9uZSBvZiAke3ZhbGlkVmFsdWVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9LCBidXQgZ290ICR7aXRlbX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZXhjbHVkZT8uaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKGAke2l0ZW19IGlzIG5vdCBhbGxvd2VkIGZvciB0aGlzIG9wZXJhdGlvbmApO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlTlJlc3VsdHMgPSAoblJlc3VsdHMpID0+IHtcbiAgaWYgKHR5cGVvZiBuUmVzdWx0cyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBDaHJvbWFWYWx1ZUVycm9yKFxuICAgICAgYEV4cGVjdGVkICduUmVzdWx0cycgdG8gYmUgYSBudW1iZXIsIGJ1dCBnb3QgJHt0eXBlb2YgblJlc3VsdHN9YFxuICAgICk7XG4gIH1cbiAgaWYgKG5SZXN1bHRzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcIk51bWJlciBvZiByZXF1ZXN0ZWQgcmVzdWx0cyBoYXMgdG8gcG9zaXRpdmVcIik7XG4gIH1cbn07XG52YXIgcGFyc2VDb25uZWN0aW9uUGF0aCA9IChwYXRoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoKTtcbiAgICBjb25zdCBzc2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgY29uc3QgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNzbCxcbiAgICAgIGhvc3QsXG4gICAgICBwb3J0OiBOdW1iZXIocG9ydClcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihgSW52YWxpZCBVUkw6ICR7cGF0aH1gKTtcbiAgfVxufTtcbnZhciBwYWNrRW1iZWRkaW5nID0gKGVtYmVkZGluZykgPT4ge1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZW1iZWRkaW5nLmxlbmd0aCAqIDQpO1xuICBjb25zdCB2aWV3ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVtYmVkZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZpZXdbaV0gPSBlbWJlZGRpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgZW1iZWRkaW5nc1RvQmFzZTY0Qnl0ZXMgPSAoZW1iZWRkaW5ncykgPT4ge1xuICByZXR1cm4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHBhY2tFbWJlZGRpbmcoZW1iZWRkaW5nKTtcbiAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBBcnJheS5mcm9tKFxuICAgICAgdWludDhBcnJheSxcbiAgICAgIChieXRlKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpXG4gICAgKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBidG9hKGJpbmFyeVN0cmluZyk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2VtYmVkZGluZy1mdW5jdGlvbi50c1xudmFyIGtub3duRW1iZWRkaW5nRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciByZWdpc3RlckVtYmVkZGluZ0Z1bmN0aW9uID0gKG5hbWUsIGZuKSA9PiB7XG4gIGlmIChrbm93bkVtYmVkZGluZ0Z1bmN0aW9ucy5oYXMobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIGBFbWJlZGRpbmcgZnVuY3Rpb24gd2l0aCBuYW1lICR7bmFtZX0gaXMgYWxyZWFkeSByZWdpc3RlcmVkLmBcbiAgICApO1xuICB9XG4gIGtub3duRW1iZWRkaW5nRnVuY3Rpb25zLnNldChuYW1lLCBmbik7XG59O1xudmFyIGdldEVtYmVkZGluZ0Z1bmN0aW9uID0gYXN5bmMgKGNvbGxlY3Rpb25OYW1lLCBlZkNvbmZpZykgPT4ge1xuICBpZiAoIWVmQ29uZmlnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYE5vIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChlZkNvbmZpZy50eXBlID09PSBcImxlZ2FjeVwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYE5vIGVtYmVkZGluZyBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9LiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IG5hbWUgPSBlZkNvbmZpZy5uYW1lO1xuICBjb25zdCBlbWJlZGRpbmdGdW5jdGlvbiA9IGtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmdldChuYW1lKTtcbiAgaWYgKCFlbWJlZGRpbmdGdW5jdGlvbikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBDb2xsZWN0aW9uICR7Y29sbGVjdGlvbk5hbWV9IHdhcyBjcmVhdGVkIHdpdGggdGhlICR7ZW1iZWRkaW5nRnVuY3Rpb259IGVtYmVkZGluZyBmdW5jdGlvbi4gSG93ZXZlciwgdGhlIEBjaHJvbWEtY29yZS8ke2VtYmVkZGluZ0Z1bmN0aW9ufSBwYWNrYWdlIGlzIG5vdCBpbnN0YWxsLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseSwgb3IgaW5zdGFsbCB0aGUgQGNocm9tYS1jb3JlLyR7ZW1iZWRkaW5nRnVuY3Rpb259IHBhY2thZ2UuYFxuICAgICk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgY29uc3RydWN0b3JDb25maWcgPSBlZkNvbmZpZy50eXBlID09PSBcImtub3duXCIgPyBlZkNvbmZpZy5jb25maWcgOiB7fTtcbiAgdHJ5IHtcbiAgICBpZiAoZW1iZWRkaW5nRnVuY3Rpb24uYnVpbGRGcm9tQ29uZmlnKSB7XG4gICAgICByZXR1cm4gZW1iZWRkaW5nRnVuY3Rpb24uYnVpbGRGcm9tQ29uZmlnKGNvbnN0cnVjdG9yQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEVtYmVkZGluZyBmdW5jdGlvbiAke25hbWV9IGRvZXMgbm90IGRlZmluZSBhICdidWlsZEZyb21Db25maWcnIGZ1bmN0aW9uLiAnYWRkJyBhbmQgJ3F1ZXJ5JyB3aWxsIGZhaWwgdW5sZXNzIHlvdSBwcm92aWRlIHRoZW0gZW1iZWRkaW5ncyBkaXJlY3RseS5gXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEVtYmVkZGluZyBmdW5jdGlvbiAke25hbWV9IGZhaWxlZCB0byBidWlsZCB3aXRoIGNvbmZpZzogJHtjb25zdHJ1Y3RvckNvbmZpZ30uICdhZGQnIGFuZCAncXVlcnknIHdpbGwgZmFpbCB1bmxlc3MgeW91IHByb3ZpZGUgdGhlbSBlbWJlZGRpbmdzIGRpcmVjdGx5LiBFcnJvcjogJHtlfWBcbiAgICApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG52YXIgc2VyaWFsaXplRW1iZWRkaW5nRnVuY3Rpb24gPSAoe1xuICBlbWJlZGRpbmdGdW5jdGlvbixcbiAgY29uZmlnRW1iZWRkaW5nRnVuY3Rpb25cbn0pID0+IHtcbiAgaWYgKGVtYmVkZGluZ0Z1bmN0aW9uICYmIGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkVtYmVkZGluZyBmdW5jdGlvbiBwcm92aWRlZCB3aGVuIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgY29sbGVjdGlvbiBjb25maWd1cmF0aW9uXCJcbiAgICApO1xuICB9XG4gIGlmICghZW1iZWRkaW5nRnVuY3Rpb24gJiYgIWNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBlZiA9IGVtYmVkZGluZ0Z1bmN0aW9uIHx8IGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uO1xuICBpZiAoIWVmLmdldENvbmZpZyB8fCAhZWYubmFtZSB8fCAhZWYuY29uc3RydWN0b3IuYnVpbGRGcm9tQ29uZmlnKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJsZWdhY3lcIiB9O1xuICB9XG4gIGlmIChlZi52YWxpZGF0ZUNvbmZpZykgZWYudmFsaWRhdGVDb25maWcoZWYuZ2V0Q29uZmlnKCkpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGVmLm5hbWUsXG4gICAgdHlwZTogXCJrbm93blwiLFxuICAgIGNvbmZpZzogZWYuZ2V0Q29uZmlnKClcbiAgfTtcbn07XG52YXIgZ2V0RGVmYXVsdEVGQ29uZmlnID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCJAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZFwiKTtcbiAgICBpZiAoIWtub3duRW1iZWRkaW5nRnVuY3Rpb25zLmhhcyhuZXcgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uKCkubmFtZSkpIHtcbiAgICAgIHJlZ2lzdGVyRW1iZWRkaW5nRnVuY3Rpb24oXCJkZWZhdWx0XCIsIERlZmF1bHRFbWJlZGRpbmdGdW5jdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCBpbnN0YW50aWF0ZSBhIGNvbGxlY3Rpb24gd2l0aCB0aGUgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uLiBQbGVhc2UgaW5zdGFsbCBAY2hyb21hLWNvcmUvZGVmYXVsdC1lbWJlZCwgb3IgcHJvdmlkZSBhIGRpZmZlcmVudCBlbWJlZGRpbmcgZnVuY3Rpb25cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImRlZmF1bHRcIixcbiAgICB0eXBlOiBcImtub3duXCIsXG4gICAgY29uZmlnOiB7fVxuICB9O1xufTtcblxuLy8gc3JjL2NvbGxlY3Rpb24tY29uZmlndXJhdGlvbi50c1xudmFyIHByb2Nlc3NDcmVhdGVDb2xsZWN0aW9uQ29uZmlnID0gYXN5bmMgKHtcbiAgY29uZmlndXJhdGlvbixcbiAgZW1iZWRkaW5nRnVuY3Rpb24sXG4gIG1ldGFkYXRhXG59KSA9PiB7XG4gIGlmIChjb25maWd1cmF0aW9uPy5obnN3ICYmIGNvbmZpZ3VyYXRpb24/LnNwYW5uKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkNhbm5vdCBzcGVjaWZ5IGJvdGggSE5TVyBhbmQgU1BBTk4gY29uZmlndXJhdGlvbnNcIlxuICAgICk7XG4gIH1cbiAgbGV0IGVtYmVkZGluZ0Z1bmN0aW9uQ29uZmlndXJhdGlvbiA9IHNlcmlhbGl6ZUVtYmVkZGluZ0Z1bmN0aW9uKHtcbiAgICBlbWJlZGRpbmdGdW5jdGlvbjogZW1iZWRkaW5nRnVuY3Rpb24gPz8gdm9pZCAwLFxuICAgIGNvbmZpZ0VtYmVkZGluZ0Z1bmN0aW9uOiBjb25maWd1cmF0aW9uPy5lbWJlZGRpbmdGdW5jdGlvblxuICB9KTtcbiAgaWYgKCFlbWJlZGRpbmdGdW5jdGlvbkNvbmZpZ3VyYXRpb24gJiYgZW1iZWRkaW5nRnVuY3Rpb24gIT09IG51bGwpIHtcbiAgICBlbWJlZGRpbmdGdW5jdGlvbkNvbmZpZ3VyYXRpb24gPSBhd2FpdCBnZXREZWZhdWx0RUZDb25maWcoKTtcbiAgfVxuICBjb25zdCBvdmVyYWxsRWYgPSBlbWJlZGRpbmdGdW5jdGlvbiB8fCBjb25maWd1cmF0aW9uPy5lbWJlZGRpbmdGdW5jdGlvbjtcbiAgaWYgKG92ZXJhbGxFZiAmJiBvdmVyYWxsRWYuZGVmYXVsdFNwYWNlICYmIG92ZXJhbGxFZi5zdXBwb3J0ZWRTcGFjZXMpIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbj8uaG5zdyA9PT0gdm9pZCAwICYmIGNvbmZpZ3VyYXRpb24/LnNwYW5uID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChtZXRhZGF0YSA9PT0gdm9pZCAwIHx8IG1ldGFkYXRhPy5bXCJobnN3OnNwYWNlXCJdID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uKSBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaG5zdyA9IHsgc3BhY2U6IG92ZXJhbGxFZi5kZWZhdWx0U3BhY2UoKSB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uZmlndXJhdGlvbj8uaG5zdyAmJiAhY29uZmlndXJhdGlvbi5obnN3LnNwYWNlICYmIG92ZXJhbGxFZi5kZWZhdWx0U3BhY2UpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uaG5zdy5zcGFjZSA9IG92ZXJhbGxFZi5kZWZhdWx0U3BhY2UoKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24/LnNwYW5uICYmICFjb25maWd1cmF0aW9uLnNwYW5uLnNwYWNlICYmIG92ZXJhbGxFZi5kZWZhdWx0U3BhY2UpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uc3Bhbm4uc3BhY2UgPSBvdmVyYWxsRWYuZGVmYXVsdFNwYWNlKCk7XG4gICAgfVxuICAgIGlmIChvdmVyYWxsRWYuc3VwcG9ydGVkU3BhY2VzKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWRTcGFjZXMgPSBvdmVyYWxsRWYuc3VwcG9ydGVkU3BhY2VzKCk7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbj8uaG5zdz8uc3BhY2UgJiYgIXN1cHBvcnRlZFNwYWNlcy5pbmNsdWRlcyhjb25maWd1cmF0aW9uLmhuc3cuc3BhY2UpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgU3BhY2UgJyR7Y29uZmlndXJhdGlvbi5obnN3LnNwYWNlfScgaXMgbm90IHN1cHBvcnRlZCBieSBlbWJlZGRpbmcgZnVuY3Rpb24gJyR7b3ZlcmFsbEVmLm5hbWUgfHwgXCJ1bmtub3duXCJ9Jy4gU3VwcG9ydGVkIHNwYWNlczogJHtzdXBwb3J0ZWRTcGFjZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWd1cmF0aW9uPy5zcGFubj8uc3BhY2UgJiYgIXN1cHBvcnRlZFNwYWNlcy5pbmNsdWRlcyhjb25maWd1cmF0aW9uLnNwYW5uLnNwYWNlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFNwYWNlICcke2NvbmZpZ3VyYXRpb24uc3Bhbm4uc3BhY2V9JyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGVtYmVkZGluZyBmdW5jdGlvbiAnJHtvdmVyYWxsRWYubmFtZSB8fCBcInVua25vd25cIn0nLiBTdXBwb3J0ZWQgc3BhY2VzOiAke3N1cHBvcnRlZFNwYWNlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFjb25maWd1cmF0aW9uPy5obnN3ICYmICFjb25maWd1cmF0aW9uPy5zcGFubiAmJiBtZXRhZGF0YSAmJiB0eXBlb2YgbWV0YWRhdGFbXCJobnN3OnNwYWNlXCJdID09PSBcInN0cmluZ1wiICYmICFzdXBwb3J0ZWRTcGFjZXMuaW5jbHVkZXMobWV0YWRhdGFbXCJobnN3OnNwYWNlXCJdKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFNwYWNlICcke21ldGFkYXRhW1wiaG5zdzpzcGFjZVwiXX0nIGZyb20gbWV0YWRhdGEgaXMgbm90IHN1cHBvcnRlZCBieSBlbWJlZGRpbmcgZnVuY3Rpb24gJyR7b3ZlcmFsbEVmLm5hbWUgfHwgXCJ1bmtub3duXCJ9Jy4gU3VwcG9ydGVkIHNwYWNlczogJHtzdXBwb3J0ZWRTcGFjZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5jb25maWd1cmF0aW9uIHx8IHt9LFxuICAgIGVtYmVkZGluZ19mdW5jdGlvbjogZW1iZWRkaW5nRnVuY3Rpb25Db25maWd1cmF0aW9uXG4gIH07XG59O1xudmFyIHByb2Nlc3NVcGRhdGVDb2xsZWN0aW9uQ29uZmlnID0gYXN5bmMgKHtcbiAgY29sbGVjdGlvbk5hbWUsXG4gIGN1cnJlbnRDb25maWd1cmF0aW9uLFxuICBjdXJyZW50RW1iZWRkaW5nRnVuY3Rpb24sXG4gIG5ld0NvbmZpZ3VyYXRpb25cbn0pID0+IHtcbiAgaWYgKG5ld0NvbmZpZ3VyYXRpb24uaG5zdyAmJiB0eXBlb2YgbmV3Q29uZmlndXJhdGlvbi5obnN3ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICBcIkludmFsaWQgSE5TVyBjb25maWcgcHJvdmlkZWQgaW4gVXBkYXRlQ29sbGVjdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICk7XG4gIH1cbiAgaWYgKG5ld0NvbmZpZ3VyYXRpb24uc3Bhbm4gJiYgdHlwZW9mIG5ld0NvbmZpZ3VyYXRpb24uc3Bhbm4gIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgIFwiSW52YWxpZCBTUEFOTiBjb25maWcgcHJvdmlkZWQgaW4gVXBkYXRlQ29sbGVjdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgZW1iZWRkaW5nRnVuY3Rpb24gPSBjdXJyZW50RW1iZWRkaW5nRnVuY3Rpb24gfHwgYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oXG4gICAgY29sbGVjdGlvbk5hbWUsXG4gICAgY3VycmVudENvbmZpZ3VyYXRpb24uZW1iZWRkaW5nRnVuY3Rpb24gPz8gdm9pZCAwXG4gICk7XG4gIGNvbnN0IG5ld0VtYmVkZGluZ0Z1bmN0aW9uID0gbmV3Q29uZmlndXJhdGlvbi5lbWJlZGRpbmdGdW5jdGlvbjtcbiAgaWYgKGVtYmVkZGluZ0Z1bmN0aW9uICYmIGVtYmVkZGluZ0Z1bmN0aW9uLnZhbGlkYXRlQ29uZmlnVXBkYXRlICYmIG5ld0VtYmVkZGluZ0Z1bmN0aW9uICYmIG5ld0VtYmVkZGluZ0Z1bmN0aW9uLmdldENvbmZpZykge1xuICAgIGVtYmVkZGluZ0Z1bmN0aW9uLnZhbGlkYXRlQ29uZmlnVXBkYXRlKG5ld0VtYmVkZGluZ0Z1bmN0aW9uLmdldENvbmZpZygpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZUNvbmZpZ3VyYXRpb246IHtcbiAgICAgIGhuc3c6IG5ld0NvbmZpZ3VyYXRpb24uaG5zdyxcbiAgICAgIHNwYW5uOiBuZXdDb25maWd1cmF0aW9uLnNwYW5uLFxuICAgICAgZW1iZWRkaW5nX2Z1bmN0aW9uOiBuZXdFbWJlZGRpbmdGdW5jdGlvbiAmJiBzZXJpYWxpemVFbWJlZGRpbmdGdW5jdGlvbih7IGVtYmVkZGluZ0Z1bmN0aW9uOiBuZXdFbWJlZGRpbmdGdW5jdGlvbiB9KVxuICAgIH0sXG4gICAgdXBkYXRlRW1iZWRkaW5nRnVuY3Rpb246IG5ld0VtYmVkZGluZ0Z1bmN0aW9uXG4gIH07XG59O1xuXG4vLyBzcmMvY29sbGVjdGlvbi50c1xudmFyIENvbGxlY3Rpb25JbXBsID0gY2xhc3MgX0NvbGxlY3Rpb25JbXBsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ29sbGVjdGlvbkFQSUltcGwgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIGNvbGxlY3Rpb24gQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2hyb21hQ2xpZW50LFxuICAgIGFwaUNsaWVudCxcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhLFxuICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgZW1iZWRkaW5nRnVuY3Rpb25cbiAgfSkge1xuICAgIHRoaXMuY2hyb21hQ2xpZW50ID0gY2hyb21hQ2xpZW50O1xuICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMuX2NvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIHRoaXMuX2VtYmVkZGluZ0Z1bmN0aW9uID0gZW1iZWRkaW5nRnVuY3Rpb247XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG4gIGdldCBjb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWd1cmF0aW9uO1xuICB9XG4gIHNldCBjb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICB0aGlzLl9jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgfVxuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICB9XG4gIHNldCBtZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cbiAgZ2V0IGVtYmVkZGluZ0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbjtcbiAgfVxuICBzZXQgZW1iZWRkaW5nRnVuY3Rpb24oZW1iZWRkaW5nRnVuY3Rpb24pIHtcbiAgICB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbiA9IGVtYmVkZGluZ0Z1bmN0aW9uO1xuICB9XG4gIGFzeW5jIHBhdGgoKSB7XG4gICAgY29uc3QgY2xpZW50UGF0aCA9IGF3YWl0IHRoaXMuY2hyb21hQ2xpZW50Ll9wYXRoKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNsaWVudFBhdGgsXG4gICAgICBjb2xsZWN0aW9uX2lkOiB0aGlzLmlkXG4gICAgfTtcbiAgfVxuICBhc3luYyBlbWJlZChkb2N1bWVudHMpIHtcbiAgICBpZiAoIXRoaXMuX2VtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgXCJFbWJlZGRpbmcgZnVuY3Rpb24gbXVzdCBiZSBkZWZpbmVkIGZvciBvcGVyYXRpb25zIHJlcXVpcmluZyBlbWJlZGRpbmdzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fZW1iZWRkaW5nRnVuY3Rpb24uZ2VuZXJhdGUoZG9jdW1lbnRzKTtcbiAgfVxuICBhc3luYyBwcmVwYXJlUmVjb3Jkcyh7XG4gICAgcmVjb3JkU2V0LFxuICAgIHVwZGF0ZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCBtYXhCYXRjaFNpemUgPSBhd2FpdCB0aGlzLmNocm9tYUNsaWVudC5nZXRNYXhCYXRjaFNpemUoKTtcbiAgICB2YWxpZGF0ZVJlY29yZFNldExlbmd0aENvbnNpc3RlbmN5KHJlY29yZFNldCk7XG4gICAgdmFsaWRhdGVJRHMocmVjb3JkU2V0Lmlkcyk7XG4gICAgdmFsaWRhdGVCYXNlUmVjb3JkU2V0KHsgcmVjb3JkU2V0LCB1cGRhdGUgfSk7XG4gICAgdmFsaWRhdGVNYXhCYXRjaFNpemUocmVjb3JkU2V0Lmlkcy5sZW5ndGgsIG1heEJhdGNoU2l6ZSk7XG4gICAgaWYgKCFyZWNvcmRTZXQuZW1iZWRkaW5ncyAmJiByZWNvcmRTZXQuZG9jdW1lbnRzKSB7XG4gICAgICByZWNvcmRTZXQuZW1iZWRkaW5ncyA9IGF3YWl0IHRoaXMuZW1iZWQocmVjb3JkU2V0LmRvY3VtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHByZXBhcmVkUmVjb3JkU2V0ID0geyAuLi5yZWNvcmRTZXQgfTtcbiAgICBjb25zdCBiYXNlNjRTdXBwb3J0ZWQgPSBhd2FpdCB0aGlzLmNocm9tYUNsaWVudC5zdXBwb3J0c0Jhc2U2NEVuY29kaW5nKCk7XG4gICAgaWYgKGJhc2U2NFN1cHBvcnRlZCAmJiByZWNvcmRTZXQuZW1iZWRkaW5ncykge1xuICAgICAgcHJlcGFyZWRSZWNvcmRTZXQuZW1iZWRkaW5ncyA9IGVtYmVkZGluZ3NUb0Jhc2U2NEJ5dGVzKFxuICAgICAgICByZWNvcmRTZXQuZW1iZWRkaW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXBhcmVkUmVjb3JkU2V0O1xuICB9XG4gIHZhbGlkYXRlR2V0KGluY2x1ZGUsIGlkcywgd2hlcmUsIHdoZXJlRG9jdW1lbnQpIHtcbiAgICB2YWxpZGF0ZUluY2x1ZGUoeyBpbmNsdWRlLCBleGNsdWRlOiBbXCJkaXN0YW5jZXNcIl0gfSk7XG4gICAgaWYgKGlkcykgdmFsaWRhdGVJRHMoaWRzKTtcbiAgICBpZiAod2hlcmUpIHZhbGlkYXRlV2hlcmUod2hlcmUpO1xuICAgIGlmICh3aGVyZURvY3VtZW50KSB2YWxpZGF0ZVdoZXJlRG9jdW1lbnQod2hlcmVEb2N1bWVudCk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVF1ZXJ5KHJlY29yZFNldCwgaW5jbHVkZSwgaWRzLCB3aGVyZSwgd2hlcmVEb2N1bWVudCwgblJlc3VsdHMpIHtcbiAgICB2YWxpZGF0ZUJhc2VSZWNvcmRTZXQoe1xuICAgICAgcmVjb3JkU2V0LFxuICAgICAgZW1iZWRkaW5nc0ZpZWxkOiBcInF1ZXJ5RW1iZWRkaW5nc1wiLFxuICAgICAgZG9jdW1lbnRzRmllbGQ6IFwicXVlcnlUZXh0c1wiXG4gICAgfSk7XG4gICAgdmFsaWRhdGVJbmNsdWRlKHsgaW5jbHVkZSB9KTtcbiAgICBpZiAoaWRzKSB2YWxpZGF0ZUlEcyhpZHMpO1xuICAgIGlmICh3aGVyZSkgdmFsaWRhdGVXaGVyZSh3aGVyZSk7XG4gICAgaWYgKHdoZXJlRG9jdW1lbnQpIHZhbGlkYXRlV2hlcmVEb2N1bWVudCh3aGVyZURvY3VtZW50KTtcbiAgICBpZiAoblJlc3VsdHMpIHZhbGlkYXRlTlJlc3VsdHMoblJlc3VsdHMpO1xuICAgIGxldCBlbWJlZGRpbmdzO1xuICAgIGlmICghcmVjb3JkU2V0LmVtYmVkZGluZ3MpIHtcbiAgICAgIGVtYmVkZGluZ3MgPSBhd2FpdCB0aGlzLmVtYmVkKHJlY29yZFNldC5kb2N1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWJlZGRpbmdzID0gcmVjb3JkU2V0LmVtYmVkZGluZ3M7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZWNvcmRTZXQsXG4gICAgICBpZHMsXG4gICAgICBlbWJlZGRpbmdzXG4gICAgfTtcbiAgfVxuICB2YWxpZGF0ZURlbGV0ZShpZHMsIHdoZXJlLCB3aGVyZURvY3VtZW50KSB7XG4gICAgaWYgKGlkcykgdmFsaWRhdGVJRHMoaWRzKTtcbiAgICBpZiAod2hlcmUpIHZhbGlkYXRlV2hlcmUod2hlcmUpO1xuICAgIGlmICh3aGVyZURvY3VtZW50KSB2YWxpZGF0ZVdoZXJlRG9jdW1lbnQod2hlcmVEb2N1bWVudCk7XG4gIH1cbiAgYXN5bmMgY291bnQoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uQ291bnQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgYWRkKHtcbiAgICBpZHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBtZXRhZGF0YXMsXG4gICAgZG9jdW1lbnRzLFxuICAgIHVyaXNcbiAgfSkge1xuICAgIGNvbnN0IHJlY29yZFNldCA9IHtcbiAgICAgIGlkcyxcbiAgICAgIGVtYmVkZGluZ3MsXG4gICAgICBkb2N1bWVudHMsXG4gICAgICBtZXRhZGF0YXMsXG4gICAgICB1cmlzXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlY29yZFNldCA9IGF3YWl0IHRoaXMucHJlcGFyZVJlY29yZHMoeyByZWNvcmRTZXQgfSk7XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvbkFkZCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkczogcHJlcGFyZWRSZWNvcmRTZXQuaWRzLFxuICAgICAgICBlbWJlZGRpbmdzOiBwcmVwYXJlZFJlY29yZFNldC5lbWJlZGRpbmdzLFxuICAgICAgICBkb2N1bWVudHM6IHByZXBhcmVkUmVjb3JkU2V0LmRvY3VtZW50cyxcbiAgICAgICAgbWV0YWRhdGFzOiBwcmVwYXJlZFJlY29yZFNldC5tZXRhZGF0YXMsXG4gICAgICAgIHVyaXM6IHByZXBhcmVkUmVjb3JkU2V0LnVyaXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQoYXJncyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRzLFxuICAgICAgd2hlcmUsXG4gICAgICBsaW1pdCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHdoZXJlRG9jdW1lbnQsXG4gICAgICBpbmNsdWRlID0gW1wiZG9jdW1lbnRzXCIsIFwibWV0YWRhdGFzXCJdXG4gICAgfSA9IGFyZ3M7XG4gICAgdGhpcy52YWxpZGF0ZUdldChpbmNsdWRlLCBpZHMsIHdoZXJlLCB3aGVyZURvY3VtZW50KTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvbGxlY3Rpb25HZXQoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBpZHMsXG4gICAgICAgIHdoZXJlLFxuICAgICAgICBsaW1pdCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB3aGVyZV9kb2N1bWVudDogd2hlcmVEb2N1bWVudCxcbiAgICAgICAgaW5jbHVkZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgR2V0UmVzdWx0KHtcbiAgICAgIGRvY3VtZW50czogZGF0YS5kb2N1bWVudHMgPz8gW10sXG4gICAgICBlbWJlZGRpbmdzOiBkYXRhLmVtYmVkZGluZ3MgPz8gW10sXG4gICAgICBpZHM6IGRhdGEuaWRzLFxuICAgICAgaW5jbHVkZTogZGF0YS5pbmNsdWRlLFxuICAgICAgbWV0YWRhdGFzOiBkYXRhLm1ldGFkYXRhcyA/PyBbXSxcbiAgICAgIHVyaXM6IGRhdGEudXJpcyA/PyBbXVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHBlZWsoeyBsaW1pdCA9IDEwIH0pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoeyBsaW1pdCB9KTtcbiAgfVxuICBhc3luYyBxdWVyeSh7XG4gICAgcXVlcnlFbWJlZGRpbmdzLFxuICAgIHF1ZXJ5VGV4dHMsXG4gICAgcXVlcnlVUklzLFxuICAgIGlkcyxcbiAgICBuUmVzdWx0cyA9IDEwLFxuICAgIHdoZXJlLFxuICAgIHdoZXJlRG9jdW1lbnQsXG4gICAgaW5jbHVkZSA9IFtcIm1ldGFkYXRhc1wiLCBcImRvY3VtZW50c1wiLCBcImRpc3RhbmNlc1wiXVxuICB9KSB7XG4gICAgY29uc3QgcmVjb3JkU2V0ID0ge1xuICAgICAgZW1iZWRkaW5nczogcXVlcnlFbWJlZGRpbmdzLFxuICAgICAgZG9jdW1lbnRzOiBxdWVyeVRleHRzLFxuICAgICAgdXJpczogcXVlcnlVUklzXG4gICAgfTtcbiAgICBjb25zdCBxdWVyeVJlY29yZFNldCA9IGF3YWl0IHRoaXMucHJlcGFyZVF1ZXJ5KFxuICAgICAgcmVjb3JkU2V0LFxuICAgICAgaW5jbHVkZSxcbiAgICAgIGlkcyxcbiAgICAgIHdoZXJlLFxuICAgICAgd2hlcmVEb2N1bWVudCxcbiAgICAgIG5SZXN1bHRzXG4gICAgKTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNvbGxlY3Rpb25RdWVyeSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkczogcXVlcnlSZWNvcmRTZXQuaWRzLFxuICAgICAgICBpbmNsdWRlLFxuICAgICAgICBuX3Jlc3VsdHM6IG5SZXN1bHRzLFxuICAgICAgICBxdWVyeV9lbWJlZGRpbmdzOiBxdWVyeVJlY29yZFNldC5lbWJlZGRpbmdzLFxuICAgICAgICB3aGVyZSxcbiAgICAgICAgd2hlcmVfZG9jdW1lbnQ6IHdoZXJlRG9jdW1lbnRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5UmVzdWx0KHtcbiAgICAgIGRpc3RhbmNlczogZGF0YS5kaXN0YW5jZXMgPz8gW10sXG4gICAgICBkb2N1bWVudHM6IGRhdGEuZG9jdW1lbnRzID8/IFtdLFxuICAgICAgZW1iZWRkaW5nczogZGF0YS5lbWJlZGRpbmdzID8/IFtdLFxuICAgICAgaWRzOiBkYXRhLmlkcyA/PyBbXSxcbiAgICAgIGluY2x1ZGU6IGRhdGEuaW5jbHVkZSxcbiAgICAgIG1ldGFkYXRhczogZGF0YS5tZXRhZGF0YXMgPz8gW10sXG4gICAgICB1cmlzOiBkYXRhLnVyaXMgPz8gW11cbiAgICB9KTtcbiAgfVxuICBhc3luYyBtb2RpZnkoe1xuICAgIG5hbWUsXG4gICAgbWV0YWRhdGEsXG4gICAgY29uZmlndXJhdGlvblxuICB9KSB7XG4gICAgaWYgKG5hbWUpIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICB2YWxpZGF0ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgY29uc3QgeyB1cGRhdGVDb25maWd1cmF0aW9uLCB1cGRhdGVFbWJlZGRpbmdGdW5jdGlvbiB9ID0gY29uZmlndXJhdGlvbiA/IGF3YWl0IHByb2Nlc3NVcGRhdGVDb2xsZWN0aW9uQ29uZmlnKHtcbiAgICAgIGNvbGxlY3Rpb25OYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjdXJyZW50Q29uZmlndXJhdGlvbjogdGhpcy5jb25maWd1cmF0aW9uLFxuICAgICAgbmV3Q29uZmlndXJhdGlvbjogY29uZmlndXJhdGlvbixcbiAgICAgIGN1cnJlbnRFbWJlZGRpbmdGdW5jdGlvbjogdGhpcy5lbWJlZGRpbmdGdW5jdGlvblxuICAgIH0pIDoge307XG4gICAgaWYgKHVwZGF0ZUVtYmVkZGluZ0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLmVtYmVkZGluZ0Z1bmN0aW9uID0gdXBkYXRlRW1iZWRkaW5nRnVuY3Rpb247XG4gICAgfVxuICAgIGlmICh1cGRhdGVDb25maWd1cmF0aW9uKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIGhuc3c6IHsgLi4udGhpcy5jb25maWd1cmF0aW9uLmhuc3csIC4uLnVwZGF0ZUNvbmZpZ3VyYXRpb24uaG5zdyB9LFxuICAgICAgICBzcGFubjogeyAuLi50aGlzLmNvbmZpZ3VyYXRpb24uc3Bhbm4sIC4uLnVwZGF0ZUNvbmZpZ3VyYXRpb24uc3Bhbm4gfSxcbiAgICAgICAgZW1iZWRkaW5nRnVuY3Rpb246IHVwZGF0ZUNvbmZpZ3VyYXRpb24uZW1iZWRkaW5nX2Z1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS51cGRhdGVDb2xsZWN0aW9uKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbmV3X25hbWU6IG5hbWUsXG4gICAgICAgIG5ld19tZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgIG5ld19jb25maWd1cmF0aW9uOiB1cGRhdGVDb25maWd1cmF0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZm9yayh7IG5hbWUgfSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZm9ya0NvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMucGF0aCgpLFxuICAgICAgYm9keTogeyBuZXdfbmFtZTogbmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBfQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLmNocm9tYUNsaWVudCxcbiAgICAgIGFwaUNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uOiB0aGlzLl9lbWJlZGRpbmdGdW5jdGlvbixcbiAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhID8/IHZvaWQgMCxcbiAgICAgIGNvbmZpZ3VyYXRpb246IGRhdGEuY29uZmlndXJhdGlvbl9qc29uXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHtcbiAgICBpZHMsXG4gICAgZW1iZWRkaW5ncyxcbiAgICBtZXRhZGF0YXMsXG4gICAgZG9jdW1lbnRzLFxuICAgIHVyaXNcbiAgfSkge1xuICAgIGNvbnN0IHJlY29yZFNldCA9IHtcbiAgICAgIGlkcyxcbiAgICAgIGVtYmVkZGluZ3MsXG4gICAgICBkb2N1bWVudHMsXG4gICAgICBtZXRhZGF0YXMsXG4gICAgICB1cmlzXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlY29yZFNldCA9IGF3YWl0IHRoaXMucHJlcGFyZVJlY29yZHMoe1xuICAgICAgcmVjb3JkU2V0LFxuICAgICAgdXBkYXRlOiB0cnVlXG4gICAgfSk7XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvblVwZGF0ZSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkczogcHJlcGFyZWRSZWNvcmRTZXQuaWRzLFxuICAgICAgICBlbWJlZGRpbmdzOiBwcmVwYXJlZFJlY29yZFNldC5lbWJlZGRpbmdzLFxuICAgICAgICBtZXRhZGF0YXM6IHByZXBhcmVkUmVjb3JkU2V0Lm1ldGFkYXRhcyxcbiAgICAgICAgdXJpczogcHJlcGFyZWRSZWNvcmRTZXQudXJpcyxcbiAgICAgICAgZG9jdW1lbnRzOiBwcmVwYXJlZFJlY29yZFNldC5kb2N1bWVudHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cHNlcnQoe1xuICAgIGlkcyxcbiAgICBlbWJlZGRpbmdzLFxuICAgIG1ldGFkYXRhcyxcbiAgICBkb2N1bWVudHMsXG4gICAgdXJpc1xuICB9KSB7XG4gICAgY29uc3QgcmVjb3JkU2V0ID0ge1xuICAgICAgaWRzLFxuICAgICAgZW1iZWRkaW5ncyxcbiAgICAgIGRvY3VtZW50cyxcbiAgICAgIG1ldGFkYXRhcyxcbiAgICAgIHVyaXNcbiAgICB9O1xuICAgIGNvbnN0IHByZXBhcmVkUmVjb3JkU2V0ID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVjb3Jkcyh7XG4gICAgICByZWNvcmRTZXRcbiAgICB9KTtcbiAgICBhd2FpdCBEZWZhdWx0U2VydmljZS5jb2xsZWN0aW9uVXBzZXJ0KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiBhd2FpdCB0aGlzLnBhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgaWRzOiBwcmVwYXJlZFJlY29yZFNldC5pZHMsXG4gICAgICAgIGVtYmVkZGluZ3M6IHByZXBhcmVkUmVjb3JkU2V0LmVtYmVkZGluZ3MsXG4gICAgICAgIG1ldGFkYXRhczogcHJlcGFyZWRSZWNvcmRTZXQubWV0YWRhdGFzLFxuICAgICAgICB1cmlzOiBwcmVwYXJlZFJlY29yZFNldC51cmlzLFxuICAgICAgICBkb2N1bWVudHM6IHByZXBhcmVkUmVjb3JkU2V0LmRvY3VtZW50c1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlbGV0ZSh7XG4gICAgaWRzLFxuICAgIHdoZXJlLFxuICAgIHdoZXJlRG9jdW1lbnRcbiAgfSkge1xuICAgIHRoaXMudmFsaWRhdGVEZWxldGUoaWRzLCB3aGVyZSwgd2hlcmVEb2N1bWVudCk7XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UuY29sbGVjdGlvbkRlbGV0ZSh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5wYXRoKCksXG4gICAgICBib2R5OiB7XG4gICAgICAgIGlkcyxcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIHdoZXJlX2RvY3VtZW50OiB3aGVyZURvY3VtZW50XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9uZXh0LnRzXG5mdW5jdGlvbiB3aXRoQ2hyb21hKHVzZXJOZXh0Q29uZmlnID0ge30pIHtcbiAgY29uc3Qgb3JpZ2luYWxXZWJwYWNrRnVuY3Rpb24gPSB1c2VyTmV4dENvbmZpZy53ZWJwYWNrO1xuICBjb25zdCBuZXdXZWJwYWNrRnVuY3Rpb24gPSAoY29uZmlnLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5leHRlcm5hbHMpKSB7XG4gICAgICBjb25maWcuZXh0ZXJuYWxzID0gW107XG4gICAgfVxuICAgIGNvbnN0IGV4dGVybmFsc1RvQWRkID0gW1wiQGh1Z2dpbmdmYWNlL3RyYW5zZm9ybWVyc1wiLCBcImNocm9tYWRiXCJdO1xuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVybmFsc1RvQWRkKSB7XG4gICAgICBpZiAoIWNvbmZpZy5leHRlcm5hbHMuaW5jbHVkZXMoZXh0KSkge1xuICAgICAgICBjb25maWcuZXh0ZXJuYWxzLnB1c2goZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFdlYnBhY2tGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxXZWJwYWNrRnVuY3Rpb24oY29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi51c2VyTmV4dENvbmZpZyxcbiAgICB3ZWJwYWNrOiBuZXdXZWJwYWNrRnVuY3Rpb25cbiAgfTtcbn1cblxuLy8gc3JjL2Nocm9tYS1mZXRjaC50c1xudmFyIG9mZmxpbmVFcnJvciA9IChlcnJvcikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICAoZXJyb3I/Lm5hbWUgPT09IFwiVHlwZUVycm9yXCIgfHwgZXJyb3I/Lm5hbWUgPT09IFwiRmV0Y2hFcnJvclwiKSAmJiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJmZXRjaCBmYWlsZWRcIikgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJFTk9URk9VTkRcIikpXG4gICk7XG59O1xudmFyIGNocm9tYUZldGNoID0gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZTtcbiAgdHJ5IHtcbiAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGlucHV0LCBpbml0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG9mZmxpbmVFcnJvcihlcnIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBjb25uZWN0IHRvIGNocm9tYWRiLiBNYWtlIHN1cmUgeW91ciBzZXJ2ZXIgaXMgcnVubmluZyBhbmQgdHJ5IGFnYWluLiBJZiB5b3UgYXJlIHJ1bm5pbmcgZnJvbSBhIGJyb3dzZXIsIG1ha2Ugc3VyZSB0aGF0IHlvdXIgY2hyb21hZGIgaW5zdGFuY2UgaXMgY29uZmlndXJlZCB0byBhbGxvdyByZXF1ZXN0cyBmcm9tIHRoZSBjdXJyZW50IG9yaWdpbiB1c2luZyB0aGUgQ0hST01BX1NFUlZFUl9DT1JTX0FMTE9XX09SSUdJTlMgZW52aXJvbm1lbnQgdmFyaWFibGUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBDaHJvbWFDb25uZWN0aW9uRXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBDaHJvbWFcIik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDA6XG4gICAgICBsZXQgc3RhdHVzID0gXCJCYWQgUmVxdWVzdFwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzdGF0dXMgPSByZXNwb25zZUJvZHkubWVzc2FnZSB8fCBzdGF0dXM7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBDaHJvbWFDbGllbnRFcnJvcihcbiAgICAgICAgYEJhZCByZXF1ZXN0IHRvICR7aW5wdXQudXJsIHx8IFwiQ2hyb21hXCJ9IHdpdGggc3RhdHVzOiAke3N0YXR1c31gXG4gICAgICApO1xuICAgIGNhc2UgNDAxOlxuICAgICAgdGhyb3cgbmV3IENocm9tYVVuYXV0aG9yaXplZEVycm9yKGBVbmF1dGhvcml6ZWRgKTtcbiAgICBjYXNlIDQwMzpcbiAgICAgIHRocm93IG5ldyBDaHJvbWFGb3JiaWRkZW5FcnJvcihcbiAgICAgICAgYFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgcmVxdWVzdGVkIHJlc291cmNlLmBcbiAgICAgICk7XG4gICAgY2FzZSA0MDQ6XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hTm90Rm91bmRFcnJvcihcbiAgICAgICAgYFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgY291bGQgbm90IGJlIGZvdW5kYFxuICAgICAgKTtcbiAgICBjYXNlIDQwOTpcbiAgICAgIHRocm93IG5ldyBDaHJvbWFVbmlxdWVFcnJvcihcIlRoZSByZXNvdXJjZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICBjYXNlIDQyMjpcbiAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoYm9keSAmJiBib2R5Lm1lc3NhZ2UgJiYgKGJvZHkubWVzc2FnZS5zdGFydHNXaXRoKFwiUXVvdGEgZXhjZWVkZWRcIikgfHwgYm9keS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJCaWxsaW5nIGxpbWl0IGV4Y2VlZGVkXCIpKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hUXVvdGFFeGNlZWRlZEVycm9yKGJvZHk/Lm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0Mjk6XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hUmF0ZUxpbWl0RXJyb3IoXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIpO1xuICB9XG4gIHRocm93IG5ldyBDaHJvbWFDb25uZWN0aW9uRXJyb3IoXG4gICAgYFVuYWJsZSB0byBjb25uZWN0IHRvIHRoZSBjaHJvbWFkYiBzZXJ2ZXIgKHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9KS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5gXG4gICk7XG59O1xuXG4vLyBzcmMvYWRtaW4tY2xpZW50LnRzXG52YXIgQWRtaW5DbGllbnQgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEFkbWluQ2xpZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gYXJncyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBhZG1pbiBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBjb25zdCB7IGhvc3QsIHBvcnQsIHNzbCwgaGVhZGVycywgZmV0Y2hPcHRpb25zIH0gPSBhcmdzIHx8IGRlZmF1bHRBZG1pbkNsaWVudEFyZ3M7XG4gICAgY29uc3QgYmFzZVVybCA9IGAke3NzbCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwifTovLyR7aG9zdH06JHtwb3J0fWA7XG4gICAgY29uc3QgY29uZmlnT3B0aW9ucyA9IHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIG1ldGhvZDogbm9ybWFsaXplTWV0aG9kKGZldGNoT3B0aW9ucz8ubWV0aG9kKSxcbiAgICAgIGJhc2VVcmwsXG4gICAgICBoZWFkZXJzXG4gICAgfTtcbiAgICB0aGlzLmFwaUNsaWVudCA9IEoodyhjb25maWdPcHRpb25zKSk7XG4gICAgdGhpcy5hcGlDbGllbnQuc2V0Q29uZmlnKHsgZmV0Y2g6IGNocm9tYUZldGNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGRhdGFiYXNlIHdpdGhpbiBhIHRlbmFudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEYXRhYmFzZSBjcmVhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhYmFzZSB0byBjcmVhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMudGVuYW50IC0gVGVuYW50IHRoYXQgd2lsbCBvd24gdGhlIGRhdGFiYXNlXG4gICAqL1xuICBhc3luYyBjcmVhdGVEYXRhYmFzZSh7XG4gICAgbmFtZSxcbiAgICB0ZW5hbnRcbiAgfSkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNyZWF0ZURhdGFiYXNlKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiB7IHRlbmFudCB9LFxuICAgICAgYm9keTogeyBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRGF0YWJhc2UgcmV0cmlldmFsIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFiYXNlIHRvIHJldHJpZXZlXG4gICAqIEBwYXJhbSBvcHRpb25zLnRlbmFudCAtIFRlbmFudCB0aGF0IG93bnMgdGhlIGRhdGFiYXNlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGRhdGFiYXNlIGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyBnZXREYXRhYmFzZSh7XG4gICAgbmFtZSxcbiAgICB0ZW5hbnRcbiAgfSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZ2V0RGF0YWJhc2Uoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgdGVuYW50LCBkYXRhYmFzZTogbmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBkYXRhYmFzZSBhbmQgYWxsIGl0cyBkYXRhLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERhdGFiYXNlIGRlbGV0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFiYXNlIHRvIGRlbGV0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucy50ZW5hbnQgLSBUZW5hbnQgdGhhdCBvd25zIHRoZSBkYXRhYmFzZVxuICAgKiBAd2FybmluZyBUaGlzIG9wZXJhdGlvbiBpcyBpcnJldmVyc2libGUgYW5kIHdpbGwgZGVsZXRlIGFsbCBkYXRhXG4gICAqL1xuICBhc3luYyBkZWxldGVEYXRhYmFzZSh7XG4gICAgbmFtZSxcbiAgICB0ZW5hbnRcbiAgfSkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmRlbGV0ZURhdGFiYXNlKHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBwYXRoOiB7IHRlbmFudCwgZGF0YWJhc2U6IG5hbWUgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZGF0YWJhc2VzIHdpdGhpbiBhIHRlbmFudC5cbiAgICogQHBhcmFtIGFyZ3MgLSBMaXN0aW5nIHBhcmFtZXRlcnMgaW5jbHVkaW5nIHRlbmFudCBhbmQgcGFnaW5hdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBkYXRhYmFzZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgbGlzdERhdGFiYXNlcyhhcmdzKSB7XG4gICAgY29uc3QgeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgdGVuYW50IH0gPSBhcmdzO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UubGlzdERhdGFiYXNlcyh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyB0ZW5hbnQgfSxcbiAgICAgIHF1ZXJ5OiB7IGxpbWl0LCBvZmZzZXQgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRlbmFudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUZW5hbnQgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgdGVuYW50IHRvIGNyZWF0ZVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGVuYW50KHsgbmFtZSB9KSB7XG4gICAgYXdhaXQgRGVmYXVsdFNlcnZpY2UuY3JlYXRlVGVuYW50KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBib2R5OiB7IG5hbWUgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyB0ZW5hbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGVuYW50IHJldHJpZXZhbCBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSB0ZW5hbnQgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRlbmFudCBuYW1lXG4gICAqL1xuICBhc3luYyBnZXRUZW5hbnQoeyBuYW1lIH0pIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmdldFRlbmFudCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyB0ZW5hbnRfbmFtZTogbmFtZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgfVxufTtcblxuLy8gc3JjL2Nocm9tYS1jbGllbnQudHNcbmltcG9ydCAqIGFzIHByb2Nlc3MgZnJvbSBcIm5vZGU6cHJvY2Vzc1wiO1xudmFyIENocm9tYUNsaWVudCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ2hyb21hQ2xpZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gYXJncyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncyA9IHt9KSB7XG4gICAgbGV0IHtcbiAgICAgIGhvc3QgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5ob3N0LFxuICAgICAgcG9ydCA9IGRlZmF1bHRDaHJvbWFDbGllbnRBcmdzLnBvcnQsXG4gICAgICBzc2wgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5zc2wsXG4gICAgICB0ZW5hbnQgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy50ZW5hbnQsXG4gICAgICBkYXRhYmFzZSA9IGRlZmF1bHRDaHJvbWFDbGllbnRBcmdzLmRhdGFiYXNlLFxuICAgICAgaGVhZGVycyA9IGRlZmF1bHRDaHJvbWFDbGllbnRBcmdzLmhlYWRlcnMsXG4gICAgICBmZXRjaE9wdGlvbnMgPSBkZWZhdWx0Q2hyb21hQ2xpZW50QXJncy5mZXRjaE9wdGlvbnNcbiAgICB9ID0gYXJncztcbiAgICBpZiAoYXJncy5wYXRoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlICdwYXRoJyBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICdzc2wnLCAnaG9zdCcsIGFuZCAncG9ydCcgaW5zdGVhZFwiXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyc2VkUGF0aCA9IHBhcnNlQ29ubmVjdGlvblBhdGgoYXJncy5wYXRoKTtcbiAgICAgIHNzbCA9IHBhcnNlZFBhdGguc3NsO1xuICAgICAgaG9zdCA9IHBhcnNlZFBhdGguaG9zdDtcbiAgICAgIHBvcnQgPSBwYXJzZWRQYXRoLnBvcnQ7XG4gICAgfVxuICAgIGlmIChhcmdzLmF1dGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJUaGUgJ2F1dGgnIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJ2hlYWRlcnMnIGluc3RlYWRcIlxuICAgICAgKTtcbiAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoIWhlYWRlcnNbXCJ4LWNocm9tYS10b2tlblwiXSAmJiBhcmdzLmF1dGgudG9rZW5IZWFkZXJUeXBlID09PSBcIlhfQ0hST01BX1RPS0VOXCIgJiYgYXJncy5hdXRoLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWNocm9tYS10b2tlblwiXSA9IGFyZ3MuYXV0aC5jcmVkZW50aWFscztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmFzZVVybCA9IGAke3NzbCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwifTovLyR7aG9zdH06JHtwb3J0fWA7XG4gICAgdGhpcy5fdGVuYW50ID0gdGVuYW50IHx8IHByb2Nlc3MuZW52LkNIUk9NQV9URU5BTlQ7XG4gICAgdGhpcy5fZGF0YWJhc2UgPSBkYXRhYmFzZSB8fCBwcm9jZXNzLmVudi5DSFJPTUFfREFUQUJBU0U7XG4gICAgY29uc3QgY29uZmlnT3B0aW9ucyA9IHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIG1ldGhvZDogbm9ybWFsaXplTWV0aG9kKGZldGNoT3B0aW9ucz8ubWV0aG9kKSxcbiAgICAgIGJhc2VVcmwsXG4gICAgICBoZWFkZXJzXG4gICAgfTtcbiAgICB0aGlzLmFwaUNsaWVudCA9IEoodyhjb25maWdPcHRpb25zKSk7XG4gICAgdGhpcy5hcGlDbGllbnQuc2V0Q29uZmlnKHsgZmV0Y2g6IGNocm9tYUZldGNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHRlbmFudCBuYW1lLlxuICAgKiBAcmV0dXJucyBUaGUgdGVuYW50IG5hbWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBzZXRcbiAgICovXG4gIGdldCB0ZW5hbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RlbmFudDtcbiAgfVxuICBzZXQgdGVuYW50KHRlbmFudCkge1xuICAgIHRoaXMuX3RlbmFudCA9IHRlbmFudDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBkYXRhYmFzZSBuYW1lLlxuICAgKiBAcmV0dXJucyBUaGUgZGF0YWJhc2UgbmFtZSBvciB1bmRlZmluZWQgaWYgbm90IHNldFxuICAgKi9cbiAgZ2V0IGRhdGFiYXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhYmFzZTtcbiAgfVxuICBzZXQgZGF0YWJhc2UoZGF0YWJhc2UpIHtcbiAgICB0aGlzLl9kYXRhYmFzZSA9IGRhdGFiYXNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcmVmbGlnaHQgY2hlY2tzXG4gICAqIEByZXR1cm5zIFRoZSBwcmVmbGlnaHQgY2hlY2tzIG9yIHVuZGVmaW5lZCBpZiBub3Qgc2V0XG4gICAqL1xuICBnZXQgcHJlZmxpZ2h0Q2hlY2tzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVmbGlnaHRDaGVja3M7XG4gIH1cbiAgc2V0IHByZWZsaWdodENoZWNrcyhwcmVmbGlnaHRDaGVja3MpIHtcbiAgICB0aGlzLl9wcmVmbGlnaHRDaGVja3MgPSBwcmVmbGlnaHRDaGVja3M7XG4gIH1cbiAgLyoqIEBpZ25vcmUgKi9cbiAgYXN5bmMgX3BhdGgoKSB7XG4gICAgaWYgKCF0aGlzLl90ZW5hbnQgfHwgIXRoaXMuX2RhdGFiYXNlKSB7XG4gICAgICBjb25zdCB7IHRlbmFudCwgZGF0YWJhc2VzIH0gPSBhd2FpdCB0aGlzLmdldFVzZXJJZGVudGl0eSgpO1xuICAgICAgY29uc3QgdW5pcXVlREJzID0gWy4uLm5ldyBTZXQoZGF0YWJhc2VzKV07XG4gICAgICB0aGlzLl90ZW5hbnQgPSB0ZW5hbnQ7XG4gICAgICBpZiAodW5pcXVlREJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVW5hdXRob3JpemVkRXJyb3IoXG4gICAgICAgICAgYFlvdXIgQVBJIGtleSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhbnkgREJzIGZvciB0ZW5hbnQgJHt0aGlzLnRlbmFudH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodW5pcXVlREJzLmxlbmd0aCA+IDEgfHwgdW5pcXVlREJzWzBdID09PSBcIipcIikge1xuICAgICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgICBcIllvdXIgQVBJIGtleSBpcyBzY29wZWQgdG8gbW9yZSB0aGFuIDEgREIuIFBsZWFzZSBwcm92aWRlIGEgREIgbmFtZSB0byB0aGUgQ2xvdWRDbGllbnQgY29uc3RydWN0b3JcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGF0YWJhc2UgPSB1bmlxdWVEQnNbMF07XG4gICAgfVxuICAgIHJldHVybiB7IHRlbmFudDogdGhpcy5fdGVuYW50LCBkYXRhYmFzZTogdGhpcy5fZGF0YWJhc2UgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlciBpZGVudGl0eSBpbmZvcm1hdGlvbiBpbmNsdWRpbmcgdGVuYW50IGFuZCBhY2Nlc3NpYmxlIGRhdGFiYXNlcy5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdXNlciBpZGVudGl0eSBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRVc2VySWRlbnRpdHkoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5nZXRVc2VySWRlbnRpdHkoe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIGhlYXJ0YmVhdCByZXF1ZXN0IHRvIGNoZWNrIHNlcnZlciBjb25uZWN0aXZpdHkuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzZXJ2ZXIncyBuYW5vc2Vjb25kIGhlYXJ0YmVhdCB0aW1lc3RhbXBcbiAgICovXG4gIGFzeW5jIGhlYXJ0YmVhdCgpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmhlYXJ0YmVhdCh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGFbXCJuYW5vc2Vjb25kIGhlYXJ0YmVhdFwiXTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIGNvbGxlY3Rpb25zIGluIHRoZSBjdXJyZW50IGRhdGFiYXNlLlxuICAgKiBAcGFyYW0gYXJncyAtIE9wdGlvbmFsIHBhZ2luYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gYXJncy5saW1pdCAtIE1heGltdW0gbnVtYmVyIG9mIGNvbGxlY3Rpb25zIHRvIHJldHVybiAoZGVmYXVsdDogMTAwKVxuICAgKiBAcGFyYW0gYXJncy5vZmZzZXQgLSBOdW1iZXIgb2YgY29sbGVjdGlvbnMgdG8gc2tpcCAoZGVmYXVsdDogMClcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgQ29sbGVjdGlvbiBpbnN0YW5jZXNcbiAgICovXG4gIGFzeW5jIGxpc3RDb2xsZWN0aW9ucyhhcmdzKSB7XG4gICAgY29uc3QgeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCB9ID0gYXJncyB8fCB7fTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmxpc3RDb2xsZWN0aW9ucyh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5fcGF0aCgpLFxuICAgICAgcXVlcnk6IHsgbGltaXQsIG9mZnNldCB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgZGF0YS5tYXAoXG4gICAgICAgIGFzeW5jIChjb2xsZWN0aW9uKSA9PiBuZXcgQ29sbGVjdGlvbkltcGwoe1xuICAgICAgICAgIGNocm9tYUNsaWVudDogdGhpcyxcbiAgICAgICAgICBhcGlDbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgICAgIG5hbWU6IGNvbGxlY3Rpb24ubmFtZSxcbiAgICAgICAgICBpZDogY29sbGVjdGlvbi5pZCxcbiAgICAgICAgICBlbWJlZGRpbmdGdW5jdGlvbjogYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oXG4gICAgICAgICAgICBjb2xsZWN0aW9uLm5hbWUsXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmNvbmZpZ3VyYXRpb25fanNvbi5lbWJlZGRpbmdfZnVuY3Rpb24gPz8gdm9pZCAwXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb25maWd1cmF0aW9uOiBjb2xsZWN0aW9uLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgICAgICBtZXRhZGF0YTogY29sbGVjdGlvbi5tZXRhZGF0YSA/PyB2b2lkIDBcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgY29sbGVjdGlvbnMgaW4gdGhlIGN1cnJlbnQgZGF0YWJhc2UuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAqL1xuICBhc3luYyBjb3VudENvbGxlY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuY291bnRDb2xsZWN0aW9ucyh7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5fcGF0aCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sbGVjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb2xsZWN0aW9uIGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZ3VyYXRpb24gLSBPcHRpb25hbCBjb2xsZWN0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG9wdGlvbnMubWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBmb3IgdGhlIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIG9wdGlvbnMuZW1iZWRkaW5nRnVuY3Rpb24gLSBPcHRpb25hbCBlbWJlZGRpbmcgZnVuY3Rpb24gdG8gdXNlLiBEZWZhdWx0cyB0byBgRGVmYXVsdEVtYmVkZGluZ0Z1bmN0aW9uYCBmcm9tIEBjaHJvbWEtY29yZS9kZWZhdWx0LWVtYmVkXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIENvbGxlY3Rpb24gaW5zdGFuY2VcbiAgICogQHRocm93cyBFcnJvciBpZiBhIGNvbGxlY3Rpb24gd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzXG4gICAqL1xuICBhc3luYyBjcmVhdGVDb2xsZWN0aW9uKHtcbiAgICBuYW1lLFxuICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgbWV0YWRhdGEsXG4gICAgZW1iZWRkaW5nRnVuY3Rpb25cbiAgfSkge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25Db25maWcgPSBhd2FpdCBwcm9jZXNzQ3JlYXRlQ29sbGVjdGlvbkNvbmZpZyh7XG4gICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgZW1iZWRkaW5nRnVuY3Rpb24sXG4gICAgICBtZXRhZGF0YVxuICAgIH0pO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogYXdhaXQgdGhpcy5fcGF0aCgpLFxuICAgICAgYm9keToge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjb25maWd1cmF0aW9uOiBjb2xsZWN0aW9uQ29uZmlnLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgZ2V0X29yX2NyZWF0ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JbXBsKHtcbiAgICAgIGNocm9tYUNsaWVudDogdGhpcyxcbiAgICAgIGFwaUNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBuYW1lLFxuICAgICAgY29uZmlndXJhdGlvbjogZGF0YS5jb25maWd1cmF0aW9uX2pzb24sXG4gICAgICBtZXRhZGF0YSxcbiAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uOiBlbWJlZGRpbmdGdW5jdGlvbiA/PyBhd2FpdCBnZXRFbWJlZGRpbmdGdW5jdGlvbihcbiAgICAgICAgZGF0YS5uYW1lLFxuICAgICAgICBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbi5lbWJlZGRpbmdfZnVuY3Rpb24gPz8gdm9pZCAwXG4gICAgICApLFxuICAgICAgaWQ6IGRhdGEuaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb24gYnkgbmFtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb2xsZWN0aW9uIHJldHJpZXZhbCBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvbiB0byByZXRyaWV2ZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbWJlZGRpbmdGdW5jdGlvbiAtIE9wdGlvbmFsIGVtYmVkZGluZyBmdW5jdGlvbi4gU2hvdWxkIG1hdGNoIHRoZSBvbmUgdXNlZCB0byBjcmVhdGUgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBDb2xsZWN0aW9uIGluc3RhbmNlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIGFzeW5jIGdldENvbGxlY3Rpb24oe1xuICAgIG5hbWUsXG4gICAgZW1iZWRkaW5nRnVuY3Rpb25cbiAgfSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgRGVmYXVsdFNlcnZpY2UuZ2V0Q29sbGVjdGlvbih7XG4gICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgcGF0aDogeyAuLi5hd2FpdCB0aGlzLl9wYXRoKCksIGNvbGxlY3Rpb25faWQ6IG5hbWUgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkltcGwoe1xuICAgICAgY2hyb21hQ2xpZW50OiB0aGlzLFxuICAgICAgYXBpQ2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIG5hbWUsXG4gICAgICBjb25maWd1cmF0aW9uOiBkYXRhLmNvbmZpZ3VyYXRpb25fanNvbixcbiAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhID8/IHZvaWQgMCxcbiAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uOiBlbWJlZGRpbmdGdW5jdGlvbiA/IGVtYmVkZGluZ0Z1bmN0aW9uIDogYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oXG4gICAgICAgIGRhdGEubmFtZSxcbiAgICAgICAgZGF0YS5jb25maWd1cmF0aW9uX2pzb24uZW1iZWRkaW5nX2Z1bmN0aW9uID8/IHZvaWQgMFxuICAgICAgKSxcbiAgICAgIGlkOiBkYXRhLmlkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBtdWx0aXBsZSBjb2xsZWN0aW9ucyBieSBuYW1lLlxuICAgKiBAcGFyYW0gaXRlbXMgLSBBcnJheSBvZiBjb2xsZWN0aW9uIG5hbWVzIG9yIG9iamVjdHMgd2l0aCBuYW1lIGFuZCBvcHRpb25hbCBlbWJlZGRpbmcgZnVuY3Rpb24gKHNob3VsZCBtYXRjaCB0aGUgb25lcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY29sbGVjdGlvbnMpXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIENvbGxlY3Rpb24gaW5zdGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRDb2xsZWN0aW9ucyhpdGVtcykge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICBsZXQgcmVxdWVzdGVkQ29sbGVjdGlvbnMgPSBpdGVtcztcbiAgICBpZiAodHlwZW9mIGl0ZW1zWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXF1ZXN0ZWRDb2xsZWN0aW9ucyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4geyBuYW1lOiBpdGVtLCBlbWJlZGRpbmdGdW5jdGlvbjogdm9pZCAwIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNvbGxlY3Rpb25zID0gcmVxdWVzdGVkQ29sbGVjdGlvbnM7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgY29sbGVjdGlvbnMubWFwKGFzeW5jIChjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbGxlY3Rpb24oeyAuLi5jb2xsZWN0aW9uIH0pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb24gb3IgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbGxlY3Rpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlndXJhdGlvbiAtIE9wdGlvbmFsIGNvbGxlY3Rpb24gY29uZmlndXJhdGlvbiAodXNlZCBvbmx5IGlmIGNyZWF0aW5nKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIGZvciB0aGUgY29sbGVjdGlvbiAodXNlZCBvbmx5IGlmIGNyZWF0aW5nKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbWJlZGRpbmdGdW5jdGlvbiAtIE9wdGlvbmFsIGVtYmVkZGluZyBmdW5jdGlvbiB0byB1c2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIENvbGxlY3Rpb24gaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIGdldE9yQ3JlYXRlQ29sbGVjdGlvbih7XG4gICAgbmFtZSxcbiAgICBjb25maWd1cmF0aW9uLFxuICAgIG1ldGFkYXRhLFxuICAgIGVtYmVkZGluZ0Z1bmN0aW9uXG4gIH0pIHtcbiAgICBjb25zdCBjb2xsZWN0aW9uQ29uZmlnID0gYXdhaXQgcHJvY2Vzc0NyZWF0ZUNvbGxlY3Rpb25Db25maWcoe1xuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgIGVtYmVkZGluZ0Z1bmN0aW9uLFxuICAgICAgbWV0YWRhdGFcbiAgICB9KTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLmNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IGF3YWl0IHRoaXMuX3BhdGgoKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY29uZmlndXJhdGlvbjogY29sbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGdldF9vcl9jcmVhdGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JbXBsKHtcbiAgICAgIGNocm9tYUNsaWVudDogdGhpcyxcbiAgICAgIGFwaUNsaWVudDogdGhpcy5hcGlDbGllbnQsXG4gICAgICBuYW1lLFxuICAgICAgY29uZmlndXJhdGlvbjogZGF0YS5jb25maWd1cmF0aW9uX2pzb24sXG4gICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSA/PyB2b2lkIDAsXG4gICAgICBlbWJlZGRpbmdGdW5jdGlvbjogZW1iZWRkaW5nRnVuY3Rpb24gPz8gYXdhaXQgZ2V0RW1iZWRkaW5nRnVuY3Rpb24oXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGEuY29uZmlndXJhdGlvbl9qc29uLmVtYmVkZGluZ19mdW5jdGlvbiA/PyB2b2lkIDBcbiAgICAgICksXG4gICAgICBpZDogZGF0YS5pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29sbGVjdGlvbiBhbmQgYWxsIGl0cyBkYXRhLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERlbGV0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRvIGRlbGV0ZVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQ29sbGVjdGlvbih7IG5hbWUgfSkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLmRlbGV0ZUNvbGxlY3Rpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudCxcbiAgICAgIHBhdGg6IHsgLi4uYXdhaXQgdGhpcy5fcGF0aCgpLCBjb2xsZWN0aW9uX2lkOiBuYW1lIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBlbnRpcmUgZGF0YWJhc2UsIGRlbGV0aW5nIGFsbCBjb2xsZWN0aW9ucyBhbmQgZGF0YS5cbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJlc2V0IGlzIGNvbXBsZXRlXG4gICAqIEB3YXJuaW5nIFRoaXMgb3BlcmF0aW9uIGlzIGlycmV2ZXJzaWJsZSBhbmQgd2lsbCBkZWxldGUgYWxsIGRhdGFcbiAgICovXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIGF3YWl0IERlZmF1bHRTZXJ2aWNlLnJlc2V0KHtcbiAgICAgIGNsaWVudDogdGhpcy5hcGlDbGllbnRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyc2lvbiBvZiB0aGUgQ2hyb21hIHNlcnZlci5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHNlcnZlciB2ZXJzaW9uIHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgdmVyc2lvbigpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IERlZmF1bHRTZXJ2aWNlLnZlcnNpb24oe1xuICAgICAgY2xpZW50OiB0aGlzLmFwaUNsaWVudFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcmVmbGlnaHQgY2hlY2tzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBwcmVmbGlnaHQgY2hlY2tzXG4gICAqL1xuICBhc3luYyBnZXRQcmVmbGlnaHRDaGVja3MoKSB7XG4gICAgaWYgKCF0aGlzLnByZWZsaWdodENoZWNrcykge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBEZWZhdWx0U2VydmljZS5wcmVGbGlnaHRDaGVja3Moe1xuICAgICAgICBjbGllbnQ6IHRoaXMuYXBpQ2xpZW50XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlZmxpZ2h0Q2hlY2tzID0gZGF0YTtcbiAgICAgIHJldHVybiB0aGlzLnByZWZsaWdodENoZWNrcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJlZmxpZ2h0Q2hlY2tzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXggYmF0Y2ggc2l6ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWF4IGJhdGNoIHNpemVcbiAgICovXG4gIGFzeW5jIGdldE1heEJhdGNoU2l6ZSgpIHtcbiAgICBjb25zdCBwcmVmbGlnaHRDaGVja3MgPSBhd2FpdCB0aGlzLmdldFByZWZsaWdodENoZWNrcygpO1xuICAgIHJldHVybiBwcmVmbGlnaHRDaGVja3MubWF4X2JhdGNoX3NpemUgPz8gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBiYXNlNjRfZW5jb2RpbmcgaXMgc3VwcG9ydGVkIGJ5IHRoZSBjb25uZWN0ZWQgc2VydmVyXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgYmFzZTY0X2VuY29kaW5nIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgYXN5bmMgc3VwcG9ydHNCYXNlNjRFbmNvZGluZygpIHtcbiAgICBjb25zdCBwcmVmbGlnaHRDaGVja3MgPSBhd2FpdCB0aGlzLmdldFByZWZsaWdodENoZWNrcygpO1xuICAgIHJldHVybiBwcmVmbGlnaHRDaGVja3Muc3VwcG9ydHNfYmFzZTY0X2VuY29kaW5nID8/IGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvY2xvdWQtY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBwcm9jZXNzMiBmcm9tIFwibm9kZTpwcm9jZXNzXCI7XG52YXIgQ2xvdWRDbGllbnQgPSBjbGFzcyBleHRlbmRzIENocm9tYUNsaWVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENsb3VkQ2xpZW50IGluc3RhbmNlIGZvciBDaHJvbWEgQ2xvdWQuXG4gICAqIEBwYXJhbSBhcmdzIC0gQ2xvdWQgY2xpZW50IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncyA9IHt9KSB7XG4gICAgY29uc3QgYXBpS2V5ID0gYXJncy5hcGlLZXkgfHwgcHJvY2VzczIuZW52LkNIUk9NQV9BUElfS0VZO1xuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQ2hyb21hVmFsdWVFcnJvcihcbiAgICAgICAgXCJNaXNzaW5nIEFQSSBrZXkuIFBsZWFzZSBwcm92aWRlIGl0IHRvIHRoZSBDbG91ZENsaWVudCBjb25zdHJ1Y3RvciBvciBzZXQgeW91ciBDSFJPTUFfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0ZW5hbnQgPSBhcmdzLnRlbmFudCB8fCBwcm9jZXNzMi5lbnYuQ0hST01BX1RFTkFOVDtcbiAgICBjb25zdCBkYXRhYmFzZSA9IGFyZ3MuZGF0YWJhc2UgfHwgcHJvY2VzczIuZW52LkNIUk9NQV9EQVRBQkFTRTtcbiAgICBzdXBlcih7XG4gICAgICBob3N0OiBcImFwaS50cnljaHJvbWEuY29tXCIsXG4gICAgICBwb3J0OiA4ZTMsXG4gICAgICBzc2w6IHRydWUsXG4gICAgICB0ZW5hbnQsXG4gICAgICBkYXRhYmFzZSxcbiAgICAgIGhlYWRlcnM6IHsgXCJ4LWNocm9tYS10b2tlblwiOiBhcGlLZXkgfSxcbiAgICAgIGZldGNoT3B0aW9uczogYXJncy5mZXRjaE9wdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRlbmFudCA9IHRlbmFudDtcbiAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XG4gIH1cbn07XG52YXIgQWRtaW5DbG91ZENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQWRtaW5DbGllbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBZG1pbkNsb3VkQ2xpZW50IGluc3RhbmNlIGZvciBjbG91ZCBhZG1pbiBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0gYXJncyAtIEFkbWluIGNsb3VkIGNsaWVudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGFwaUtleSA9IGFyZ3MuYXBpS2V5IHx8IHByb2Nlc3MyLmVudi5DSFJPTUFfQVBJX0tFWTtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IENocm9tYVZhbHVlRXJyb3IoXG4gICAgICAgIFwiTWlzc2luZyBBUEkga2V5LiBQbGVhc2UgcHJvdmlkZSBpdCB0byB0aGUgQ2xvdWRDbGllbnQgY29uc3RydWN0b3Igb3Igc2V0IHlvdXIgQ0hST01BX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgc3VwZXIoe1xuICAgICAgaG9zdDogXCJhcGkudHJ5Y2hyb21hLmNvbVwiLFxuICAgICAgcG9ydDogOGUzLFxuICAgICAgc3NsOiB0cnVlLFxuICAgICAgaGVhZGVyczogeyBcIngtY2hyb21hLXRva2VuXCI6IGFwaUtleSB9LFxuICAgICAgZmV0Y2hPcHRpb25zOiBhcmdzLmZldGNoT3B0aW9uc1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWRtaW5DbGllbnQsXG4gIEFkbWluQ2xvdWRDbGllbnQsXG4gIENocm9tYUNsaWVudCxcbiAgQ2hyb21hQ2xpZW50RXJyb3IsXG4gIENocm9tYUNvbm5lY3Rpb25FcnJvcixcbiAgQ2hyb21hRXJyb3IsXG4gIENocm9tYUZvcmJpZGRlbkVycm9yLFxuICBDaHJvbWFOb3RGb3VuZEVycm9yLFxuICBDaHJvbWFRdW90YUV4Y2VlZGVkRXJyb3IsXG4gIENocm9tYVJhdGVMaW1pdEVycm9yLFxuICBDaHJvbWFTZXJ2ZXJFcnJvcixcbiAgQ2hyb21hVW5hdXRob3JpemVkRXJyb3IsXG4gIENocm9tYVVuaXF1ZUVycm9yLFxuICBDaHJvbWFWYWx1ZUVycm9yLFxuICBDbG91ZENsaWVudCxcbiAgR2V0UmVzdWx0LFxuICBJbmNsdWRlRW51bSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRDb2xsZWN0aW9uRXJyb3IsXG4gIFF1ZXJ5UmVzdWx0LFxuICBiYXNlUmVjb3JkU2V0RmllbGRzLFxuICBjcmVhdGVFcnJvckJ5VHlwZSxcbiAgZ2V0RGVmYXVsdEVGQ29uZmlnLFxuICBnZXRFbWJlZGRpbmdGdW5jdGlvbixcbiAga25vd25FbWJlZGRpbmdGdW5jdGlvbnMsXG4gIHByb2Nlc3NDcmVhdGVDb2xsZWN0aW9uQ29uZmlnLFxuICBwcm9jZXNzVXBkYXRlQ29sbGVjdGlvbkNvbmZpZyxcbiAgcmVjb3JkU2V0RmllbGRzLFxuICByZWdpc3RlckVtYmVkZGluZ0Z1bmN0aW9uLFxuICBzZXJpYWxpemVFbWJlZGRpbmdGdW5jdGlvbixcbiAgd2l0aENocm9tYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNocm9tYWRiLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chromadb.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __publicField: () => (/* binding */ __publicField)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n//# sourceMappingURL=chunk-NSSMTXJJ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vY2hyb21hZGJAMy4wLjE3L25vZGVfbW9kdWxlcy9jaHJvbWFkYi9kaXN0L2NodW5rLU5TU01UWEpKLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVucm91dGVyLWxhbmdncmFwaC8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaHJvbWFkYkAzLjAuMTcvbm9kZV9tb2R1bGVzL2Nocm9tYWRiL2Rpc3QvY2h1bmstTlNTTVRYSkoubWpzP2E5YjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcblxuZXhwb3J0IHtcbiAgX19wdWJsaWNGaWVsZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU5TU01UWEpKLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/chromadb@3.0.17/node_modules/chromadb/dist/chunk-NSSMTXJJ.mjs\n");

/***/ })

};
;