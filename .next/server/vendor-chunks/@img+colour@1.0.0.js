/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@img+colour@1.0.0";
exports.ids = ["vendor-chunks/@img+colour@1.0.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/color.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/color.cjs ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// node_modules/color/index.js\nvar index_exports = {};\n__export(index_exports, {\n  default: () => index_default\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// node_modules/color-name/index.js\nvar color_name_default = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  grey: [128, 128, 128],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  rebeccapurple: [102, 51, 153],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\n// node_modules/color-string/index.js\nvar reverseNames = /* @__PURE__ */ Object.create(null);\nfor (const name in color_name_default) {\n  if (Object.hasOwn(color_name_default, name)) {\n    reverseNames[color_name_default[name]] = name;\n  }\n}\nvar cs = {\n  to: {},\n  get: {}\n};\ncs.get = function(string) {\n  const prefix = string.slice(0, 3).toLowerCase();\n  let value;\n  let model;\n  switch (prefix) {\n    case \"hsl\": {\n      value = cs.get.hsl(string);\n      model = \"hsl\";\n      break;\n    }\n    case \"hwb\": {\n      value = cs.get.hwb(string);\n      model = \"hwb\";\n      break;\n    }\n    default: {\n      value = cs.get.rgb(string);\n      model = \"rgb\";\n      break;\n    }\n  }\n  if (!value) {\n    return null;\n  }\n  return { model, value };\n};\ncs.get.rgb = function(string) {\n  if (!string) {\n    return null;\n  }\n  const abbr = /^#([a-f\\d]{3,4})$/i;\n  const hex = /^#([a-f\\d]{6})([a-f\\d]{2})?$/i;\n  const rgba = /^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[\\s,|/]\\s*([+-]?[\\d.]+)(%?)\\s*)?\\)$/;\n  const per = /^rgba?\\(\\s*([+-]?[\\d.]+)%\\s*,?\\s*([+-]?[\\d.]+)%\\s*,?\\s*([+-]?[\\d.]+)%\\s*(?:[\\s,|/]\\s*([+-]?[\\d.]+)(%?)\\s*)?\\)$/;\n  const keyword = /^(\\w+)$/;\n  let rgb = [0, 0, 0, 1];\n  let match;\n  let i;\n  let hexAlpha;\n  if (match = string.match(hex)) {\n    hexAlpha = match[2];\n    match = match[1];\n    for (i = 0; i < 3; i++) {\n      const i2 = i * 2;\n      rgb[i] = Number.parseInt(match.slice(i2, i2 + 2), 16);\n    }\n    if (hexAlpha) {\n      rgb[3] = Number.parseInt(hexAlpha, 16) / 255;\n    }\n  } else if (match = string.match(abbr)) {\n    match = match[1];\n    hexAlpha = match[3];\n    for (i = 0; i < 3; i++) {\n      rgb[i] = Number.parseInt(match[i] + match[i], 16);\n    }\n    if (hexAlpha) {\n      rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;\n    }\n  } else if (match = string.match(rgba)) {\n    for (i = 0; i < 3; i++) {\n      rgb[i] = Number.parseInt(match[i + 1], 10);\n    }\n    if (match[4]) {\n      rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);\n    }\n  } else if (match = string.match(per)) {\n    for (i = 0; i < 3; i++) {\n      rgb[i] = Math.round(Number.parseFloat(match[i + 1]) * 2.55);\n    }\n    if (match[4]) {\n      rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);\n    }\n  } else if (match = string.match(keyword)) {\n    if (match[1] === \"transparent\") {\n      return [0, 0, 0, 0];\n    }\n    if (!Object.hasOwn(color_name_default, match[1])) {\n      return null;\n    }\n    rgb = color_name_default[match[1]];\n    rgb[3] = 1;\n    return rgb;\n  } else {\n    return null;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] = clamp(rgb[i], 0, 255);\n  }\n  rgb[3] = clamp(rgb[3], 0, 1);\n  return rgb;\n};\ncs.get.hsl = function(string) {\n  if (!string) {\n    return null;\n  }\n  const hsl = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d.]+)%\\s*,?\\s*([+-]?[\\d.]+)%\\s*(?:[,|/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n  const match = string.match(hsl);\n  if (match) {\n    const alpha = Number.parseFloat(match[4]);\n    const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;\n    const s = clamp(Number.parseFloat(match[2]), 0, 100);\n    const l = clamp(Number.parseFloat(match[3]), 0, 100);\n    const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);\n    return [h, s, l, a];\n  }\n  return null;\n};\ncs.get.hwb = function(string) {\n  if (!string) {\n    return null;\n  }\n  const hwb = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*[\\s,]\\s*([+-]?[\\d.]+)%\\s*[\\s,]\\s*([+-]?[\\d.]+)%\\s*(?:[\\s,]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n  const match = string.match(hwb);\n  if (match) {\n    const alpha = Number.parseFloat(match[4]);\n    const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;\n    const w = clamp(Number.parseFloat(match[2]), 0, 100);\n    const b = clamp(Number.parseFloat(match[3]), 0, 100);\n    const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);\n    return [h, w, b, a];\n  }\n  return null;\n};\ncs.to.hex = function(...rgba) {\n  return \"#\" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : \"\");\n};\ncs.to.rgb = function(...rgba) {\n  return rgba.length < 4 || rgba[3] === 1 ? \"rgb(\" + Math.round(rgba[0]) + \", \" + Math.round(rgba[1]) + \", \" + Math.round(rgba[2]) + \")\" : \"rgba(\" + Math.round(rgba[0]) + \", \" + Math.round(rgba[1]) + \", \" + Math.round(rgba[2]) + \", \" + rgba[3] + \")\";\n};\ncs.to.rgb.percent = function(...rgba) {\n  const r = Math.round(rgba[0] / 255 * 100);\n  const g = Math.round(rgba[1] / 255 * 100);\n  const b = Math.round(rgba[2] / 255 * 100);\n  return rgba.length < 4 || rgba[3] === 1 ? \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\" : \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + rgba[3] + \")\";\n};\ncs.to.hsl = function(...hsla) {\n  return hsla.length < 4 || hsla[3] === 1 ? \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\" : \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \" + hsla[3] + \")\";\n};\ncs.to.hwb = function(...hwba) {\n  let a = \"\";\n  if (hwba.length >= 4 && hwba[3] !== 1) {\n    a = \", \" + hwba[3];\n  }\n  return \"hwb(\" + hwba[0] + \", \" + hwba[1] + \"%, \" + hwba[2] + \"%\" + a + \")\";\n};\ncs.to.keyword = function(...rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n};\nfunction clamp(number_, min, max) {\n  return Math.min(Math.max(min, number_), max);\n}\nfunction hexDouble(number_) {\n  const string_ = Math.round(number_).toString(16).toUpperCase();\n  return string_.length < 2 ? \"0\" + string_ : string_;\n}\nvar color_string_default = cs;\n\n// node_modules/color-convert/conversions.js\nvar reverseKeywords = {};\nfor (const key of Object.keys(color_name_default)) {\n  reverseKeywords[color_name_default[key]] = key;\n}\nvar convert = {\n  rgb: { channels: 3, labels: \"rgb\" },\n  hsl: { channels: 3, labels: \"hsl\" },\n  hsv: { channels: 3, labels: \"hsv\" },\n  hwb: { channels: 3, labels: \"hwb\" },\n  cmyk: { channels: 4, labels: \"cmyk\" },\n  xyz: { channels: 3, labels: \"xyz\" },\n  lab: { channels: 3, labels: \"lab\" },\n  oklab: { channels: 3, labels: [\"okl\", \"oka\", \"okb\"] },\n  lch: { channels: 3, labels: \"lch\" },\n  oklch: { channels: 3, labels: [\"okl\", \"okc\", \"okh\"] },\n  hex: { channels: 1, labels: [\"hex\"] },\n  keyword: { channels: 1, labels: [\"keyword\"] },\n  ansi16: { channels: 1, labels: [\"ansi16\"] },\n  ansi256: { channels: 1, labels: [\"ansi256\"] },\n  hcg: { channels: 3, labels: [\"h\", \"c\", \"g\"] },\n  apple: { channels: 3, labels: [\"r16\", \"g16\", \"b16\"] },\n  gray: { channels: 1, labels: [\"gray\"] }\n};\nvar conversions_default = convert;\nvar LAB_FT = (6 / 29) ** 3;\nfunction srgbNonlinearTransform(c) {\n  const cc = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92;\n  return Math.min(Math.max(0, cc), 1);\n}\nfunction srgbNonlinearTransformInv(c) {\n  return c > 0.04045 ? ((c + 0.055) / 1.055) ** 2.4 : c / 12.92;\n}\nfor (const model of Object.keys(convert)) {\n  if (!(\"channels\" in convert[model])) {\n    throw new Error(\"missing channels property: \" + model);\n  }\n  if (!(\"labels\" in convert[model])) {\n    throw new Error(\"missing channel labels property: \" + model);\n  }\n  if (convert[model].labels.length !== convert[model].channels) {\n    throw new Error(\"channel and label counts mismatch: \" + model);\n  }\n  const { channels, labels } = convert[model];\n  delete convert[model].channels;\n  delete convert[model].labels;\n  Object.defineProperty(convert[model], \"channels\", { value: channels });\n  Object.defineProperty(convert[model], \"labels\", { value: labels });\n}\nconvert.rgb.hsl = function(rgb) {\n  const r = rgb[0] / 255;\n  const g = rgb[1] / 255;\n  const b = rgb[2] / 255;\n  const min = Math.min(r, g, b);\n  const max = Math.max(r, g, b);\n  const delta = max - min;\n  let h;\n  let s;\n  switch (max) {\n    case min: {\n      h = 0;\n      break;\n    }\n    case r: {\n      h = (g - b) / delta;\n      break;\n    }\n    case g: {\n      h = 2 + (b - r) / delta;\n      break;\n    }\n    case b: {\n      h = 4 + (r - g) / delta;\n      break;\n    }\n  }\n  h = Math.min(h * 60, 360);\n  if (h < 0) {\n    h += 360;\n  }\n  const l = (min + max) / 2;\n  if (max === min) {\n    s = 0;\n  } else if (l <= 0.5) {\n    s = delta / (max + min);\n  } else {\n    s = delta / (2 - max - min);\n  }\n  return [h, s * 100, l * 100];\n};\nconvert.rgb.hsv = function(rgb) {\n  let rdif;\n  let gdif;\n  let bdif;\n  let h;\n  let s;\n  const r = rgb[0] / 255;\n  const g = rgb[1] / 255;\n  const b = rgb[2] / 255;\n  const v = Math.max(r, g, b);\n  const diff = v - Math.min(r, g, b);\n  const diffc = function(c) {\n    return (v - c) / 6 / diff + 1 / 2;\n  };\n  if (diff === 0) {\n    h = 0;\n    s = 0;\n  } else {\n    s = diff / v;\n    rdif = diffc(r);\n    gdif = diffc(g);\n    bdif = diffc(b);\n    switch (v) {\n      case r: {\n        h = bdif - gdif;\n        break;\n      }\n      case g: {\n        h = 1 / 3 + rdif - bdif;\n        break;\n      }\n      case b: {\n        h = 2 / 3 + gdif - rdif;\n        break;\n      }\n    }\n    if (h < 0) {\n      h += 1;\n    } else if (h > 1) {\n      h -= 1;\n    }\n  }\n  return [\n    h * 360,\n    s * 100,\n    v * 100\n  ];\n};\nconvert.rgb.hwb = function(rgb) {\n  const r = rgb[0];\n  const g = rgb[1];\n  let b = rgb[2];\n  const h = convert.rgb.hsl(rgb)[0];\n  const w = 1 / 255 * Math.min(r, Math.min(g, b));\n  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n  return [h, w * 100, b * 100];\n};\nconvert.rgb.oklab = function(rgb) {\n  const r = srgbNonlinearTransformInv(rgb[0] / 255);\n  const g = srgbNonlinearTransformInv(rgb[1] / 255);\n  const b = srgbNonlinearTransformInv(rgb[2] / 255);\n  const lp = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);\n  const mp = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);\n  const sp = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);\n  const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;\n  const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;\n  const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;\n  return [l * 100, aa * 100, bb * 100];\n};\nconvert.rgb.cmyk = function(rgb) {\n  const r = rgb[0] / 255;\n  const g = rgb[1] / 255;\n  const b = rgb[2] / 255;\n  const k = Math.min(1 - r, 1 - g, 1 - b);\n  const c = (1 - r - k) / (1 - k) || 0;\n  const m = (1 - g - k) / (1 - k) || 0;\n  const y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n};\nfunction comparativeDistance(x, y) {\n  return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;\n}\nconvert.rgb.keyword = function(rgb) {\n  const reversed = reverseKeywords[rgb];\n  if (reversed) {\n    return reversed;\n  }\n  let currentClosestDistance = Number.POSITIVE_INFINITY;\n  let currentClosestKeyword;\n  for (const keyword of Object.keys(color_name_default)) {\n    const value = color_name_default[keyword];\n    const distance = comparativeDistance(rgb, value);\n    if (distance < currentClosestDistance) {\n      currentClosestDistance = distance;\n      currentClosestKeyword = keyword;\n    }\n  }\n  return currentClosestKeyword;\n};\nconvert.keyword.rgb = function(keyword) {\n  return color_name_default[keyword];\n};\nconvert.rgb.xyz = function(rgb) {\n  const r = srgbNonlinearTransformInv(rgb[0] / 255);\n  const g = srgbNonlinearTransformInv(rgb[1] / 255);\n  const b = srgbNonlinearTransformInv(rgb[2] / 255);\n  const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;\n  const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;\n  const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;\n  return [x * 100, y * 100, z * 100];\n};\nconvert.rgb.lab = function(rgb) {\n  const xyz = convert.rgb.xyz(rgb);\n  let x = xyz[0];\n  let y = xyz[1];\n  let z = xyz[2];\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n  x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;\n  y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;\n  z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;\n  const l = 116 * y - 16;\n  const a = 500 * (x - y);\n  const b = 200 * (y - z);\n  return [l, a, b];\n};\nconvert.hsl.rgb = function(hsl) {\n  const h = hsl[0] / 360;\n  const s = hsl[1] / 100;\n  const l = hsl[2] / 100;\n  let t3;\n  let value;\n  if (s === 0) {\n    value = l * 255;\n    return [value, value, value];\n  }\n  const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const t1 = 2 * l - t2;\n  const rgb = [0, 0, 0];\n  for (let i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * -(i - 1);\n    if (t3 < 0) {\n      t3++;\n    }\n    if (t3 > 1) {\n      t3--;\n    }\n    if (6 * t3 < 1) {\n      value = t1 + (t2 - t1) * 6 * t3;\n    } else if (2 * t3 < 1) {\n      value = t2;\n    } else if (3 * t3 < 2) {\n      value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    } else {\n      value = t1;\n    }\n    rgb[i] = value * 255;\n  }\n  return rgb;\n};\nconvert.hsl.hsv = function(hsl) {\n  const h = hsl[0];\n  let s = hsl[1] / 100;\n  let l = hsl[2] / 100;\n  let smin = s;\n  const lmin = Math.max(l, 0.01);\n  l *= 2;\n  s *= l <= 1 ? l : 2 - l;\n  smin *= lmin <= 1 ? lmin : 2 - lmin;\n  const v = (l + s) / 2;\n  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n  return [h, sv * 100, v * 100];\n};\nconvert.hsv.rgb = function(hsv) {\n  const h = hsv[0] / 60;\n  const s = hsv[1] / 100;\n  let v = hsv[2] / 100;\n  const hi = Math.floor(h) % 6;\n  const f = h - Math.floor(h);\n  const p = 255 * v * (1 - s);\n  const q = 255 * v * (1 - s * f);\n  const t = 255 * v * (1 - s * (1 - f));\n  v *= 255;\n  switch (hi) {\n    case 0: {\n      return [v, t, p];\n    }\n    case 1: {\n      return [q, v, p];\n    }\n    case 2: {\n      return [p, v, t];\n    }\n    case 3: {\n      return [p, q, v];\n    }\n    case 4: {\n      return [t, p, v];\n    }\n    case 5: {\n      return [v, p, q];\n    }\n  }\n};\nconvert.hsv.hsl = function(hsv) {\n  const h = hsv[0];\n  const s = hsv[1] / 100;\n  const v = hsv[2] / 100;\n  const vmin = Math.max(v, 0.01);\n  let sl;\n  let l;\n  l = (2 - s) * v;\n  const lmin = (2 - s) * vmin;\n  sl = s * vmin;\n  sl /= lmin <= 1 ? lmin : 2 - lmin;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n};\nconvert.hwb.rgb = function(hwb) {\n  const h = hwb[0] / 360;\n  let wh = hwb[1] / 100;\n  let bl = hwb[2] / 100;\n  const ratio = wh + bl;\n  let f;\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n  const i = Math.floor(6 * h);\n  const v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 1) !== 0) {\n    f = 1 - f;\n  }\n  const n = wh + f * (v - wh);\n  let r;\n  let g;\n  let b;\n  switch (i) {\n    default:\n    case 6:\n    case 0: {\n      r = v;\n      g = n;\n      b = wh;\n      break;\n    }\n    case 1: {\n      r = n;\n      g = v;\n      b = wh;\n      break;\n    }\n    case 2: {\n      r = wh;\n      g = v;\n      b = n;\n      break;\n    }\n    case 3: {\n      r = wh;\n      g = n;\n      b = v;\n      break;\n    }\n    case 4: {\n      r = n;\n      g = wh;\n      b = v;\n      break;\n    }\n    case 5: {\n      r = v;\n      g = wh;\n      b = n;\n      break;\n    }\n  }\n  return [r * 255, g * 255, b * 255];\n};\nconvert.cmyk.rgb = function(cmyk) {\n  const c = cmyk[0] / 100;\n  const m = cmyk[1] / 100;\n  const y = cmyk[2] / 100;\n  const k = cmyk[3] / 100;\n  const r = 1 - Math.min(1, c * (1 - k) + k);\n  const g = 1 - Math.min(1, m * (1 - k) + k);\n  const b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n};\nconvert.xyz.rgb = function(xyz) {\n  const x = xyz[0] / 100;\n  const y = xyz[1] / 100;\n  const z = xyz[2] / 100;\n  let r;\n  let g;\n  let b;\n  r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;\n  g = x * -0.969266 + y * 1.8760108 + z * 0.041556;\n  b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;\n  r = srgbNonlinearTransform(r);\n  g = srgbNonlinearTransform(g);\n  b = srgbNonlinearTransform(b);\n  return [r * 255, g * 255, b * 255];\n};\nconvert.xyz.lab = function(xyz) {\n  let x = xyz[0];\n  let y = xyz[1];\n  let z = xyz[2];\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n  x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;\n  y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;\n  z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;\n  const l = 116 * y - 16;\n  const a = 500 * (x - y);\n  const b = 200 * (y - z);\n  return [l, a, b];\n};\nconvert.xyz.oklab = function(xyz) {\n  const x = xyz[0] / 100;\n  const y = xyz[1] / 100;\n  const z = xyz[2] / 100;\n  const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z);\n  const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z);\n  const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z);\n  const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;\n  const a = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;\n  const b = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;\n  return [l * 100, a * 100, b * 100];\n};\nconvert.oklab.oklch = function(oklab) {\n  return convert.lab.lch(oklab);\n};\nconvert.oklab.xyz = function(oklab) {\n  const ll = oklab[0] / 100;\n  const a = oklab[1] / 100;\n  const b = oklab[2] / 100;\n  const l = (0.999999998 * ll + 0.396337792 * a + 0.215803758 * b) ** 3;\n  const m = (1.000000008 * ll - 0.105561342 * a - 0.063854175 * b) ** 3;\n  const s = (1.000000055 * ll - 0.089484182 * a - 1.291485538 * b) ** 3;\n  const x = 1.227013851 * l - 0.55779998 * m + 0.281256149 * s;\n  const y = -0.040580178 * l + 1.11225687 * m - 0.071676679 * s;\n  const z = -0.076381285 * l - 0.421481978 * m + 1.58616322 * s;\n  return [x * 100, y * 100, z * 100];\n};\nconvert.oklab.rgb = function(oklab) {\n  const ll = oklab[0] / 100;\n  const aa = oklab[1] / 100;\n  const bb = oklab[2] / 100;\n  const l = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;\n  const m = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;\n  const s = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;\n  const r = srgbNonlinearTransform(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s);\n  const g = srgbNonlinearTransform(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s);\n  const b = srgbNonlinearTransform(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s);\n  return [r * 255, g * 255, b * 255];\n};\nconvert.oklch.oklab = function(oklch) {\n  return convert.lch.lab(oklch);\n};\nconvert.lab.xyz = function(lab) {\n  const l = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  let x;\n  let y;\n  let z;\n  y = (l + 16) / 116;\n  x = a / 500 + y;\n  z = y - b / 200;\n  const y2 = y ** 3;\n  const x2 = x ** 3;\n  const z2 = z ** 3;\n  y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;\n  x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;\n  z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;\n  x *= 95.047;\n  y *= 100;\n  z *= 108.883;\n  return [x, y, z];\n};\nconvert.lab.lch = function(lab) {\n  const l = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  let h;\n  const hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  const c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n};\nconvert.lch.lab = function(lch) {\n  const l = lch[0];\n  const c = lch[1];\n  const h = lch[2];\n  const hr = h / 360 * 2 * Math.PI;\n  const a = c * Math.cos(hr);\n  const b = c * Math.sin(hr);\n  return [l, a, b];\n};\nconvert.rgb.ansi16 = function(args, saturation = null) {\n  const [r, g, b] = args;\n  let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;\n  value = Math.round(value / 50);\n  if (value === 0) {\n    return 30;\n  }\n  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n  if (value === 2) {\n    ansi += 60;\n  }\n  return ansi;\n};\nconvert.hsv.ansi16 = function(args) {\n  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\nconvert.rgb.ansi256 = function(args) {\n  const r = args[0];\n  const g = args[1];\n  const b = args[2];\n  if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {\n    if (r < 8) {\n      return 16;\n    }\n    if (r > 248) {\n      return 231;\n    }\n    return Math.round((r - 8) / 247 * 24) + 232;\n  }\n  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n  return ansi;\n};\nconvert.ansi16.rgb = function(args) {\n  args = args[0];\n  let color = args % 10;\n  if (color === 0 || color === 7) {\n    if (args > 50) {\n      color += 3.5;\n    }\n    color = color / 10.5 * 255;\n    return [color, color, color];\n  }\n  const mult = (Math.trunc(args > 50) + 1) * 0.5;\n  const r = (color & 1) * mult * 255;\n  const g = (color >> 1 & 1) * mult * 255;\n  const b = (color >> 2 & 1) * mult * 255;\n  return [r, g, b];\n};\nconvert.ansi256.rgb = function(args) {\n  args = args[0];\n  if (args >= 232) {\n    const c = (args - 232) * 10 + 8;\n    return [c, c, c];\n  }\n  args -= 16;\n  let rem;\n  const r = Math.floor(args / 36) / 5 * 255;\n  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n  const b = rem % 6 / 5 * 255;\n  return [r, g, b];\n};\nconvert.rgb.hex = function(args) {\n  const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);\n  const string = integer.toString(16).toUpperCase();\n  return \"000000\".slice(string.length) + string;\n};\nconvert.hex.rgb = function(args) {\n  const match = args.toString(16).match(/[a-f\\d]{6}|[a-f\\d]{3}/i);\n  if (!match) {\n    return [0, 0, 0];\n  }\n  let colorString = match[0];\n  if (match[0].length === 3) {\n    colorString = [...colorString].map((char) => char + char).join(\"\");\n  }\n  const integer = Number.parseInt(colorString, 16);\n  const r = integer >> 16 & 255;\n  const g = integer >> 8 & 255;\n  const b = integer & 255;\n  return [r, g, b];\n};\nconvert.rgb.hcg = function(rgb) {\n  const r = rgb[0] / 255;\n  const g = rgb[1] / 255;\n  const b = rgb[2] / 255;\n  const max = Math.max(Math.max(r, g), b);\n  const min = Math.min(Math.min(r, g), b);\n  const chroma = max - min;\n  let hue;\n  const grayscale = chroma < 1 ? min / (1 - chroma) : 0;\n  if (chroma <= 0) {\n    hue = 0;\n  } else if (max === r) {\n    hue = (g - b) / chroma % 6;\n  } else if (max === g) {\n    hue = 2 + (b - r) / chroma;\n  } else {\n    hue = 4 + (r - g) / chroma;\n  }\n  hue /= 6;\n  hue %= 1;\n  return [hue * 360, chroma * 100, grayscale * 100];\n};\nconvert.hsl.hcg = function(hsl) {\n  const s = hsl[1] / 100;\n  const l = hsl[2] / 100;\n  const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);\n  let f = 0;\n  if (c < 1) {\n    f = (l - 0.5 * c) / (1 - c);\n  }\n  return [hsl[0], c * 100, f * 100];\n};\nconvert.hsv.hcg = function(hsv) {\n  const s = hsv[1] / 100;\n  const v = hsv[2] / 100;\n  const c = s * v;\n  let f = 0;\n  if (c < 1) {\n    f = (v - c) / (1 - c);\n  }\n  return [hsv[0], c * 100, f * 100];\n};\nconvert.hcg.rgb = function(hcg) {\n  const h = hcg[0] / 360;\n  const c = hcg[1] / 100;\n  const g = hcg[2] / 100;\n  if (c === 0) {\n    return [g * 255, g * 255, g * 255];\n  }\n  const pure = [0, 0, 0];\n  const hi = h % 1 * 6;\n  const v = hi % 1;\n  const w = 1 - v;\n  let mg = 0;\n  switch (Math.floor(hi)) {\n    case 0: {\n      pure[0] = 1;\n      pure[1] = v;\n      pure[2] = 0;\n      break;\n    }\n    case 1: {\n      pure[0] = w;\n      pure[1] = 1;\n      pure[2] = 0;\n      break;\n    }\n    case 2: {\n      pure[0] = 0;\n      pure[1] = 1;\n      pure[2] = v;\n      break;\n    }\n    case 3: {\n      pure[0] = 0;\n      pure[1] = w;\n      pure[2] = 1;\n      break;\n    }\n    case 4: {\n      pure[0] = v;\n      pure[1] = 0;\n      pure[2] = 1;\n      break;\n    }\n    default: {\n      pure[0] = 1;\n      pure[1] = 0;\n      pure[2] = w;\n    }\n  }\n  mg = (1 - c) * g;\n  return [\n    (c * pure[0] + mg) * 255,\n    (c * pure[1] + mg) * 255,\n    (c * pure[2] + mg) * 255\n  ];\n};\nconvert.hcg.hsv = function(hcg) {\n  const c = hcg[1] / 100;\n  const g = hcg[2] / 100;\n  const v = c + g * (1 - c);\n  let f = 0;\n  if (v > 0) {\n    f = c / v;\n  }\n  return [hcg[0], f * 100, v * 100];\n};\nconvert.hcg.hsl = function(hcg) {\n  const c = hcg[1] / 100;\n  const g = hcg[2] / 100;\n  const l = g * (1 - c) + 0.5 * c;\n  let s = 0;\n  if (l > 0 && l < 0.5) {\n    s = c / (2 * l);\n  } else if (l >= 0.5 && l < 1) {\n    s = c / (2 * (1 - l));\n  }\n  return [hcg[0], s * 100, l * 100];\n};\nconvert.hcg.hwb = function(hcg) {\n  const c = hcg[1] / 100;\n  const g = hcg[2] / 100;\n  const v = c + g * (1 - c);\n  return [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\nconvert.hwb.hcg = function(hwb) {\n  const w = hwb[1] / 100;\n  const b = hwb[2] / 100;\n  const v = 1 - b;\n  const c = v - w;\n  let g = 0;\n  if (c < 1) {\n    g = (v - c) / (1 - c);\n  }\n  return [hwb[0], c * 100, g * 100];\n};\nconvert.apple.rgb = function(apple) {\n  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n};\nconvert.rgb.apple = function(rgb) {\n  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n};\nconvert.gray.rgb = function(args) {\n  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\nconvert.gray.hsl = function(args) {\n  return [0, 0, args[0]];\n};\nconvert.gray.hsv = convert.gray.hsl;\nconvert.gray.hwb = function(gray) {\n  return [0, 100, gray[0]];\n};\nconvert.gray.cmyk = function(gray) {\n  return [0, 0, 0, gray[0]];\n};\nconvert.gray.lab = function(gray) {\n  return [gray[0], 0, 0];\n};\nconvert.gray.hex = function(gray) {\n  const value = Math.round(gray[0] / 100 * 255) & 255;\n  const integer = (value << 16) + (value << 8) + value;\n  const string = integer.toString(16).toUpperCase();\n  return \"000000\".slice(string.length) + string;\n};\nconvert.rgb.gray = function(rgb) {\n  const value = (rgb[0] + rgb[1] + rgb[2]) / 3;\n  return [value / 255 * 100];\n};\n\n// node_modules/color-convert/route.js\nfunction buildGraph() {\n  const graph = {};\n  const models2 = Object.keys(conversions_default);\n  for (let { length } = models2, i = 0; i < length; i++) {\n    graph[models2[i]] = {\n      // http://jsperf.com/1-vs-infinity\n      // micro-opt, but this is simple.\n      distance: -1,\n      parent: null\n    };\n  }\n  return graph;\n}\nfunction deriveBFS(fromModel) {\n  const graph = buildGraph();\n  const queue = [fromModel];\n  graph[fromModel].distance = 0;\n  while (queue.length > 0) {\n    const current = queue.pop();\n    const adjacents = Object.keys(conversions_default[current]);\n    for (let { length } = adjacents, i = 0; i < length; i++) {\n      const adjacent = adjacents[i];\n      const node = graph[adjacent];\n      if (node.distance === -1) {\n        node.distance = graph[current].distance + 1;\n        node.parent = current;\n        queue.unshift(adjacent);\n      }\n    }\n  }\n  return graph;\n}\nfunction link(from, to) {\n  return function(args) {\n    return to(from(args));\n  };\n}\nfunction wrapConversion(toModel, graph) {\n  const path = [graph[toModel].parent, toModel];\n  let fn = conversions_default[graph[toModel].parent][toModel];\n  let cur = graph[toModel].parent;\n  while (graph[cur].parent) {\n    path.unshift(graph[cur].parent);\n    fn = link(conversions_default[graph[cur].parent][cur], fn);\n    cur = graph[cur].parent;\n  }\n  fn.conversion = path;\n  return fn;\n}\nfunction route(fromModel) {\n  const graph = deriveBFS(fromModel);\n  const conversion = {};\n  const models2 = Object.keys(graph);\n  for (let { length } = models2, i = 0; i < length; i++) {\n    const toModel = models2[i];\n    const node = graph[toModel];\n    if (node.parent === null) {\n      continue;\n    }\n    conversion[toModel] = wrapConversion(toModel, graph);\n  }\n  return conversion;\n}\nvar route_default = route;\n\n// node_modules/color-convert/index.js\nvar convert2 = {};\nvar models = Object.keys(conversions_default);\nfunction wrapRaw(fn) {\n  const wrappedFn = function(...args) {\n    const arg0 = args[0];\n    if (arg0 === void 0 || arg0 === null) {\n      return arg0;\n    }\n    if (arg0.length > 1) {\n      args = arg0;\n    }\n    return fn(args);\n  };\n  if (\"conversion\" in fn) {\n    wrappedFn.conversion = fn.conversion;\n  }\n  return wrappedFn;\n}\nfunction wrapRounded(fn) {\n  const wrappedFn = function(...args) {\n    const arg0 = args[0];\n    if (arg0 === void 0 || arg0 === null) {\n      return arg0;\n    }\n    if (arg0.length > 1) {\n      args = arg0;\n    }\n    const result = fn(args);\n    if (typeof result === \"object\") {\n      for (let { length } = result, i = 0; i < length; i++) {\n        result[i] = Math.round(result[i]);\n      }\n    }\n    return result;\n  };\n  if (\"conversion\" in fn) {\n    wrappedFn.conversion = fn.conversion;\n  }\n  return wrappedFn;\n}\nfor (const fromModel of models) {\n  convert2[fromModel] = {};\n  Object.defineProperty(convert2[fromModel], \"channels\", { value: conversions_default[fromModel].channels });\n  Object.defineProperty(convert2[fromModel], \"labels\", { value: conversions_default[fromModel].labels });\n  const routes = route_default(fromModel);\n  const routeModels = Object.keys(routes);\n  for (const toModel of routeModels) {\n    const fn = routes[toModel];\n    convert2[fromModel][toModel] = wrapRounded(fn);\n    convert2[fromModel][toModel].raw = wrapRaw(fn);\n  }\n}\nvar color_convert_default = convert2;\n\n// node_modules/color/index.js\nvar skippedModels = [\n  // To be honest, I don't really feel like keyword belongs in color convert, but eh.\n  \"keyword\",\n  // Gray conflicts with some method names, and has its own method defined.\n  \"gray\",\n  // Shouldn't really be in color-convert either...\n  \"hex\"\n];\nvar hashedModelKeys = {};\nfor (const model of Object.keys(color_convert_default)) {\n  hashedModelKeys[[...color_convert_default[model].labels].sort().join(\"\")] = model;\n}\nvar limiters = {};\nfunction Color(object, model) {\n  if (!(this instanceof Color)) {\n    return new Color(object, model);\n  }\n  if (model && model in skippedModels) {\n    model = null;\n  }\n  if (model && !(model in color_convert_default)) {\n    throw new Error(\"Unknown model: \" + model);\n  }\n  let i;\n  let channels;\n  if (object == null) {\n    this.model = \"rgb\";\n    this.color = [0, 0, 0];\n    this.valpha = 1;\n  } else if (object instanceof Color) {\n    this.model = object.model;\n    this.color = [...object.color];\n    this.valpha = object.valpha;\n  } else if (typeof object === \"string\") {\n    const result = color_string_default.get(object);\n    if (result === null) {\n      throw new Error(\"Unable to parse color from string: \" + object);\n    }\n    this.model = result.model;\n    channels = color_convert_default[this.model].channels;\n    this.color = result.value.slice(0, channels);\n    this.valpha = typeof result.value[channels] === \"number\" ? result.value[channels] : 1;\n  } else if (object.length > 0) {\n    this.model = model || \"rgb\";\n    channels = color_convert_default[this.model].channels;\n    const newArray = Array.prototype.slice.call(object, 0, channels);\n    this.color = zeroArray(newArray, channels);\n    this.valpha = typeof object[channels] === \"number\" ? object[channels] : 1;\n  } else if (typeof object === \"number\") {\n    this.model = \"rgb\";\n    this.color = [\n      object >> 16 & 255,\n      object >> 8 & 255,\n      object & 255\n    ];\n    this.valpha = 1;\n  } else {\n    this.valpha = 1;\n    const keys = Object.keys(object);\n    if (\"alpha\" in object) {\n      keys.splice(keys.indexOf(\"alpha\"), 1);\n      this.valpha = typeof object.alpha === \"number\" ? object.alpha : 0;\n    }\n    const hashedKeys = keys.sort().join(\"\");\n    if (!(hashedKeys in hashedModelKeys)) {\n      throw new Error(\"Unable to parse color from object: \" + JSON.stringify(object));\n    }\n    this.model = hashedModelKeys[hashedKeys];\n    const { labels } = color_convert_default[this.model];\n    const color = [];\n    for (i = 0; i < labels.length; i++) {\n      color.push(object[labels[i]]);\n    }\n    this.color = zeroArray(color);\n  }\n  if (limiters[this.model]) {\n    channels = color_convert_default[this.model].channels;\n    for (i = 0; i < channels; i++) {\n      const limit = limiters[this.model][i];\n      if (limit) {\n        this.color[i] = limit(this.color[i]);\n      }\n    }\n  }\n  this.valpha = Math.max(0, Math.min(1, this.valpha));\n  if (Object.freeze) {\n    Object.freeze(this);\n  }\n}\nColor.prototype = {\n  toString() {\n    return this.string();\n  },\n  toJSON() {\n    return this[this.model]();\n  },\n  string(places) {\n    let self = this.model in color_string_default.to ? this : this.rgb();\n    self = self.round(typeof places === \"number\" ? places : 1);\n    const arguments_ = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n    return color_string_default.to[self.model](...arguments_);\n  },\n  percentString(places) {\n    const self = this.rgb().round(typeof places === \"number\" ? places : 1);\n    const arguments_ = self.valpha === 1 ? self.color : [...self.color, this.valpha];\n    return color_string_default.to.rgb.percent(...arguments_);\n  },\n  array() {\n    return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];\n  },\n  object() {\n    const result = {};\n    const { channels } = color_convert_default[this.model];\n    const { labels } = color_convert_default[this.model];\n    for (let i = 0; i < channels; i++) {\n      result[labels[i]] = this.color[i];\n    }\n    if (this.valpha !== 1) {\n      result.alpha = this.valpha;\n    }\n    return result;\n  },\n  unitArray() {\n    const rgb = this.rgb().color;\n    rgb[0] /= 255;\n    rgb[1] /= 255;\n    rgb[2] /= 255;\n    if (this.valpha !== 1) {\n      rgb.push(this.valpha);\n    }\n    return rgb;\n  },\n  unitObject() {\n    const rgb = this.rgb().object();\n    rgb.r /= 255;\n    rgb.g /= 255;\n    rgb.b /= 255;\n    if (this.valpha !== 1) {\n      rgb.alpha = this.valpha;\n    }\n    return rgb;\n  },\n  round(places) {\n    places = Math.max(places || 0, 0);\n    return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);\n  },\n  alpha(value) {\n    if (value !== void 0) {\n      return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);\n    }\n    return this.valpha;\n  },\n  // Rgb\n  red: getset(\"rgb\", 0, maxfn(255)),\n  green: getset(\"rgb\", 1, maxfn(255)),\n  blue: getset(\"rgb\", 2, maxfn(255)),\n  hue: getset([\"hsl\", \"hsv\", \"hsl\", \"hwb\", \"hcg\"], 0, (value) => (value % 360 + 360) % 360),\n  saturationl: getset(\"hsl\", 1, maxfn(100)),\n  lightness: getset(\"hsl\", 2, maxfn(100)),\n  saturationv: getset(\"hsv\", 1, maxfn(100)),\n  value: getset(\"hsv\", 2, maxfn(100)),\n  chroma: getset(\"hcg\", 1, maxfn(100)),\n  gray: getset(\"hcg\", 2, maxfn(100)),\n  white: getset(\"hwb\", 1, maxfn(100)),\n  wblack: getset(\"hwb\", 2, maxfn(100)),\n  cyan: getset(\"cmyk\", 0, maxfn(100)),\n  magenta: getset(\"cmyk\", 1, maxfn(100)),\n  yellow: getset(\"cmyk\", 2, maxfn(100)),\n  black: getset(\"cmyk\", 3, maxfn(100)),\n  x: getset(\"xyz\", 0, maxfn(95.047)),\n  y: getset(\"xyz\", 1, maxfn(100)),\n  z: getset(\"xyz\", 2, maxfn(108.833)),\n  l: getset(\"lab\", 0, maxfn(100)),\n  a: getset(\"lab\", 1),\n  b: getset(\"lab\", 2),\n  keyword(value) {\n    if (value !== void 0) {\n      return new Color(value);\n    }\n    return color_convert_default[this.model].keyword(this.color);\n  },\n  hex(value) {\n    if (value !== void 0) {\n      return new Color(value);\n    }\n    return color_string_default.to.hex(...this.rgb().round().color);\n  },\n  hexa(value) {\n    if (value !== void 0) {\n      return new Color(value);\n    }\n    const rgbArray = this.rgb().round().color;\n    let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n    if (alphaHex.length === 1) {\n      alphaHex = \"0\" + alphaHex;\n    }\n    return color_string_default.to.hex(...rgbArray) + alphaHex;\n  },\n  rgbNumber() {\n    const rgb = this.rgb().color;\n    return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;\n  },\n  luminosity() {\n    const rgb = this.rgb().color;\n    const lum = [];\n    for (const [i, element] of rgb.entries()) {\n      const chan = element / 255;\n      lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n    }\n    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n  },\n  contrast(color2) {\n    const lum1 = this.luminosity();\n    const lum2 = color2.luminosity();\n    if (lum1 > lum2) {\n      return (lum1 + 0.05) / (lum2 + 0.05);\n    }\n    return (lum2 + 0.05) / (lum1 + 0.05);\n  },\n  level(color2) {\n    const contrastRatio = this.contrast(color2);\n    if (contrastRatio >= 7) {\n      return \"AAA\";\n    }\n    return contrastRatio >= 4.5 ? \"AA\" : \"\";\n  },\n  isDark() {\n    const rgb = this.rgb().color;\n    const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;\n    return yiq < 128;\n  },\n  isLight() {\n    return !this.isDark();\n  },\n  negate() {\n    const rgb = this.rgb();\n    for (let i = 0; i < 3; i++) {\n      rgb.color[i] = 255 - rgb.color[i];\n    }\n    return rgb;\n  },\n  lighten(ratio) {\n    const hsl = this.hsl();\n    hsl.color[2] += hsl.color[2] * ratio;\n    return hsl;\n  },\n  darken(ratio) {\n    const hsl = this.hsl();\n    hsl.color[2] -= hsl.color[2] * ratio;\n    return hsl;\n  },\n  saturate(ratio) {\n    const hsl = this.hsl();\n    hsl.color[1] += hsl.color[1] * ratio;\n    return hsl;\n  },\n  desaturate(ratio) {\n    const hsl = this.hsl();\n    hsl.color[1] -= hsl.color[1] * ratio;\n    return hsl;\n  },\n  whiten(ratio) {\n    const hwb = this.hwb();\n    hwb.color[1] += hwb.color[1] * ratio;\n    return hwb;\n  },\n  blacken(ratio) {\n    const hwb = this.hwb();\n    hwb.color[2] += hwb.color[2] * ratio;\n    return hwb;\n  },\n  grayscale() {\n    const rgb = this.rgb().color;\n    const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n    return Color.rgb(value, value, value);\n  },\n  fade(ratio) {\n    return this.alpha(this.valpha - this.valpha * ratio);\n  },\n  opaquer(ratio) {\n    return this.alpha(this.valpha + this.valpha * ratio);\n  },\n  rotate(degrees) {\n    const hsl = this.hsl();\n    let hue = hsl.color[0];\n    hue = (hue + degrees) % 360;\n    hue = hue < 0 ? 360 + hue : hue;\n    hsl.color[0] = hue;\n    return hsl;\n  },\n  mix(mixinColor, weight) {\n    if (!mixinColor || !mixinColor.rgb) {\n      throw new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n    }\n    const color1 = mixinColor.rgb();\n    const color2 = this.rgb();\n    const p = weight === void 0 ? 0.5 : weight;\n    const w = 2 * p - 1;\n    const a = color1.alpha() - color2.alpha();\n    const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;\n    const w2 = 1 - w1;\n    return Color.rgb(\n      w1 * color1.red() + w2 * color2.red(),\n      w1 * color1.green() + w2 * color2.green(),\n      w1 * color1.blue() + w2 * color2.blue(),\n      color1.alpha() * p + color2.alpha() * (1 - p)\n    );\n  }\n};\nfor (const model of Object.keys(color_convert_default)) {\n  if (skippedModels.includes(model)) {\n    continue;\n  }\n  const { channels } = color_convert_default[model];\n  Color.prototype[model] = function(...arguments_) {\n    if (this.model === model) {\n      return new Color(this);\n    }\n    if (arguments_.length > 0) {\n      return new Color(arguments_, model);\n    }\n    return new Color([...assertArray(color_convert_default[this.model][model].raw(this.color)), this.valpha], model);\n  };\n  Color[model] = function(...arguments_) {\n    let color = arguments_[0];\n    if (typeof color === \"number\") {\n      color = zeroArray(arguments_, channels);\n    }\n    return new Color(color, model);\n  };\n}\nfunction roundTo(number, places) {\n  return Number(number.toFixed(places));\n}\nfunction roundToPlace(places) {\n  return function(number) {\n    return roundTo(number, places);\n  };\n}\nfunction getset(model, channel, modifier) {\n  model = Array.isArray(model) ? model : [model];\n  for (const m of model) {\n    (limiters[m] ||= [])[channel] = modifier;\n  }\n  model = model[0];\n  return function(value) {\n    let result;\n    if (value !== void 0) {\n      if (modifier) {\n        value = modifier(value);\n      }\n      result = this[model]();\n      result.color[channel] = value;\n      return result;\n    }\n    result = this[model]().color[channel];\n    if (modifier) {\n      result = modifier(result);\n    }\n    return result;\n  };\n}\nfunction maxfn(max) {\n  return function(v) {\n    return Math.max(0, Math.min(max, v));\n  };\n}\nfunction assertArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction zeroArray(array, length) {\n  for (let i = 0; i < length; i++) {\n    if (typeof array[i] !== \"number\") {\n      array[i] = 0;\n    }\n  }\n  return array;\n}\nvar index_default = Color;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGltZytjb2xvdXJAMS4wLjAvbm9kZV9tb2R1bGVzL0BpbWcvY29sb3VyL2NvbG9yLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQiwwQkFBMEIsRUFBRSxVQUFVLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyw0QkFBNEI7QUFDckMsVUFBVSw2QkFBNkI7QUFDdkMsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyw0QkFBNEI7QUFDckMsV0FBVyw0Q0FBNEM7QUFDdkQsU0FBUyw0QkFBNEI7QUFDckMsV0FBVyw0Q0FBNEM7QUFDdkQsU0FBUyw4QkFBOEI7QUFDdkMsYUFBYSxrQ0FBa0M7QUFDL0MsWUFBWSxpQ0FBaUM7QUFDN0MsYUFBYSxrQ0FBa0M7QUFDL0MsU0FBUyxzQ0FBc0M7QUFDL0MsV0FBVyw0Q0FBNEM7QUFDdkQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRSxTQUFTLEVBQUU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLGtCQUFrQixZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLG9CQUFvQixZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsa0JBQWtCLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsaUJBQWlCLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdEQUFnRDtBQUMzRyx5REFBeUQsOENBQThDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxTQUFTO0FBQ3JCLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5yb3V0ZXItbGFuZ2dyYXBoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpbWcrY29sb3VyQDEuMC4wL25vZGVfbW9kdWxlcy9AaW1nL2NvbG91ci9jb2xvci5janM/ZTkwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBub2RlX21vZHVsZXMvY29sb3IvaW5kZXguanNcbnZhciBpbmRleF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbmRleF9leHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGluZGV4X2RlZmF1bHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaW5kZXhfZXhwb3J0cyk7XG5cbi8vIG5vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4LmpzXG52YXIgY29sb3JfbmFtZV9kZWZhdWx0ID0ge1xuICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gIGJsdWU6IFswLCAwLCAyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogWzI1NSwgMCwgMF0sXG4gIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9jb2xvci1zdHJpbmcvaW5kZXguanNcbnZhciByZXZlcnNlTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAoY29uc3QgbmFtZSBpbiBjb2xvcl9uYW1lX2RlZmF1bHQpIHtcbiAgaWYgKE9iamVjdC5oYXNPd24oY29sb3JfbmFtZV9kZWZhdWx0LCBuYW1lKSkge1xuICAgIHJldmVyc2VOYW1lc1tjb2xvcl9uYW1lX2RlZmF1bHRbbmFtZV1dID0gbmFtZTtcbiAgfVxufVxudmFyIGNzID0ge1xuICB0bzoge30sXG4gIGdldDoge31cbn07XG5jcy5nZXQgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gc3RyaW5nLnNsaWNlKDAsIDMpLnRvTG93ZXJDYXNlKCk7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IG1vZGVsO1xuICBzd2l0Y2ggKHByZWZpeCkge1xuICAgIGNhc2UgXCJoc2xcIjoge1xuICAgICAgdmFsdWUgPSBjcy5nZXQuaHNsKHN0cmluZyk7XG4gICAgICBtb2RlbCA9IFwiaHNsXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImh3YlwiOiB7XG4gICAgICB2YWx1ZSA9IGNzLmdldC5od2Ioc3RyaW5nKTtcbiAgICAgIG1vZGVsID0gXCJod2JcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB2YWx1ZSA9IGNzLmdldC5yZ2Ioc3RyaW5nKTtcbiAgICAgIG1vZGVsID0gXCJyZ2JcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHsgbW9kZWwsIHZhbHVlIH07XG59O1xuY3MuZ2V0LnJnYiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFiYnIgPSAvXiMoW2EtZlxcZF17Myw0fSkkL2k7XG4gIGNvbnN0IGhleCA9IC9eIyhbYS1mXFxkXXs2fSkoW2EtZlxcZF17Mn0pPyQvaTtcbiAgY29uc3QgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKykoPz1bXFxzLF0pXFxzKig/OixcXHMqKT8oWystXT9cXGQrKSg/PVtcXHMsXSlcXHMqKD86LFxccyopPyhbKy1dP1xcZCspXFxzKig/OltcXHMsfC9dXFxzKihbKy1dP1tcXGQuXSspKCU/KVxccyopP1xcKSQvO1xuICBjb25zdCBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGQuXSspJVxccyosP1xccyooWystXT9bXFxkLl0rKSVcXHMqLD9cXHMqKFsrLV0/W1xcZC5dKyklXFxzKig/OltcXHMsfC9dXFxzKihbKy1dP1tcXGQuXSspKCU/KVxccyopP1xcKSQvO1xuICBjb25zdCBrZXl3b3JkID0gL14oXFx3KykkLztcbiAgbGV0IHJnYiA9IFswLCAwLCAwLCAxXTtcbiAgbGV0IG1hdGNoO1xuICBsZXQgaTtcbiAgbGV0IGhleEFscGhhO1xuICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgIGhleEFscGhhID0gbWF0Y2hbMl07XG4gICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBjb25zdCBpMiA9IGkgKiAyO1xuICAgICAgcmdiW2ldID0gTnVtYmVyLnBhcnNlSW50KG1hdGNoLnNsaWNlKGkyLCBpMiArIDIpLCAxNik7XG4gICAgfVxuICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgcmdiWzNdID0gTnVtYmVyLnBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpKSB7XG4gICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICBoZXhBbHBoYSA9IG1hdGNoWzNdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IE51bWJlci5wYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XG4gICAgfVxuICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgcmdiWzNdID0gTnVtYmVyLnBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICByZ2JbaV0gPSBOdW1iZXIucGFyc2VJbnQobWF0Y2hbaSArIDFdLCAxMCk7XG4gICAgfVxuICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgcmdiWzNdID0gbWF0Y2hbNV0gPyBOdW1iZXIucGFyc2VGbG9hdChtYXRjaFs0XSkgKiAwLjAxIDogTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgcmdiW2ldID0gTWF0aC5yb3VuZChOdW1iZXIucGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgfVxuICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgcmdiWzNdID0gbWF0Y2hbNV0gPyBOdW1iZXIucGFyc2VGbG9hdChtYXRjaFs0XSkgKiAwLjAxIDogTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgIGlmIChtYXRjaFsxXSA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBpZiAoIU9iamVjdC5oYXNPd24oY29sb3JfbmFtZV9kZWZhdWx0LCBtYXRjaFsxXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZ2IgPSBjb2xvcl9uYW1lX2RlZmF1bHRbbWF0Y2hbMV1dO1xuICAgIHJnYlszXSA9IDE7XG4gICAgcmV0dXJuIHJnYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldID0gY2xhbXAocmdiW2ldLCAwLCAyNTUpO1xuICB9XG4gIHJnYlszXSA9IGNsYW1wKHJnYlszXSwgMCwgMSk7XG4gIHJldHVybiByZ2I7XG59O1xuY3MuZ2V0LmhzbCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/KD86XFxkezAsM31cXC4pP1xcZCspKD86ZGVnKT9cXHMqLD9cXHMqKFsrLV0/W1xcZC5dKyklXFxzKiw/XFxzKihbKy1dP1tcXGQuXSspJVxccyooPzpbLHwvXVxccyooWystXT8oPz1cXC5cXGR8XFxkKSg/OjB8WzEtOV1cXGQqKT8oPzpcXC5cXGQqKT8oPzpbZUVdWystXT9cXGQrKT8pXFxzKik/XFwpJC87XG4gIGNvbnN0IG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IGFscGhhID0gTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgIGNvbnN0IGggPSAoTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwICsgMzYwKSAlIDM2MDtcbiAgICBjb25zdCBzID0gY2xhbXAoTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApO1xuICAgIGNvbnN0IGwgPSBjbGFtcChOdW1iZXIucGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCk7XG4gICAgY29uc3QgYSA9IGNsYW1wKE51bWJlci5pc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY3MuZ2V0Lmh3YiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZHswLDN9KD86XFwuXFxkKyk/KSg/OmRlZyk/XFxzKltcXHMsXVxccyooWystXT9bXFxkLl0rKSVcXHMqW1xccyxdXFxzKihbKy1dP1tcXGQuXSspJVxccyooPzpbXFxzLF1cXHMqKFsrLV0/KD89XFwuXFxkfFxcZCkoPzowfFsxLTldXFxkKik/KD86XFwuXFxkKik/KD86W2VFXVsrLV0/XFxkKyk/KVxccyopP1xcKSQvO1xuICBjb25zdCBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBjb25zdCBhbHBoYSA9IE51bWJlci5wYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICBjb25zdCBoID0gKE51bWJlci5wYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCArIDM2MCkgJSAzNjA7XG4gICAgY29uc3QgdyA9IGNsYW1wKE51bWJlci5wYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKTtcbiAgICBjb25zdCBiID0gY2xhbXAoTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApO1xuICAgIGNvbnN0IGEgPSBjbGFtcChOdW1iZXIuaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNzLnRvLmhleCA9IGZ1bmN0aW9uKC4uLnJnYmEpIHtcbiAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYmFbMF0pICsgaGV4RG91YmxlKHJnYmFbMV0pICsgaGV4RG91YmxlKHJnYmFbMl0pICsgKHJnYmFbM10gPCAxID8gaGV4RG91YmxlKE1hdGgucm91bmQocmdiYVszXSAqIDI1NSkpIDogXCJcIik7XG59O1xuY3MudG8ucmdiID0gZnVuY3Rpb24oLi4ucmdiYSkge1xuICByZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDEgPyBcInJnYihcIiArIE1hdGgucm91bmQocmdiYVswXSkgKyBcIiwgXCIgKyBNYXRoLnJvdW5kKHJnYmFbMV0pICsgXCIsIFwiICsgTWF0aC5yb3VuZChyZ2JhWzJdKSArIFwiKVwiIDogXCJyZ2JhKFwiICsgTWF0aC5yb3VuZChyZ2JhWzBdKSArIFwiLCBcIiArIE1hdGgucm91bmQocmdiYVsxXSkgKyBcIiwgXCIgKyBNYXRoLnJvdW5kKHJnYmFbMl0pICsgXCIsIFwiICsgcmdiYVszXSArIFwiKVwiO1xufTtcbmNzLnRvLnJnYi5wZXJjZW50ID0gZnVuY3Rpb24oLi4ucmdiYSkge1xuICBjb25zdCByID0gTWF0aC5yb3VuZChyZ2JhWzBdIC8gMjU1ICogMTAwKTtcbiAgY29uc3QgZyA9IE1hdGgucm91bmQocmdiYVsxXSAvIDI1NSAqIDEwMCk7XG4gIGNvbnN0IGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0gLyAyNTUgKiAxMDApO1xuICByZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDEgPyBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiIDogXCJyZ2JhKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUsIFwiICsgcmdiYVszXSArIFwiKVwiO1xufTtcbmNzLnRvLmhzbCA9IGZ1bmN0aW9uKC4uLmhzbGEpIHtcbiAgcmV0dXJuIGhzbGEubGVuZ3RoIDwgNCB8fCBoc2xhWzNdID09PSAxID8gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiIDogXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCIgKyBoc2xhWzNdICsgXCIpXCI7XG59O1xuY3MudG8uaHdiID0gZnVuY3Rpb24oLi4uaHdiYSkge1xuICBsZXQgYSA9IFwiXCI7XG4gIGlmIChod2JhLmxlbmd0aCA+PSA0ICYmIGh3YmFbM10gIT09IDEpIHtcbiAgICBhID0gXCIsIFwiICsgaHdiYVszXTtcbiAgfVxuICByZXR1cm4gXCJod2IoXCIgKyBod2JhWzBdICsgXCIsIFwiICsgaHdiYVsxXSArIFwiJSwgXCIgKyBod2JhWzJdICsgXCIlXCIgKyBhICsgXCIpXCI7XG59O1xuY3MudG8ua2V5d29yZCA9IGZ1bmN0aW9uKC4uLnJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59O1xuZnVuY3Rpb24gY2xhbXAobnVtYmVyXywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtYmVyXyksIG1heCk7XG59XG5mdW5jdGlvbiBoZXhEb3VibGUobnVtYmVyXykge1xuICBjb25zdCBzdHJpbmdfID0gTWF0aC5yb3VuZChudW1iZXJfKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIHN0cmluZ18ubGVuZ3RoIDwgMiA/IFwiMFwiICsgc3RyaW5nXyA6IHN0cmluZ187XG59XG52YXIgY29sb3Jfc3RyaW5nX2RlZmF1bHQgPSBjcztcblxuLy8gbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvY29udmVyc2lvbnMuanNcbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvbG9yX25hbWVfZGVmYXVsdCkpIHtcbiAgcmV2ZXJzZUtleXdvcmRzW2NvbG9yX25hbWVfZGVmYXVsdFtrZXldXSA9IGtleTtcbn1cbnZhciBjb252ZXJ0ID0ge1xuICByZ2I6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJyZ2JcIiB9LFxuICBoc2w6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJoc2xcIiB9LFxuICBoc3Y6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJoc3ZcIiB9LFxuICBod2I6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJod2JcIiB9LFxuICBjbXlrOiB7IGNoYW5uZWxzOiA0LCBsYWJlbHM6IFwiY215a1wiIH0sXG4gIHh5ejogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInh5elwiIH0sXG4gIGxhYjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcImxhYlwiIH0sXG4gIG9rbGFiOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcIm9rbFwiLCBcIm9rYVwiLCBcIm9rYlwiXSB9LFxuICBsY2g6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJsY2hcIiB9LFxuICBva2xjaDogeyBjaGFubmVsczogMywgbGFiZWxzOiBbXCJva2xcIiwgXCJva2NcIiwgXCJva2hcIl0gfSxcbiAgaGV4OiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImhleFwiXSB9LFxuICBrZXl3b3JkOiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImtleXdvcmRcIl0gfSxcbiAgYW5zaTE2OiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImFuc2kxNlwiXSB9LFxuICBhbnNpMjU2OiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImFuc2kyNTZcIl0gfSxcbiAgaGNnOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcImhcIiwgXCJjXCIsIFwiZ1wiXSB9LFxuICBhcHBsZTogeyBjaGFubmVsczogMywgbGFiZWxzOiBbXCJyMTZcIiwgXCJnMTZcIiwgXCJiMTZcIl0gfSxcbiAgZ3JheTogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJncmF5XCJdIH1cbn07XG52YXIgY29udmVyc2lvbnNfZGVmYXVsdCA9IGNvbnZlcnQ7XG52YXIgTEFCX0ZUID0gKDYgLyAyOSkgKiogMztcbmZ1bmN0aW9uIHNyZ2JOb25saW5lYXJUcmFuc2Zvcm0oYykge1xuICBjb25zdCBjYyA9IGMgPiAzMTMwOGUtNyA/IDEuMDU1ICogYyAqKiAoMSAvIDIuNCkgLSAwLjA1NSA6IGMgKiAxMi45MjtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KDAsIGNjKSwgMSk7XG59XG5mdW5jdGlvbiBzcmdiTm9ubGluZWFyVHJhbnNmb3JtSW52KGMpIHtcbiAgcmV0dXJuIGMgPiAwLjA0MDQ1ID8gKChjICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IGMgLyAxMi45Mjtcbn1cbmZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoY29udmVydCkpIHtcbiAgaWYgKCEoXCJjaGFubmVsc1wiIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6IFwiICsgbW9kZWwpO1xuICB9XG4gIGlmICghKFwibGFiZWxzXCIgaW4gY29udmVydFttb2RlbF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogXCIgKyBtb2RlbCk7XG4gIH1cbiAgaWYgKGNvbnZlcnRbbW9kZWxdLmxhYmVscy5sZW5ndGggIT09IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiBcIiArIG1vZGVsKTtcbiAgfVxuICBjb25zdCB7IGNoYW5uZWxzLCBsYWJlbHMgfSA9IGNvbnZlcnRbbW9kZWxdO1xuICBkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG4gIGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgXCJjaGFubmVsc1wiLCB7IHZhbHVlOiBjaGFubmVscyB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCBcImxhYmVsc1wiLCB7IHZhbHVlOiBsYWJlbHMgfSk7XG59XG5jb252ZXJ0LnJnYi5oc2wgPSBmdW5jdGlvbihyZ2IpIHtcbiAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcbiAgbGV0IGg7XG4gIGxldCBzO1xuICBzd2l0Y2ggKG1heCkge1xuICAgIGNhc2UgbWluOiB7XG4gICAgICBoID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIHI6IHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBnOiB7XG4gICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIGI6IHtcbiAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDI7XG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIHMgPSAwO1xuICB9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG4gICAgcyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuICB9XG4gIHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuY29udmVydC5yZ2IuaHN2ID0gZnVuY3Rpb24ocmdiKSB7XG4gIGxldCByZGlmO1xuICBsZXQgZ2RpZjtcbiAgbGV0IGJkaWY7XG4gIGxldCBoO1xuICBsZXQgcztcbiAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgY29uc3QgdiA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBkaWZmYyA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gKHYgLSBjKSAvIDYgLyBkaWZmICsgMSAvIDI7XG4gIH07XG4gIGlmIChkaWZmID09PSAwKSB7XG4gICAgaCA9IDA7XG4gICAgcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGRpZmYgLyB2O1xuICAgIHJkaWYgPSBkaWZmYyhyKTtcbiAgICBnZGlmID0gZGlmZmMoZyk7XG4gICAgYmRpZiA9IGRpZmZjKGIpO1xuICAgIHN3aXRjaCAodikge1xuICAgICAgY2FzZSByOiB7XG4gICAgICAgIGggPSBiZGlmIC0gZ2RpZjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGc6IHtcbiAgICAgICAgaCA9IDEgLyAzICsgcmRpZiAtIGJkaWY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBiOiB7XG4gICAgICAgIGggPSAyIC8gMyArIGdkaWYgLSByZGlmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoICs9IDE7XG4gICAgfSBlbHNlIGlmIChoID4gMSkge1xuICAgICAgaCAtPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIGggKiAzNjAsXG4gICAgcyAqIDEwMCxcbiAgICB2ICogMTAwXG4gIF07XG59O1xuY29udmVydC5yZ2IuaHdiID0gZnVuY3Rpb24ocmdiKSB7XG4gIGNvbnN0IHIgPSByZ2JbMF07XG4gIGNvbnN0IGcgPSByZ2JbMV07XG4gIGxldCBiID0gcmdiWzJdO1xuICBjb25zdCBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG4gIGNvbnN0IHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuICBiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59O1xuY29udmVydC5yZ2Iub2tsYWIgPSBmdW5jdGlvbihyZ2IpIHtcbiAgY29uc3QgciA9IHNyZ2JOb25saW5lYXJUcmFuc2Zvcm1JbnYocmdiWzBdIC8gMjU1KTtcbiAgY29uc3QgZyA9IHNyZ2JOb25saW5lYXJUcmFuc2Zvcm1JbnYocmdiWzFdIC8gMjU1KTtcbiAgY29uc3QgYiA9IHNyZ2JOb25saW5lYXJUcmFuc2Zvcm1JbnYocmdiWzJdIC8gMjU1KTtcbiAgY29uc3QgbHAgPSBNYXRoLmNicnQoMC40MTIyMjE0NzA4ICogciArIDAuNTM2MzMyNTM2MyAqIGcgKyAwLjA1MTQ0NTk5MjkgKiBiKTtcbiAgY29uc3QgbXAgPSBNYXRoLmNicnQoMC4yMTE5MDM0OTgyICogciArIDAuNjgwNjk5NTQ1MSAqIGcgKyAwLjEwNzM5Njk1NjYgKiBiKTtcbiAgY29uc3Qgc3AgPSBNYXRoLmNicnQoMC4wODgzMDI0NjE5ICogciArIDAuMjgxNzE4ODM3NiAqIGcgKyAwLjYyOTk3ODcwMDUgKiBiKTtcbiAgY29uc3QgbCA9IDAuMjEwNDU0MjU1MyAqIGxwICsgMC43OTM2MTc3ODUgKiBtcCAtIDAuMDA0MDcyMDQ2OCAqIHNwO1xuICBjb25zdCBhYSA9IDEuOTc3OTk4NDk1MSAqIGxwIC0gMi40Mjg1OTIyMDUgKiBtcCArIDAuNDUwNTkzNzA5OSAqIHNwO1xuICBjb25zdCBiYiA9IDAuMDI1OTA0MDM3MSAqIGxwICsgMC43ODI3NzE3NjYyICogbXAgLSAwLjgwODY3NTc2NiAqIHNwO1xuICByZXR1cm4gW2wgKiAxMDAsIGFhICogMTAwLCBiYiAqIDEwMF07XG59O1xuY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uKHJnYikge1xuICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICBjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuICBjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuICBjb25zdCBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGNvbnN0IGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgY29uc3QgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICBjb25zdCB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59O1xuZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG4gIHJldHVybiAoeFswXSAtIHlbMF0pICoqIDIgKyAoeFsxXSAtIHlbMV0pICoqIDIgKyAoeFsyXSAtIHlbMl0pICoqIDI7XG59XG5jb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24ocmdiKSB7XG4gIGNvbnN0IHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG4gIGlmIChyZXZlcnNlZCkge1xuICAgIHJldHVybiByZXZlcnNlZDtcbiAgfVxuICBsZXQgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgbGV0IGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbiAgZm9yIChjb25zdCBrZXl3b3JkIG9mIE9iamVjdC5rZXlzKGNvbG9yX25hbWVfZGVmYXVsdCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbG9yX25hbWVfZGVmYXVsdFtrZXl3b3JkXTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG4gICAgaWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgY3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbn07XG5jb252ZXJ0LmtleXdvcmQucmdiID0gZnVuY3Rpb24oa2V5d29yZCkge1xuICByZXR1cm4gY29sb3JfbmFtZV9kZWZhdWx0W2tleXdvcmRdO1xufTtcbmNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uKHJnYikge1xuICBjb25zdCByID0gc3JnYk5vbmxpbmVhclRyYW5zZm9ybUludihyZ2JbMF0gLyAyNTUpO1xuICBjb25zdCBnID0gc3JnYk5vbmxpbmVhclRyYW5zZm9ybUludihyZ2JbMV0gLyAyNTUpO1xuICBjb25zdCBiID0gc3JnYk5vbmxpbmVhclRyYW5zZm9ybUludihyZ2JbMl0gLyAyNTUpO1xuICBjb25zdCB4ID0gciAqIDAuNDEyNDU2NCArIGcgKiAwLjM1NzU3NjEgKyBiICogMC4xODA0Mzc1O1xuICBjb25zdCB5ID0gciAqIDAuMjEyNjcyOSArIGcgKiAwLjcxNTE1MjIgKyBiICogMC4wNzIxNzU7XG4gIGNvbnN0IHogPSByICogMC4wMTkzMzM5ICsgZyAqIDAuMTE5MTkyICsgYiAqIDAuOTUwMzA0MTtcbiAgcmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbn07XG5jb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbihyZ2IpIHtcbiAgY29uc3QgeHl6ID0gY29udmVydC5yZ2IueHl6KHJnYik7XG4gIGxldCB4ID0geHl6WzBdO1xuICBsZXQgeSA9IHh5elsxXTtcbiAgbGV0IHogPSB4eXpbMl07XG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuICB4ID0geCA+IExBQl9GVCA/IHggKiogKDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2O1xuICB5ID0geSA+IExBQl9GVCA/IHkgKiogKDEgLyAzKSA6IDcuNzg3ICogeSArIDE2IC8gMTE2O1xuICB6ID0geiA+IExBQl9GVCA/IHogKiogKDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2O1xuICBjb25zdCBsID0gMTE2ICogeSAtIDE2O1xuICBjb25zdCBhID0gNTAwICogKHggLSB5KTtcbiAgY29uc3QgYiA9IDIwMCAqICh5IC0geik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59O1xuY29udmVydC5oc2wucmdiID0gZnVuY3Rpb24oaHNsKSB7XG4gIGNvbnN0IGggPSBoc2xbMF0gLyAzNjA7XG4gIGNvbnN0IHMgPSBoc2xbMV0gLyAxMDA7XG4gIGNvbnN0IGwgPSBoc2xbMl0gLyAxMDA7XG4gIGxldCB0MztcbiAgbGV0IHZhbHVlO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHZhbHVlID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbHVlLCB2YWx1ZSwgdmFsdWVdO1xuICB9XG4gIGNvbnN0IHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgY29uc3QgdDEgPSAyICogbCAtIHQyO1xuICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcbiAgICBpZiAodDMgPCAwKSB7XG4gICAgICB0MysrO1xuICAgIH1cbiAgICBpZiAodDMgPiAxKSB7XG4gICAgICB0My0tO1xuICAgIH1cbiAgICBpZiAoNiAqIHQzIDwgMSkge1xuICAgICAgdmFsdWUgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0MztcbiAgICB9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcbiAgICAgIHZhbHVlID0gdDI7XG4gICAgfSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG4gICAgICB2YWx1ZSA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB0MTtcbiAgICB9XG4gICAgcmdiW2ldID0gdmFsdWUgKiAyNTU7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn07XG5jb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbihoc2wpIHtcbiAgY29uc3QgaCA9IGhzbFswXTtcbiAgbGV0IHMgPSBoc2xbMV0gLyAxMDA7XG4gIGxldCBsID0gaHNsWzJdIC8gMTAwO1xuICBsZXQgc21pbiA9IHM7XG4gIGNvbnN0IGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcbiAgbCAqPSAyO1xuICBzICo9IGwgPD0gMSA/IGwgOiAyIC0gbDtcbiAgc21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG4gIGNvbnN0IHYgPSAobCArIHMpIC8gMjtcbiAgY29uc3Qgc3YgPSBsID09PSAwID8gMiAqIHNtaW4gLyAobG1pbiArIHNtaW4pIDogMiAqIHMgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn07XG5jb252ZXJ0Lmhzdi5yZ2IgPSBmdW5jdGlvbihoc3YpIHtcbiAgY29uc3QgaCA9IGhzdlswXSAvIDYwO1xuICBjb25zdCBzID0gaHN2WzFdIC8gMTAwO1xuICBsZXQgdiA9IGhzdlsyXSAvIDEwMDtcbiAgY29uc3QgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcbiAgY29uc3QgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuICBjb25zdCBwID0gMjU1ICogdiAqICgxIC0gcyk7XG4gIGNvbnN0IHEgPSAyNTUgKiB2ICogKDEgLSBzICogZik7XG4gIGNvbnN0IHQgPSAyNTUgKiB2ICogKDEgLSBzICogKDEgLSBmKSk7XG4gIHYgKj0gMjU1O1xuICBzd2l0Y2ggKGhpKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICByZXR1cm4gW3YsIHQsIHBdO1xuICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgIHJldHVybiBbcSwgdiwgcF07XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgcmV0dXJuIFtwLCB2LCB0XTtcbiAgICB9XG4gICAgY2FzZSAzOiB7XG4gICAgICByZXR1cm4gW3AsIHEsIHZdO1xuICAgIH1cbiAgICBjYXNlIDQ6IHtcbiAgICAgIHJldHVybiBbdCwgcCwgdl07XG4gICAgfVxuICAgIGNhc2UgNToge1xuICAgICAgcmV0dXJuIFt2LCBwLCBxXTtcbiAgICB9XG4gIH1cbn07XG5jb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbihoc3YpIHtcbiAgY29uc3QgaCA9IGhzdlswXTtcbiAgY29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcbiAgY29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcbiAgY29uc3Qgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuICBsZXQgc2w7XG4gIGxldCBsO1xuICBsID0gKDIgLSBzKSAqIHY7XG4gIGNvbnN0IGxtaW4gPSAoMiAtIHMpICogdm1pbjtcbiAgc2wgPSBzICogdm1pbjtcbiAgc2wgLz0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuICBzbCA9IHNsIHx8IDA7XG4gIGwgLz0gMjtcbiAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59O1xuY29udmVydC5od2IucmdiID0gZnVuY3Rpb24oaHdiKSB7XG4gIGNvbnN0IGggPSBod2JbMF0gLyAzNjA7XG4gIGxldCB3aCA9IGh3YlsxXSAvIDEwMDtcbiAgbGV0IGJsID0gaHdiWzJdIC8gMTAwO1xuICBjb25zdCByYXRpbyA9IHdoICsgYmw7XG4gIGxldCBmO1xuICBpZiAocmF0aW8gPiAxKSB7XG4gICAgd2ggLz0gcmF0aW87XG4gICAgYmwgLz0gcmF0aW87XG4gIH1cbiAgY29uc3QgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICBjb25zdCB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAxKSAhPT0gMCkge1xuICAgIGYgPSAxIC0gZjtcbiAgfVxuICBjb25zdCBuID0gd2ggKyBmICogKHYgLSB3aCk7XG4gIGxldCByO1xuICBsZXQgZztcbiAgbGV0IGI7XG4gIHN3aXRjaCAoaSkge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgMDoge1xuICAgICAgciA9IHY7XG4gICAgICBnID0gbjtcbiAgICAgIGIgPSB3aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgIHIgPSBuO1xuICAgICAgZyA9IHY7XG4gICAgICBiID0gd2g7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICByID0gd2g7XG4gICAgICBnID0gdjtcbiAgICAgIGIgPSBuO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMzoge1xuICAgICAgciA9IHdoO1xuICAgICAgZyA9IG47XG4gICAgICBiID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDQ6IHtcbiAgICAgIHIgPSBuO1xuICAgICAgZyA9IHdoO1xuICAgICAgYiA9IHY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA1OiB7XG4gICAgICByID0gdjtcbiAgICAgIGcgPSB3aDtcbiAgICAgIGIgPSBuO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuY29udmVydC5jbXlrLnJnYiA9IGZ1bmN0aW9uKGNteWspIHtcbiAgY29uc3QgYyA9IGNteWtbMF0gLyAxMDA7XG4gIGNvbnN0IG0gPSBjbXlrWzFdIC8gMTAwO1xuICBjb25zdCB5ID0gY215a1syXSAvIDEwMDtcbiAgY29uc3QgayA9IGNteWtbM10gLyAxMDA7XG4gIGNvbnN0IHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgY29uc3QgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICBjb25zdCBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuY29udmVydC54eXoucmdiID0gZnVuY3Rpb24oeHl6KSB7XG4gIGNvbnN0IHggPSB4eXpbMF0gLyAxMDA7XG4gIGNvbnN0IHkgPSB4eXpbMV0gLyAxMDA7XG4gIGNvbnN0IHogPSB4eXpbMl0gLyAxMDA7XG4gIGxldCByO1xuICBsZXQgZztcbiAgbGV0IGI7XG4gIHIgPSB4ICogMy4yNDA0NTQyICsgeSAqIC0xLjUzNzEzODUgKyB6ICogLTAuNDk4NTMxNDtcbiAgZyA9IHggKiAtMC45NjkyNjYgKyB5ICogMS44NzYwMTA4ICsgeiAqIDAuMDQxNTU2O1xuICBiID0geCAqIDAuMDU1NjQzNCArIHkgKiAtMC4yMDQwMjU5ICsgeiAqIDEuMDU3MjI1MjtcbiAgciA9IHNyZ2JOb25saW5lYXJUcmFuc2Zvcm0ocik7XG4gIGcgPSBzcmdiTm9ubGluZWFyVHJhbnNmb3JtKGcpO1xuICBiID0gc3JnYk5vbmxpbmVhclRyYW5zZm9ybShiKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5jb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbih4eXopIHtcbiAgbGV0IHggPSB4eXpbMF07XG4gIGxldCB5ID0geHl6WzFdO1xuICBsZXQgeiA9IHh5elsyXTtcbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG4gIHggPSB4ID4gTEFCX0ZUID8geCAqKiAoMSAvIDMpIDogNy43ODcgKiB4ICsgMTYgLyAxMTY7XG4gIHkgPSB5ID4gTEFCX0ZUID8geSAqKiAoMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTY7XG4gIHogPSB6ID4gTEFCX0ZUID8geiAqKiAoMSAvIDMpIDogNy43ODcgKiB6ICsgMTYgLyAxMTY7XG4gIGNvbnN0IGwgPSAxMTYgKiB5IC0gMTY7XG4gIGNvbnN0IGEgPSA1MDAgKiAoeCAtIHkpO1xuICBjb25zdCBiID0gMjAwICogKHkgLSB6KTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn07XG5jb252ZXJ0Lnh5ei5va2xhYiA9IGZ1bmN0aW9uKHh5eikge1xuICBjb25zdCB4ID0geHl6WzBdIC8gMTAwO1xuICBjb25zdCB5ID0geHl6WzFdIC8gMTAwO1xuICBjb25zdCB6ID0geHl6WzJdIC8gMTAwO1xuICBjb25zdCBscCA9IE1hdGguY2JydCgwLjgxODkzMzAxMDEgKiB4ICsgMC4zNjE4NjY3NDI0ICogeSAtIDAuMTI4ODU5NzEzNyAqIHopO1xuICBjb25zdCBtcCA9IE1hdGguY2JydCgwLjAzMjk4NDU0MzYgKiB4ICsgMC45MjkzMTE4NzE1ICogeSArIDAuMDM2MTQ1NjM4NyAqIHopO1xuICBjb25zdCBzcCA9IE1hdGguY2JydCgwLjA0ODIwMDMwMTggKiB4ICsgMC4yNjQzNjYyNjkxICogeSArIDAuNjMzODUxNzA3ICogeik7XG4gIGNvbnN0IGwgPSAwLjIxMDQ1NDI1NTMgKiBscCArIDAuNzkzNjE3Nzg1ICogbXAgLSAwLjAwNDA3MjA0NjggKiBzcDtcbiAgY29uc3QgYSA9IDEuOTc3OTk4NDk1MSAqIGxwIC0gMi40Mjg1OTIyMDUgKiBtcCArIDAuNDUwNTkzNzA5OSAqIHNwO1xuICBjb25zdCBiID0gMC4wMjU5MDQwMzcxICogbHAgKyAwLjc4Mjc3MTc2NjIgKiBtcCAtIDAuODA4Njc1NzY2ICogc3A7XG4gIHJldHVybiBbbCAqIDEwMCwgYSAqIDEwMCwgYiAqIDEwMF07XG59O1xuY29udmVydC5va2xhYi5va2xjaCA9IGZ1bmN0aW9uKG9rbGFiKSB7XG4gIHJldHVybiBjb252ZXJ0LmxhYi5sY2gob2tsYWIpO1xufTtcbmNvbnZlcnQub2tsYWIueHl6ID0gZnVuY3Rpb24ob2tsYWIpIHtcbiAgY29uc3QgbGwgPSBva2xhYlswXSAvIDEwMDtcbiAgY29uc3QgYSA9IG9rbGFiWzFdIC8gMTAwO1xuICBjb25zdCBiID0gb2tsYWJbMl0gLyAxMDA7XG4gIGNvbnN0IGwgPSAoMC45OTk5OTk5OTggKiBsbCArIDAuMzk2MzM3NzkyICogYSArIDAuMjE1ODAzNzU4ICogYikgKiogMztcbiAgY29uc3QgbSA9ICgxLjAwMDAwMDAwOCAqIGxsIC0gMC4xMDU1NjEzNDIgKiBhIC0gMC4wNjM4NTQxNzUgKiBiKSAqKiAzO1xuICBjb25zdCBzID0gKDEuMDAwMDAwMDU1ICogbGwgLSAwLjA4OTQ4NDE4MiAqIGEgLSAxLjI5MTQ4NTUzOCAqIGIpICoqIDM7XG4gIGNvbnN0IHggPSAxLjIyNzAxMzg1MSAqIGwgLSAwLjU1Nzc5OTk4ICogbSArIDAuMjgxMjU2MTQ5ICogcztcbiAgY29uc3QgeSA9IC0wLjA0MDU4MDE3OCAqIGwgKyAxLjExMjI1Njg3ICogbSAtIDAuMDcxNjc2Njc5ICogcztcbiAgY29uc3QgeiA9IC0wLjA3NjM4MTI4NSAqIGwgLSAwLjQyMTQ4MTk3OCAqIG0gKyAxLjU4NjE2MzIyICogcztcbiAgcmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbn07XG5jb252ZXJ0Lm9rbGFiLnJnYiA9IGZ1bmN0aW9uKG9rbGFiKSB7XG4gIGNvbnN0IGxsID0gb2tsYWJbMF0gLyAxMDA7XG4gIGNvbnN0IGFhID0gb2tsYWJbMV0gLyAxMDA7XG4gIGNvbnN0IGJiID0gb2tsYWJbMl0gLyAxMDA7XG4gIGNvbnN0IGwgPSAobGwgKyAwLjM5NjMzNzc3NzQgKiBhYSArIDAuMjE1ODAzNzU3MyAqIGJiKSAqKiAzO1xuICBjb25zdCBtID0gKGxsIC0gMC4xMDU1NjEzNDU4ICogYWEgLSAwLjA2Mzg1NDE3MjggKiBiYikgKiogMztcbiAgY29uc3QgcyA9IChsbCAtIDAuMDg5NDg0MTc3NSAqIGFhIC0gMS4yOTE0ODU1NDggKiBiYikgKiogMztcbiAgY29uc3QgciA9IHNyZ2JOb25saW5lYXJUcmFuc2Zvcm0oNC4wNzY3NDE2NjIxICogbCAtIDMuMzA3NzExNTkxMyAqIG0gKyAwLjIzMDk2OTkyOTIgKiBzKTtcbiAgY29uc3QgZyA9IHNyZ2JOb25saW5lYXJUcmFuc2Zvcm0oLTEuMjY4NDM4MDA0NiAqIGwgKyAyLjYwOTc1NzQwMTEgKiBtIC0gMC4zNDEzMTkzOTY1ICogcyk7XG4gIGNvbnN0IGIgPSBzcmdiTm9ubGluZWFyVHJhbnNmb3JtKC0wLjAwNDE5NjA4NjMgKiBsIC0gMC43MDM0MTg2MTQ3ICogbSArIDEuNzA3NjE0NzAxICogcyk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuY29udmVydC5va2xjaC5va2xhYiA9IGZ1bmN0aW9uKG9rbGNoKSB7XG4gIHJldHVybiBjb252ZXJ0LmxjaC5sYWIob2tsY2gpO1xufTtcbmNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uKGxhYikge1xuICBjb25zdCBsID0gbGFiWzBdO1xuICBjb25zdCBhID0gbGFiWzFdO1xuICBjb25zdCBiID0gbGFiWzJdO1xuICBsZXQgeDtcbiAgbGV0IHk7XG4gIGxldCB6O1xuICB5ID0gKGwgKyAxNikgLyAxMTY7XG4gIHggPSBhIC8gNTAwICsgeTtcbiAgeiA9IHkgLSBiIC8gMjAwO1xuICBjb25zdCB5MiA9IHkgKiogMztcbiAgY29uc3QgeDIgPSB4ICoqIDM7XG4gIGNvbnN0IHoyID0geiAqKiAzO1xuICB5ID0geTIgPiBMQUJfRlQgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gIHggPSB4MiA+IExBQl9GVCA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgeiA9IHoyID4gTEFCX0ZUID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICB4ICo9IDk1LjA0NztcbiAgeSAqPSAxMDA7XG4gIHogKj0gMTA4Ljg4MztcbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn07XG5jb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbihsYWIpIHtcbiAgY29uc3QgbCA9IGxhYlswXTtcbiAgY29uc3QgYSA9IGxhYlsxXTtcbiAgY29uc3QgYiA9IGxhYlsyXTtcbiAgbGV0IGg7XG4gIGNvbnN0IGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIHJldHVybiBbbCwgYywgaF07XG59O1xuY29udmVydC5sY2gubGFiID0gZnVuY3Rpb24obGNoKSB7XG4gIGNvbnN0IGwgPSBsY2hbMF07XG4gIGNvbnN0IGMgPSBsY2hbMV07XG4gIGNvbnN0IGggPSBsY2hbMl07XG4gIGNvbnN0IGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICBjb25zdCBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgY29uc3QgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59O1xuY29udmVydC5yZ2IuYW5zaTE2ID0gZnVuY3Rpb24oYXJncywgc2F0dXJhdGlvbiA9IG51bGwpIHtcbiAgY29uc3QgW3IsIGcsIGJdID0gYXJncztcbiAgbGV0IHZhbHVlID0gc2F0dXJhdGlvbiA9PT0gbnVsbCA/IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXSA6IHNhdHVyYXRpb247XG4gIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIDUwKTtcbiAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIDMwO1xuICB9XG4gIGxldCBhbnNpID0gMzAgKyAoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyIHwgTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxIHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG4gIGlmICh2YWx1ZSA9PT0gMikge1xuICAgIGFuc2kgKz0gNjA7XG4gIH1cbiAgcmV0dXJuIGFuc2k7XG59O1xuY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG59O1xuY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgY29uc3QgciA9IGFyZ3NbMF07XG4gIGNvbnN0IGcgPSBhcmdzWzFdO1xuICBjb25zdCBiID0gYXJnc1syXTtcbiAgaWYgKHIgPj4gNCA9PT0gZyA+PiA0ICYmIGcgPj4gNCA9PT0gYiA+PiA0KSB7XG4gICAgaWYgKHIgPCA4KSB7XG4gICAgICByZXR1cm4gMTY7XG4gICAgfVxuICAgIGlmIChyID4gMjQ4KSB7XG4gICAgICByZXR1cm4gMjMxO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgociAtIDgpIC8gMjQ3ICogMjQpICsgMjMyO1xuICB9XG4gIGNvbnN0IGFuc2kgPSAxNiArIDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkgKyA2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkgKyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcbiAgcmV0dXJuIGFuc2k7XG59O1xuY29udmVydC5hbnNpMTYucmdiID0gZnVuY3Rpb24oYXJncykge1xuICBhcmdzID0gYXJnc1swXTtcbiAgbGV0IGNvbG9yID0gYXJncyAlIDEwO1xuICBpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcbiAgICBpZiAoYXJncyA+IDUwKSB7XG4gICAgICBjb2xvciArPSAzLjU7XG4gICAgfVxuICAgIGNvbG9yID0gY29sb3IgLyAxMC41ICogMjU1O1xuICAgIHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG4gIH1cbiAgY29uc3QgbXVsdCA9IChNYXRoLnRydW5jKGFyZ3MgPiA1MCkgKyAxKSAqIDAuNTtcbiAgY29uc3QgciA9IChjb2xvciAmIDEpICogbXVsdCAqIDI1NTtcbiAgY29uc3QgZyA9IChjb2xvciA+PiAxICYgMSkgKiBtdWx0ICogMjU1O1xuICBjb25zdCBiID0gKGNvbG9yID4+IDIgJiAxKSAqIG11bHQgKiAyNTU7XG4gIHJldHVybiBbciwgZywgYl07XG59O1xuY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgYXJncyA9IGFyZ3NbMF07XG4gIGlmIChhcmdzID49IDIzMikge1xuICAgIGNvbnN0IGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG4gICAgcmV0dXJuIFtjLCBjLCBjXTtcbiAgfVxuICBhcmdzIC09IDE2O1xuICBsZXQgcmVtO1xuICBjb25zdCByID0gTWF0aC5mbG9vcihhcmdzIC8gMzYpIC8gNSAqIDI1NTtcbiAgY29uc3QgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG4gIGNvbnN0IGIgPSByZW0gJSA2IC8gNSAqIDI1NTtcbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn07XG5jb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbihhcmdzKSB7XG4gIGNvbnN0IGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAyNTUpIDw8IDE2KSArICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDI1NSkgPDwgOCkgKyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDI1NSk7XG4gIGNvbnN0IHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBcIjAwMDAwMFwiLnNsaWNlKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcbmNvbnZlcnQuaGV4LnJnYiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgY29uc3QgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZlxcZF17Nn18W2EtZlxcZF17M30vaSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG4gIGxldCBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG4gICAgY29sb3JTdHJpbmcgPSBbLi4uY29sb3JTdHJpbmddLm1hcCgoY2hhcikgPT4gY2hhciArIGNoYXIpLmpvaW4oXCJcIik7XG4gIH1cbiAgY29uc3QgaW50ZWdlciA9IE51bWJlci5wYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuICBjb25zdCByID0gaW50ZWdlciA+PiAxNiAmIDI1NTtcbiAgY29uc3QgZyA9IGludGVnZXIgPj4gOCAmIDI1NTtcbiAgY29uc3QgYiA9IGludGVnZXIgJiAyNTU7XG4gIHJldHVybiBbciwgZywgYl07XG59O1xuY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24ocmdiKSB7XG4gIGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG4gIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KE1hdGgubWF4KHIsIGcpLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuICBjb25zdCBjaHJvbWEgPSBtYXggLSBtaW47XG4gIGxldCBodWU7XG4gIGNvbnN0IGdyYXlzY2FsZSA9IGNocm9tYSA8IDEgPyBtaW4gLyAoMSAtIGNocm9tYSkgOiAwO1xuICBpZiAoY2hyb21hIDw9IDApIHtcbiAgICBodWUgPSAwO1xuICB9IGVsc2UgaWYgKG1heCA9PT0gcikge1xuICAgIGh1ZSA9IChnIC0gYikgLyBjaHJvbWEgJSA2O1xuICB9IGVsc2UgaWYgKG1heCA9PT0gZykge1xuICAgIGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuICB9IGVsc2Uge1xuICAgIGh1ZSA9IDQgKyAociAtIGcpIC8gY2hyb21hO1xuICB9XG4gIGh1ZSAvPSA2O1xuICBodWUgJT0gMTtcbiAgcmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5jb252ZXJ0LmhzbC5oY2cgPSBmdW5jdGlvbihoc2wpIHtcbiAgY29uc3QgcyA9IGhzbFsxXSAvIDEwMDtcbiAgY29uc3QgbCA9IGhzbFsyXSAvIDEwMDtcbiAgY29uc3QgYyA9IGwgPCAwLjUgPyAyICogcyAqIGwgOiAyICogcyAqICgxIC0gbCk7XG4gIGxldCBmID0gMDtcbiAgaWYgKGMgPCAxKSB7XG4gICAgZiA9IChsIC0gMC41ICogYykgLyAoMSAtIGMpO1xuICB9XG4gIHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5jb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbihoc3YpIHtcbiAgY29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcbiAgY29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcbiAgY29uc3QgYyA9IHMgKiB2O1xuICBsZXQgZiA9IDA7XG4gIGlmIChjIDwgMSkge1xuICAgIGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgfVxuICByZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24oaGNnKSB7XG4gIGNvbnN0IGggPSBoY2dbMF0gLyAzNjA7XG4gIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gIGlmIChjID09PSAwKSB7XG4gICAgcmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcbiAgfVxuICBjb25zdCBwdXJlID0gWzAsIDAsIDBdO1xuICBjb25zdCBoaSA9IGggJSAxICogNjtcbiAgY29uc3QgdiA9IGhpICUgMTtcbiAgY29uc3QgdyA9IDEgLSB2O1xuICBsZXQgbWcgPSAwO1xuICBzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICBwdXJlWzBdID0gMTtcbiAgICAgIHB1cmVbMV0gPSB2O1xuICAgICAgcHVyZVsyXSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICBwdXJlWzBdID0gdztcbiAgICAgIHB1cmVbMV0gPSAxO1xuICAgICAgcHVyZVsyXSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICBwdXJlWzBdID0gMDtcbiAgICAgIHB1cmVbMV0gPSAxO1xuICAgICAgcHVyZVsyXSA9IHY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAzOiB7XG4gICAgICBwdXJlWzBdID0gMDtcbiAgICAgIHB1cmVbMV0gPSB3O1xuICAgICAgcHVyZVsyXSA9IDE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA0OiB7XG4gICAgICBwdXJlWzBdID0gdjtcbiAgICAgIHB1cmVbMV0gPSAwO1xuICAgICAgcHVyZVsyXSA9IDE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcHVyZVswXSA9IDE7XG4gICAgICBwdXJlWzFdID0gMDtcbiAgICAgIHB1cmVbMl0gPSB3O1xuICAgIH1cbiAgfVxuICBtZyA9ICgxIC0gYykgKiBnO1xuICByZXR1cm4gW1xuICAgIChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcbiAgICAoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsXG4gICAgKGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG4gIF07XG59O1xuY29udmVydC5oY2cuaHN2ID0gZnVuY3Rpb24oaGNnKSB7XG4gIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gIGNvbnN0IHYgPSBjICsgZyAqICgxIC0gYyk7XG4gIGxldCBmID0gMDtcbiAgaWYgKHYgPiAwKSB7XG4gICAgZiA9IGMgLyB2O1xuICB9XG4gIHJldHVybiBbaGNnWzBdLCBmICogMTAwLCB2ICogMTAwXTtcbn07XG5jb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbihoY2cpIHtcbiAgY29uc3QgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgY29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcbiAgY29uc3QgbCA9IGcgKiAoMSAtIGMpICsgMC41ICogYztcbiAgbGV0IHMgPSAwO1xuICBpZiAobCA+IDAgJiYgbCA8IDAuNSkge1xuICAgIHMgPSBjIC8gKDIgKiBsKTtcbiAgfSBlbHNlIGlmIChsID49IDAuNSAmJiBsIDwgMSkge1xuICAgIHMgPSBjIC8gKDIgKiAoMSAtIGwpKTtcbiAgfVxuICByZXR1cm4gW2hjZ1swXSwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24oaGNnKSB7XG4gIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gIGNvbnN0IHYgPSBjICsgZyAqICgxIC0gYyk7XG4gIHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbn07XG5jb252ZXJ0Lmh3Yi5oY2cgPSBmdW5jdGlvbihod2IpIHtcbiAgY29uc3QgdyA9IGh3YlsxXSAvIDEwMDtcbiAgY29uc3QgYiA9IGh3YlsyXSAvIDEwMDtcbiAgY29uc3QgdiA9IDEgLSBiO1xuICBjb25zdCBjID0gdiAtIHc7XG4gIGxldCBnID0gMDtcbiAgaWYgKGMgPCAxKSB7XG4gICAgZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuICB9XG4gIHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbn07XG5jb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uKGFwcGxlKSB7XG4gIHJldHVybiBbYXBwbGVbMF0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMV0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMl0gLyA2NTUzNSAqIDI1NV07XG59O1xuY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbihyZ2IpIHtcbiAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUgKiA2NTUzNSwgcmdiWzFdIC8gMjU1ICogNjU1MzUsIHJnYlsyXSAvIDI1NSAqIDY1NTM1XTtcbn07XG5jb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xufTtcbmNvbnZlcnQuZ3JheS5oc2wgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHJldHVybiBbMCwgMCwgYXJnc1swXV07XG59O1xuY29udmVydC5ncmF5LmhzdiA9IGNvbnZlcnQuZ3JheS5oc2w7XG5jb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24oZ3JheSkge1xuICByZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG59O1xuY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbihncmF5KSB7XG4gIHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG59O1xuY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uKGdyYXkpIHtcbiAgcmV0dXJuIFtncmF5WzBdLCAwLCAwXTtcbn07XG5jb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24oZ3JheSkge1xuICBjb25zdCB2YWx1ZSA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAyNTU7XG4gIGNvbnN0IGludGVnZXIgPSAodmFsdWUgPDwgMTYpICsgKHZhbHVlIDw8IDgpICsgdmFsdWU7XG4gIGNvbnN0IHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBcIjAwMDAwMFwiLnNsaWNlKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcbmNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbihyZ2IpIHtcbiAgY29uc3QgdmFsdWUgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG4gIHJldHVybiBbdmFsdWUgLyAyNTUgKiAxMDBdO1xufTtcblxuLy8gbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvcm91dGUuanNcbmZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG4gIGNvbnN0IGdyYXBoID0ge307XG4gIGNvbnN0IG1vZGVsczIgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc19kZWZhdWx0KTtcbiAgZm9yIChsZXQgeyBsZW5ndGggfSA9IG1vZGVsczIsIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBncmFwaFttb2RlbHMyW2ldXSA9IHtcbiAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tLzEtdnMtaW5maW5pdHlcbiAgICAgIC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuICAgICAgZGlzdGFuY2U6IC0xLFxuICAgICAgcGFyZW50OiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZ3JhcGg7XG59XG5mdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG4gIGNvbnN0IGdyYXBoID0gYnVpbGRHcmFwaCgpO1xuICBjb25zdCBxdWV1ZSA9IFtmcm9tTW9kZWxdO1xuICBncmFwaFtmcm9tTW9kZWxdLmRpc3RhbmNlID0gMDtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcXVldWUucG9wKCk7XG4gICAgY29uc3QgYWRqYWNlbnRzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnNfZGVmYXVsdFtjdXJyZW50XSk7XG4gICAgZm9yIChsZXQgeyBsZW5ndGggfSA9IGFkamFjZW50cywgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG4gICAgICBjb25zdCBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuICAgICAgaWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG4gICAgICAgIG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG4gICAgICAgIG5vZGUucGFyZW50ID0gY3VycmVudDtcbiAgICAgICAgcXVldWUudW5zaGlmdChhZGphY2VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBncmFwaDtcbn1cbmZ1bmN0aW9uIGxpbmsoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gdG8oZnJvbShhcmdzKSk7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCkge1xuICBjb25zdCBwYXRoID0gW2dyYXBoW3RvTW9kZWxdLnBhcmVudCwgdG9Nb2RlbF07XG4gIGxldCBmbiA9IGNvbnZlcnNpb25zX2RlZmF1bHRbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcbiAgbGV0IGN1ciA9IGdyYXBoW3RvTW9kZWxdLnBhcmVudDtcbiAgd2hpbGUgKGdyYXBoW2N1cl0ucGFyZW50KSB7XG4gICAgcGF0aC51bnNoaWZ0KGdyYXBoW2N1cl0ucGFyZW50KTtcbiAgICBmbiA9IGxpbmsoY29udmVyc2lvbnNfZGVmYXVsdFtncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuICAgIGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuICB9XG4gIGZuLmNvbnZlcnNpb24gPSBwYXRoO1xuICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiByb3V0ZShmcm9tTW9kZWwpIHtcbiAgY29uc3QgZ3JhcGggPSBkZXJpdmVCRlMoZnJvbU1vZGVsKTtcbiAgY29uc3QgY29udmVyc2lvbiA9IHt9O1xuICBjb25zdCBtb2RlbHMyID0gT2JqZWN0LmtleXMoZ3JhcGgpO1xuICBmb3IgKGxldCB7IGxlbmd0aCB9ID0gbW9kZWxzMiwgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvTW9kZWwgPSBtb2RlbHMyW2ldO1xuICAgIGNvbnN0IG5vZGUgPSBncmFwaFt0b01vZGVsXTtcbiAgICBpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpO1xuICB9XG4gIHJldHVybiBjb252ZXJzaW9uO1xufVxudmFyIHJvdXRlX2RlZmF1bHQgPSByb3V0ZTtcblxuLy8gbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanNcbnZhciBjb252ZXJ0MiA9IHt9O1xudmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zX2RlZmF1bHQpO1xuZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgYXJnMCA9IGFyZ3NbMF07XG4gICAgaWYgKGFyZzAgPT09IHZvaWQgMCB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJnMDtcbiAgICB9XG4gICAgaWYgKGFyZzAubGVuZ3RoID4gMSkge1xuICAgICAgYXJncyA9IGFyZzA7XG4gICAgfVxuICAgIHJldHVybiBmbihhcmdzKTtcbiAgfTtcbiAgaWYgKFwiY29udmVyc2lvblwiIGluIGZuKSB7XG4gICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICB9XG4gIHJldHVybiB3cmFwcGVkRm47XG59XG5mdW5jdGlvbiB3cmFwUm91bmRlZChmbikge1xuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgYXJnMCA9IGFyZ3NbMF07XG4gICAgaWYgKGFyZzAgPT09IHZvaWQgMCB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJnMDtcbiAgICB9XG4gICAgaWYgKGFyZzAubGVuZ3RoID4gMSkge1xuICAgICAgYXJncyA9IGFyZzA7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGZuKGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGxldCB7IGxlbmd0aCB9ID0gcmVzdWx0LCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IE1hdGgucm91bmQocmVzdWx0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgaWYgKFwiY29udmVyc2lvblwiIGluIGZuKSB7XG4gICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICB9XG4gIHJldHVybiB3cmFwcGVkRm47XG59XG5mb3IgKGNvbnN0IGZyb21Nb2RlbCBvZiBtb2RlbHMpIHtcbiAgY29udmVydDJbZnJvbU1vZGVsXSA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydDJbZnJvbU1vZGVsXSwgXCJjaGFubmVsc1wiLCB7IHZhbHVlOiBjb252ZXJzaW9uc19kZWZhdWx0W2Zyb21Nb2RlbF0uY2hhbm5lbHMgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0Mltmcm9tTW9kZWxdLCBcImxhYmVsc1wiLCB7IHZhbHVlOiBjb252ZXJzaW9uc19kZWZhdWx0W2Zyb21Nb2RlbF0ubGFiZWxzIH0pO1xuICBjb25zdCByb3V0ZXMgPSByb3V0ZV9kZWZhdWx0KGZyb21Nb2RlbCk7XG4gIGNvbnN0IHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcbiAgZm9yIChjb25zdCB0b01vZGVsIG9mIHJvdXRlTW9kZWxzKSB7XG4gICAgY29uc3QgZm4gPSByb3V0ZXNbdG9Nb2RlbF07XG4gICAgY29udmVydDJbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcbiAgICBjb252ZXJ0Mltmcm9tTW9kZWxdW3RvTW9kZWxdLnJhdyA9IHdyYXBSYXcoZm4pO1xuICB9XG59XG52YXIgY29sb3JfY29udmVydF9kZWZhdWx0ID0gY29udmVydDI7XG5cbi8vIG5vZGVfbW9kdWxlcy9jb2xvci9pbmRleC5qc1xudmFyIHNraXBwZWRNb2RlbHMgPSBbXG4gIC8vIFRvIGJlIGhvbmVzdCwgSSBkb24ndCByZWFsbHkgZmVlbCBsaWtlIGtleXdvcmQgYmVsb25ncyBpbiBjb2xvciBjb252ZXJ0LCBidXQgZWguXG4gIFwia2V5d29yZFwiLFxuICAvLyBHcmF5IGNvbmZsaWN0cyB3aXRoIHNvbWUgbWV0aG9kIG5hbWVzLCBhbmQgaGFzIGl0cyBvd24gbWV0aG9kIGRlZmluZWQuXG4gIFwiZ3JheVwiLFxuICAvLyBTaG91bGRuJ3QgcmVhbGx5IGJlIGluIGNvbG9yLWNvbnZlcnQgZWl0aGVyLi4uXG4gIFwiaGV4XCJcbl07XG52YXIgaGFzaGVkTW9kZWxLZXlzID0ge307XG5mb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC5rZXlzKGNvbG9yX2NvbnZlcnRfZGVmYXVsdCkpIHtcbiAgaGFzaGVkTW9kZWxLZXlzW1suLi5jb2xvcl9jb252ZXJ0X2RlZmF1bHRbbW9kZWxdLmxhYmVsc10uc29ydCgpLmpvaW4oXCJcIildID0gbW9kZWw7XG59XG52YXIgbGltaXRlcnMgPSB7fTtcbmZ1bmN0aW9uIENvbG9yKG9iamVjdCwgbW9kZWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgIHJldHVybiBuZXcgQ29sb3Iob2JqZWN0LCBtb2RlbCk7XG4gIH1cbiAgaWYgKG1vZGVsICYmIG1vZGVsIGluIHNraXBwZWRNb2RlbHMpIHtcbiAgICBtb2RlbCA9IG51bGw7XG4gIH1cbiAgaWYgKG1vZGVsICYmICEobW9kZWwgaW4gY29sb3JfY29udmVydF9kZWZhdWx0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZWw6IFwiICsgbW9kZWwpO1xuICB9XG4gIGxldCBpO1xuICBsZXQgY2hhbm5lbHM7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRoaXMubW9kZWwgPSBcInJnYlwiO1xuICAgIHRoaXMuY29sb3IgPSBbMCwgMCwgMF07XG4gICAgdGhpcy52YWxwaGEgPSAxO1xuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgdGhpcy5tb2RlbCA9IG9iamVjdC5tb2RlbDtcbiAgICB0aGlzLmNvbG9yID0gWy4uLm9iamVjdC5jb2xvcl07XG4gICAgdGhpcy52YWxwaGEgPSBvYmplY3QudmFscGhhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb2xvcl9zdHJpbmdfZGVmYXVsdC5nZXQob2JqZWN0KTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmc6IFwiICsgb2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5tb2RlbCA9IHJlc3VsdC5tb2RlbDtcbiAgICBjaGFubmVscyA9IGNvbG9yX2NvbnZlcnRfZGVmYXVsdFt0aGlzLm1vZGVsXS5jaGFubmVscztcbiAgICB0aGlzLmNvbG9yID0gcmVzdWx0LnZhbHVlLnNsaWNlKDAsIGNoYW5uZWxzKTtcbiAgICB0aGlzLnZhbHBoYSA9IHR5cGVvZiByZXN1bHQudmFsdWVbY2hhbm5lbHNdID09PSBcIm51bWJlclwiID8gcmVzdWx0LnZhbHVlW2NoYW5uZWxzXSA6IDE7XG4gIH0gZWxzZSBpZiAob2JqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWwgfHwgXCJyZ2JcIjtcbiAgICBjaGFubmVscyA9IGNvbG9yX2NvbnZlcnRfZGVmYXVsdFt0aGlzLm1vZGVsXS5jaGFubmVscztcbiAgICBjb25zdCBuZXdBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iamVjdCwgMCwgY2hhbm5lbHMpO1xuICAgIHRoaXMuY29sb3IgPSB6ZXJvQXJyYXkobmV3QXJyYXksIGNoYW5uZWxzKTtcbiAgICB0aGlzLnZhbHBoYSA9IHR5cGVvZiBvYmplY3RbY2hhbm5lbHNdID09PSBcIm51bWJlclwiID8gb2JqZWN0W2NoYW5uZWxzXSA6IDE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHRoaXMubW9kZWwgPSBcInJnYlwiO1xuICAgIHRoaXMuY29sb3IgPSBbXG4gICAgICBvYmplY3QgPj4gMTYgJiAyNTUsXG4gICAgICBvYmplY3QgPj4gOCAmIDI1NSxcbiAgICAgIG9iamVjdCAmIDI1NVxuICAgIF07XG4gICAgdGhpcy52YWxwaGEgPSAxO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudmFscGhhID0gMTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoXCJhbHBoYVwiIGluIG9iamVjdCkge1xuICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKFwiYWxwaGFcIiksIDEpO1xuICAgICAgdGhpcy52YWxwaGEgPSB0eXBlb2Ygb2JqZWN0LmFscGhhID09PSBcIm51bWJlclwiID8gb2JqZWN0LmFscGhhIDogMDtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkS2V5cyA9IGtleXMuc29ydCgpLmpvaW4oXCJcIik7XG4gICAgaWYgKCEoaGFzaGVkS2V5cyBpbiBoYXNoZWRNb2RlbEtleXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG4gICAgfVxuICAgIHRoaXMubW9kZWwgPSBoYXNoZWRNb2RlbEtleXNbaGFzaGVkS2V5c107XG4gICAgY29uc3QgeyBsYWJlbHMgfSA9IGNvbG9yX2NvbnZlcnRfZGVmYXVsdFt0aGlzLm1vZGVsXTtcbiAgICBjb25zdCBjb2xvciA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbG9yLnB1c2gob2JqZWN0W2xhYmVsc1tpXV0pO1xuICAgIH1cbiAgICB0aGlzLmNvbG9yID0gemVyb0FycmF5KGNvbG9yKTtcbiAgfVxuICBpZiAobGltaXRlcnNbdGhpcy5tb2RlbF0pIHtcbiAgICBjaGFubmVscyA9IGNvbG9yX2NvbnZlcnRfZGVmYXVsdFt0aGlzLm1vZGVsXS5jaGFubmVscztcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuICAgICAgY29uc3QgbGltaXQgPSBsaW1pdGVyc1t0aGlzLm1vZGVsXVtpXTtcbiAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICB0aGlzLmNvbG9yW2ldID0gbGltaXQodGhpcy5jb2xvcltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMudmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy52YWxwaGEpKTtcbiAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG59XG5Db2xvci5wcm90b3R5cGUgPSB7XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZygpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5tb2RlbF0oKTtcbiAgfSxcbiAgc3RyaW5nKHBsYWNlcykge1xuICAgIGxldCBzZWxmID0gdGhpcy5tb2RlbCBpbiBjb2xvcl9zdHJpbmdfZGVmYXVsdC50byA/IHRoaXMgOiB0aGlzLnJnYigpO1xuICAgIHNlbGYgPSBzZWxmLnJvdW5kKHR5cGVvZiBwbGFjZXMgPT09IFwibnVtYmVyXCIgPyBwbGFjZXMgOiAxKTtcbiAgICBjb25zdCBhcmd1bWVudHNfID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogWy4uLnNlbGYuY29sb3IsIHRoaXMudmFscGhhXTtcbiAgICByZXR1cm4gY29sb3Jfc3RyaW5nX2RlZmF1bHQudG9bc2VsZi5tb2RlbF0oLi4uYXJndW1lbnRzXyk7XG4gIH0sXG4gIHBlcmNlbnRTdHJpbmcocGxhY2VzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMucmdiKCkucm91bmQodHlwZW9mIHBsYWNlcyA9PT0gXCJudW1iZXJcIiA/IHBsYWNlcyA6IDEpO1xuICAgIGNvbnN0IGFyZ3VtZW50c18gPSBzZWxmLnZhbHBoYSA9PT0gMSA/IHNlbGYuY29sb3IgOiBbLi4uc2VsZi5jb2xvciwgdGhpcy52YWxwaGFdO1xuICAgIHJldHVybiBjb2xvcl9zdHJpbmdfZGVmYXVsdC50by5yZ2IucGVyY2VudCguLi5hcmd1bWVudHNfKTtcbiAgfSxcbiAgYXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFscGhhID09PSAxID8gWy4uLnRoaXMuY29sb3JdIDogWy4uLnRoaXMuY29sb3IsIHRoaXMudmFscGhhXTtcbiAgfSxcbiAgb2JqZWN0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHsgY2hhbm5lbHMgfSA9IGNvbG9yX2NvbnZlcnRfZGVmYXVsdFt0aGlzLm1vZGVsXTtcbiAgICBjb25zdCB7IGxhYmVscyB9ID0gY29sb3JfY29udmVydF9kZWZhdWx0W3RoaXMubW9kZWxdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuICAgICAgcmVzdWx0W2xhYmVsc1tpXV0gPSB0aGlzLmNvbG9yW2ldO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcbiAgICAgIHJlc3VsdC5hbHBoYSA9IHRoaXMudmFscGhhO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICB1bml0QXJyYXkoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcbiAgICByZ2JbMF0gLz0gMjU1O1xuICAgIHJnYlsxXSAvPSAyNTU7XG4gICAgcmdiWzJdIC89IDI1NTtcbiAgICBpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcbiAgICAgIHJnYi5wdXNoKHRoaXMudmFscGhhKTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfSxcbiAgdW5pdE9iamVjdCgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLnJnYigpLm9iamVjdCgpO1xuICAgIHJnYi5yIC89IDI1NTtcbiAgICByZ2IuZyAvPSAyNTU7XG4gICAgcmdiLmIgLz0gMjU1O1xuICAgIGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuICAgICAgcmdiLmFscGhhID0gdGhpcy52YWxwaGE7XG4gICAgfVxuICAgIHJldHVybiByZ2I7XG4gIH0sXG4gIHJvdW5kKHBsYWNlcykge1xuICAgIHBsYWNlcyA9IE1hdGgubWF4KHBsYWNlcyB8fCAwLCAwKTtcbiAgICByZXR1cm4gbmV3IENvbG9yKFsuLi50aGlzLmNvbG9yLm1hcChyb3VuZFRvUGxhY2UocGxhY2VzKSksIHRoaXMudmFscGhhXSwgdGhpcy5tb2RlbCk7XG4gIH0sXG4gIGFscGhhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoWy4uLnRoaXMuY29sb3IsIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlKSldLCB0aGlzLm1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFscGhhO1xuICB9LFxuICAvLyBSZ2JcbiAgcmVkOiBnZXRzZXQoXCJyZ2JcIiwgMCwgbWF4Zm4oMjU1KSksXG4gIGdyZWVuOiBnZXRzZXQoXCJyZ2JcIiwgMSwgbWF4Zm4oMjU1KSksXG4gIGJsdWU6IGdldHNldChcInJnYlwiLCAyLCBtYXhmbigyNTUpKSxcbiAgaHVlOiBnZXRzZXQoW1wiaHNsXCIsIFwiaHN2XCIsIFwiaHNsXCIsIFwiaHdiXCIsIFwiaGNnXCJdLCAwLCAodmFsdWUpID0+ICh2YWx1ZSAlIDM2MCArIDM2MCkgJSAzNjApLFxuICBzYXR1cmF0aW9ubDogZ2V0c2V0KFwiaHNsXCIsIDEsIG1heGZuKDEwMCkpLFxuICBsaWdodG5lc3M6IGdldHNldChcImhzbFwiLCAyLCBtYXhmbigxMDApKSxcbiAgc2F0dXJhdGlvbnY6IGdldHNldChcImhzdlwiLCAxLCBtYXhmbigxMDApKSxcbiAgdmFsdWU6IGdldHNldChcImhzdlwiLCAyLCBtYXhmbigxMDApKSxcbiAgY2hyb21hOiBnZXRzZXQoXCJoY2dcIiwgMSwgbWF4Zm4oMTAwKSksXG4gIGdyYXk6IGdldHNldChcImhjZ1wiLCAyLCBtYXhmbigxMDApKSxcbiAgd2hpdGU6IGdldHNldChcImh3YlwiLCAxLCBtYXhmbigxMDApKSxcbiAgd2JsYWNrOiBnZXRzZXQoXCJod2JcIiwgMiwgbWF4Zm4oMTAwKSksXG4gIGN5YW46IGdldHNldChcImNteWtcIiwgMCwgbWF4Zm4oMTAwKSksXG4gIG1hZ2VudGE6IGdldHNldChcImNteWtcIiwgMSwgbWF4Zm4oMTAwKSksXG4gIHllbGxvdzogZ2V0c2V0KFwiY215a1wiLCAyLCBtYXhmbigxMDApKSxcbiAgYmxhY2s6IGdldHNldChcImNteWtcIiwgMywgbWF4Zm4oMTAwKSksXG4gIHg6IGdldHNldChcInh5elwiLCAwLCBtYXhmbig5NS4wNDcpKSxcbiAgeTogZ2V0c2V0KFwieHl6XCIsIDEsIG1heGZuKDEwMCkpLFxuICB6OiBnZXRzZXQoXCJ4eXpcIiwgMiwgbWF4Zm4oMTA4LjgzMykpLFxuICBsOiBnZXRzZXQoXCJsYWJcIiwgMCwgbWF4Zm4oMTAwKSksXG4gIGE6IGdldHNldChcImxhYlwiLCAxKSxcbiAgYjogZ2V0c2V0KFwibGFiXCIsIDIpLFxuICBrZXl3b3JkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29sb3IodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3JfY29udmVydF9kZWZhdWx0W3RoaXMubW9kZWxdLmtleXdvcmQodGhpcy5jb2xvcik7XG4gIH0sXG4gIGhleCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbG9yKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yX3N0cmluZ19kZWZhdWx0LnRvLmhleCguLi50aGlzLnJnYigpLnJvdW5kKCkuY29sb3IpO1xuICB9LFxuICBoZXhhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29sb3IodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCByZ2JBcnJheSA9IHRoaXMucmdiKCkucm91bmQoKS5jb2xvcjtcbiAgICBsZXQgYWxwaGFIZXggPSBNYXRoLnJvdW5kKHRoaXMudmFscGhhICogMjU1KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoYWxwaGFIZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICBhbHBoYUhleCA9IFwiMFwiICsgYWxwaGFIZXg7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcl9zdHJpbmdfZGVmYXVsdC50by5oZXgoLi4ucmdiQXJyYXkpICsgYWxwaGFIZXg7XG4gIH0sXG4gIHJnYk51bWJlcigpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuICAgIHJldHVybiAocmdiWzBdICYgMjU1KSA8PCAxNiB8IChyZ2JbMV0gJiAyNTUpIDw8IDggfCByZ2JbMl0gJiAyNTU7XG4gIH0sXG4gIGx1bWlub3NpdHkoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcbiAgICBjb25zdCBsdW0gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpLCBlbGVtZW50XSBvZiByZ2IuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBjaGFuID0gZWxlbWVudCAvIDI1NTtcbiAgICAgIGx1bVtpXSA9IGNoYW4gPD0gMC4wNDA0NSA/IGNoYW4gLyAxMi45MiA6ICgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gICAgfVxuICAgIHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG4gIH0sXG4gIGNvbnRyYXN0KGNvbG9yMikge1xuICAgIGNvbnN0IGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcbiAgICBjb25zdCBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcbiAgICBpZiAobHVtMSA+IGx1bTIpIHtcbiAgICAgIHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcbiAgICB9XG4gICAgcmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuICB9LFxuICBsZXZlbChjb2xvcjIpIHtcbiAgICBjb25zdCBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuICAgIGlmIChjb250cmFzdFJhdGlvID49IDcpIHtcbiAgICAgIHJldHVybiBcIkFBQVwiO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJhc3RSYXRpbyA+PSA0LjUgPyBcIkFBXCIgOiBcIlwiO1xuICB9LFxuICBpc0RhcmsoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcbiAgICBjb25zdCB5aXEgPSAocmdiWzBdICogMjEyNiArIHJnYlsxXSAqIDcxNTIgKyByZ2JbMl0gKiA3MjIpIC8gMWU0O1xuICAgIHJldHVybiB5aXEgPCAxMjg7XG4gIH0sXG4gIGlzTGlnaHQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzRGFyaygpO1xuICB9LFxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5yZ2IoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgcmdiLmNvbG9yW2ldID0gMjU1IC0gcmdiLmNvbG9yW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9LFxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgY29uc3QgaHNsID0gdGhpcy5oc2woKTtcbiAgICBoc2wuY29sb3JbMl0gKz0gaHNsLmNvbG9yWzJdICogcmF0aW87XG4gICAgcmV0dXJuIGhzbDtcbiAgfSxcbiAgZGFya2VuKHJhdGlvKSB7XG4gICAgY29uc3QgaHNsID0gdGhpcy5oc2woKTtcbiAgICBoc2wuY29sb3JbMl0gLT0gaHNsLmNvbG9yWzJdICogcmF0aW87XG4gICAgcmV0dXJuIGhzbDtcbiAgfSxcbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBjb25zdCBoc2wgPSB0aGlzLmhzbCgpO1xuICAgIGhzbC5jb2xvclsxXSArPSBoc2wuY29sb3JbMV0gKiByYXRpbztcbiAgICByZXR1cm4gaHNsO1xuICB9LFxuICBkZXNhdHVyYXRlKHJhdGlvKSB7XG4gICAgY29uc3QgaHNsID0gdGhpcy5oc2woKTtcbiAgICBoc2wuY29sb3JbMV0gLT0gaHNsLmNvbG9yWzFdICogcmF0aW87XG4gICAgcmV0dXJuIGhzbDtcbiAgfSxcbiAgd2hpdGVuKHJhdGlvKSB7XG4gICAgY29uc3QgaHdiID0gdGhpcy5od2IoKTtcbiAgICBod2IuY29sb3JbMV0gKz0gaHdiLmNvbG9yWzFdICogcmF0aW87XG4gICAgcmV0dXJuIGh3YjtcbiAgfSxcbiAgYmxhY2tlbihyYXRpbykge1xuICAgIGNvbnN0IGh3YiA9IHRoaXMuaHdiKCk7XG4gICAgaHdiLmNvbG9yWzJdICs9IGh3Yi5jb2xvclsyXSAqIHJhdGlvO1xuICAgIHJldHVybiBod2I7XG4gIH0sXG4gIGdyYXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuICAgIGNvbnN0IHZhbHVlID0gcmdiWzBdICogMC4zICsgcmdiWzFdICogMC41OSArIHJnYlsyXSAqIDAuMTE7XG4gICAgcmV0dXJuIENvbG9yLnJnYih2YWx1ZSwgdmFsdWUsIHZhbHVlKTtcbiAgfSxcbiAgZmFkZShyYXRpbykge1xuICAgIHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhIC0gdGhpcy52YWxwaGEgKiByYXRpbyk7XG4gIH0sXG4gIG9wYXF1ZXIocmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSArIHRoaXMudmFscGhhICogcmF0aW8pO1xuICB9LFxuICByb3RhdGUoZGVncmVlcykge1xuICAgIGNvbnN0IGhzbCA9IHRoaXMuaHNsKCk7XG4gICAgbGV0IGh1ZSA9IGhzbC5jb2xvclswXTtcbiAgICBodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG4gICAgaHVlID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICBoc2wuY29sb3JbMF0gPSBodWU7XG4gICAgcmV0dXJuIGhzbDtcbiAgfSxcbiAgbWl4KG1peGluQ29sb3IsIHdlaWdodCkge1xuICAgIGlmICghbWl4aW5Db2xvciB8fCAhbWl4aW5Db2xvci5yZ2IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gXCJtaXhcIiB3YXMgbm90IGEgQ29sb3IgaW5zdGFuY2UsIGJ1dCByYXRoZXIgYW4gaW5zdGFuY2Ugb2YgJyArIHR5cGVvZiBtaXhpbkNvbG9yKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3IxID0gbWl4aW5Db2xvci5yZ2IoKTtcbiAgICBjb25zdCBjb2xvcjIgPSB0aGlzLnJnYigpO1xuICAgIGNvbnN0IHAgPSB3ZWlnaHQgPT09IHZvaWQgMCA/IDAuNSA6IHdlaWdodDtcbiAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgIGNvbnN0IGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuICAgIGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMjtcbiAgICBjb25zdCB3MiA9IDEgLSB3MTtcbiAgICByZXR1cm4gQ29sb3IucmdiKFxuICAgICAgdzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcbiAgICAgIHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuICAgICAgdzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpLFxuICAgICAgY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApXG4gICAgKTtcbiAgfVxufTtcbmZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoY29sb3JfY29udmVydF9kZWZhdWx0KSkge1xuICBpZiAoc2tpcHBlZE1vZGVscy5pbmNsdWRlcyhtb2RlbCkpIHtcbiAgICBjb250aW51ZTtcbiAgfVxuICBjb25zdCB7IGNoYW5uZWxzIH0gPSBjb2xvcl9jb252ZXJ0X2RlZmF1bHRbbW9kZWxdO1xuICBDb2xvci5wcm90b3R5cGVbbW9kZWxdID0gZnVuY3Rpb24oLi4uYXJndW1lbnRzXykge1xuICAgIGlmICh0aGlzLm1vZGVsID09PSBtb2RlbCkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50c18ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcihhcmd1bWVudHNfLCBtb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29sb3IoWy4uLmFzc2VydEFycmF5KGNvbG9yX2NvbnZlcnRfZGVmYXVsdFt0aGlzLm1vZGVsXVttb2RlbF0ucmF3KHRoaXMuY29sb3IpKSwgdGhpcy52YWxwaGFdLCBtb2RlbCk7XG4gIH07XG4gIENvbG9yW21vZGVsXSA9IGZ1bmN0aW9uKC4uLmFyZ3VtZW50c18pIHtcbiAgICBsZXQgY29sb3IgPSBhcmd1bWVudHNfWzBdO1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbG9yID0gemVyb0FycmF5KGFyZ3VtZW50c18sIGNoYW5uZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihjb2xvciwgbW9kZWwpO1xuICB9O1xufVxuZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIHBsYWNlcykge1xuICByZXR1cm4gTnVtYmVyKG51bWJlci50b0ZpeGVkKHBsYWNlcykpO1xufVxuZnVuY3Rpb24gcm91bmRUb1BsYWNlKHBsYWNlcykge1xuICByZXR1cm4gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgcmV0dXJuIHJvdW5kVG8obnVtYmVyLCBwbGFjZXMpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0c2V0KG1vZGVsLCBjaGFubmVsLCBtb2RpZmllcikge1xuICBtb2RlbCA9IEFycmF5LmlzQXJyYXkobW9kZWwpID8gbW9kZWwgOiBbbW9kZWxdO1xuICBmb3IgKGNvbnN0IG0gb2YgbW9kZWwpIHtcbiAgICAobGltaXRlcnNbbV0gfHw9IFtdKVtjaGFubmVsXSA9IG1vZGlmaWVyO1xuICB9XG4gIG1vZGVsID0gbW9kZWxbMF07XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICB2YWx1ZSA9IG1vZGlmaWVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHRoaXNbbW9kZWxdKCk7XG4gICAgICByZXN1bHQuY29sb3JbY2hhbm5lbF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdCA9IHRoaXNbbW9kZWxdKCkuY29sb3JbY2hhbm5lbF07XG4gICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBtb2RpZmllcihyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gbWF4Zm4obWF4KSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgdikpO1xuICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gemVyb0FycmF5KGFycmF5LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgYXJyYXlbaV0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFycmF5W2ldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxudmFyIGluZGV4X2RlZmF1bHQgPSBDb2xvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/color.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/index.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/index.cjs ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./color.cjs */ \"(rsc)/./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/color.cjs\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGltZytjb2xvdXJAMS4wLjAvbm9kZV9tb2R1bGVzL0BpbWcvY29sb3VyL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxxSkFBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVucm91dGVyLWxhbmdncmFwaC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaW1nK2NvbG91ckAxLjAuMC9ub2RlX21vZHVsZXMvQGltZy9jb2xvdXIvaW5kZXguY2pzPzA3ZWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9jb2xvci5janNcIikuZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@img+colour@1.0.0/node_modules/@img/colour/index.cjs\n");

/***/ })

};
;